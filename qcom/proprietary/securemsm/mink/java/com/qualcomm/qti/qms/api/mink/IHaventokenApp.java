// AUTOGENERATED FILE: DO NOT EDIT

package com.qualcomm.qti.qms.api.mink;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/* Copyright (c) 2018 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
/** @cond */
public interface IHavenTokenApp {
  int IHavenTokenApp_SIG_SEC_LEVEL_HW = 7;
  int IHavenTokenApp_SIG_SEC_LEVEL_SEK = 6;
  int IHavenTokenApp_SIG_SEC_LEVEL_SEU = 5;
  int IHavenTokenApp_SIG_SEC_LEVEL_TEEK = 4;
  int IHavenTokenApp_SIG_SEC_LEVEL_TEEU = 3;
  int IHavenTokenApp_SIG_SEC_LEVEL_RICHOSK = 2;
  int IHavenTokenApp_SIG_SEC_LEVEL_RICHOSU = 1;
  int IHavenTokenApp_KEYTYPE_NONE = 0;
  int IHavenTokenApp_KEYTYPE_DEMO = 1;
  int IHavenTokenApp_KEYTYPE_GROUPLOW = 2;
  int IHavenTokenApp_KEYTYPE_GROUP = 3;
  int IHavenTokenApp_KEYTYPE_PERCHIP = 4;
  int IHavenTokenApp_KEYTYPE_RESERVED_1 = 5;
  int IHavenTokenApp_KEYTYPE_RESERVED_2 = 6;
  int IHavenTokenApp_KEYTYPE_GROUPTEST = 7;
  int IHavenTokenApp_KEYTYPE_BEST_PRIVACY_PRESERVING_AVAILABLE = 8;
  long IHavenTokenApp_OPT_SIMDATA = 0x0000000000000001;
  long IHavenTokenApp_OPT_APPCERT = 0x0000000000000002;
  long IHavenTokenApp_OPT_LOCATION = 0x0000000000000004;
  long IHavenTokenApp_OPT_LONGRTIC = 0x0000000000000008;
  long IHavenTokenApp_OPT_RTIC_CURRENT = 0x0000000000000020;
  long IHavenTokenApp_OPT_CIPHER_SUITE_1 = 0x0000000000000100;
  long IHavenTokenApp_OPT_CIPHER_SUITE_2 = 0x0000000000000200;
  long IHavenTokenApp_OPT_CIPHER_SUITE_3 = 0x0000000000000400;
  int IHavenTokenApp_LICENSE_OPT_NO_OEMID_CHECK = 0x00000001;
  int IHavenTokenApp_LICENSE_OPT_NO_HWVERSION_CHECK = 0x00000002;
  int IHavenTokenApp_LICENSE_OPT_NO_FEATUREID_CHECK = 0x00000004;
  int IHavenTokenApp_LICENSE_OPT_NO_TIME_CHECK = 0x00000008;
  int IHavenTokenApp_LICENSE_OPT_CLOCK_NOT_SET_OK = 0x00000010;
  int IHavenTokenApp_LICENSE_OPT_SELECT_TEST_ROOT = 0x00000020;
  int IHavenTokenApp_LICENSE_OPT_USAGE_ENCRYPT = 0x00000040;

  int IHavenTokenApp_ERROR_NOMEM = 10;
  int IHavenTokenApp_ERROR_SIGNING_KEY_UNAVAIL = 11;
  int IHavenTokenApp_ERROR_CBOR_ENCODE_ERR = 12;
  int IHavenTokenApp_ERROR_CERT_PKHASH = 13;
  int IHavenTokenApp_ERROR_INVALID_CERT = 14;
  int IHavenTokenApp_ERROR_CERT_FEATUREID = 15;
  int IHavenTokenApp_ERROR_CERT_EXPIRED_OR_NOTYETVALID = 16;
  int IHavenTokenApp_ERROR_CERT_OEM = 17;
  int IHavenTokenApp_ERROR_CERT_HWVERSION = 18;
  int IHavenTokenApp_ERROR_CERT_ISVCERTHASH = 19;
  int IHavenTokenApp_ERROR_DATA_MARSHAL = 20;
  int IHavenTokenApp_ERROR_HASH_GENERATION = 21;
  int IHavenTokenApp_ERROR_CERT_NOT_TRUSTED = 22;
  int IHavenTokenApp_ERROR_CERT_GENERAL_ERR = 23;
  int IHavenTokenApp_ERROR_DATA_TOO_BIG = 24;
  int IHavenTokenApp_ERROR_OFFSET_TOO_LARGE = 25;
  int IHavenTokenApp_ERROR_OUT_OF_ORDER = 26;
  int IHavenTokenApp_ERROR_NO_DATA = 27;
  int IHavenTokenApp_ERROR_RPMB_ERR = 28;
  int IHavenTokenApp_ERROR_ENCRYPTION = 29;
  int IHavenTokenApp_ERROR_NOT_ALLOWED = 30;
  int IHavenTokenApp_ERROR_LICENSE_TOO_BIG = 31;
  int IHavenTokenApp_ERROR_PRIVILEGE_ERR = 32;
  int IHavenTokenApp_ERROR_TOO_MUCH_APPDATA = 33;
  int IHavenTokenApp_ERROR_SECURITYLEVEL_NOT_SUPPORTED = 34;
  int IHavenTokenApp_ERROR_UNSUPPORTED_PAYLOAD_HASH = 35;
  int IHavenTokenApp_ERROR_SIGNING_ERR = 36;
  int IHavenTokenApp_ERROR_DEVICE_NOT_SECURE = 37;
  int IHavenTokenApp_ERROR_GROUPKEY_ERR = 38;

  int IHavenTokenApp_OP_start = 0;
  int IHavenTokenApp_OP_addDataItem = 1;
  int IHavenTokenApp_OP_getSize = 2;
  int IHavenTokenApp_OP_getBytes = 3;
  int IHavenTokenApp_OP_finish = 4;
  int IHavenTokenApp_OP_setTime = 5;
  int IHavenTokenApp_OP_processLicense = 6;
  int IHavenTokenApp_OP_processLicense_TEE = 7;

  void start(int uKeySelect_val, long nOpts_val, byte[] LicenseCert_val) throws IMinkObject.InvokeException;

  void addDataItem(byte[] DataItem_val, byte[] Label_val, byte[] Data_val) throws IMinkObject.InvokeException;

  void getSize(long[] pnSize_ptr) throws IMinkObject.InvokeException;

  void getBytes(long uOffset_val, byte[][] pBuffer_ptr, int pBuffer_len) throws IMinkObject.InvokeException;

  void finish() throws IMinkObject.InvokeException;

  void setTime(long UTCTime_val) throws IMinkObject.InvokeException;

  void processLicense(byte[] LicenseCert_val, int OptFlags_val, byte[] IntermediateCert_val, int FeatureID_val, byte[] ISVCertHash_val, byte[][] Licensee_ptr, int Licensee_len, byte[][] Issuer_ptr, int Issuer_len, byte[][] SerialNumber_ptr, int SerialNumber_len, byte[][] PublicKey_ptr, int PublicKey_len) throws IMinkObject.InvokeException;

  void processLicense_TEE(byte[] LicenseCert_val, int OptFlags_val, byte[] IntermediateCert_val, int FeatureID_val, byte[] ISVCertHash_val, byte[][] Licensee_ptr, int Licensee_len, byte[][] Issuer_ptr, int Issuer_len, byte[][] SerialNumber_ptr, int SerialNumber_len, byte[][] PublicKey_ptr, int PublicKey_len, long[] CalleeID_ptr) throws IMinkObject.InvokeException;

  class Proxy extends MinkProxy implements IHavenTokenApp {
    public Proxy(IMinkObject o) {
      super(o);
    }

    @Override
    public void start(int uKeySelect_val, long nOpts_val, byte[] LicenseCert_val) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[2][];
      bi[0] = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN).putLong(nOpts_val).putInt(uKeySelect_val).array();
      bi[1] = LicenseCert_val;

      minkObject.invoke(IHavenTokenApp_OP_start,bi,null,null,null,null);
    }
    @Override
    public void addDataItem(byte[] DataItem_val, byte[] Label_val, byte[] Data_val) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[3][];
      bi[0] = DataItem_val;
      bi[1] = Label_val;
      bi[2] = Data_val;

      minkObject.invoke(IHavenTokenApp_OP_addDataItem,bi,null,null,null,null);
    }
    @Override
    public void getSize(long[] pnSize_ptr) throws IMinkObject.InvokeException {
      byte[][] bo = new byte[1][];
      int[] boSizes = new int[1];
      boSizes[0] = 8;

      minkObject.invoke(IHavenTokenApp_OP_getSize,null,boSizes,bo,null,null);

      ByteBuffer bundleOut = ByteBuffer.wrap(bo[0]).order(ByteOrder.LITTLE_ENDIAN);
      if (pnSize_ptr != null) {
        pnSize_ptr[0] = bundleOut.getLong();
      }

    }
    @Override
    public void getBytes(long uOffset_val, byte[][] pBuffer_ptr, int pBuffer_len) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[1][];
      byte[][] bo = new byte[1][];
      int[] boSizes = new int[1];
      bi[0] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(uOffset_val).array();
      boSizes[0] = pBuffer_len;

      minkObject.invoke(IHavenTokenApp_OP_getBytes,bi,boSizes,bo,null,null);

      if (pBuffer_ptr != null) {
        int pBuffer_lenout = Math.min(bo[0].length, pBuffer_len);
        pBuffer_ptr[0] = new byte[pBuffer_lenout];
        System.arraycopy(bo[0], 0, pBuffer_ptr[0], 0, pBuffer_lenout);
      }

    }
    @Override
    public void finish() throws IMinkObject.InvokeException {
      minkObject.invoke(IHavenTokenApp_OP_finish,null,null,null,null,null);
    }
    @Override
    public void setTime(long UTCTime_val) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[1][];
      bi[0] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(UTCTime_val).array();

      minkObject.invoke(IHavenTokenApp_OP_setTime,bi,null,null,null,null);
    }
    @Override
    public void processLicense(byte[] LicenseCert_val, int OptFlags_val, byte[] IntermediateCert_val, int FeatureID_val, byte[] ISVCertHash_val, byte[][] Licensee_ptr, int Licensee_len, byte[][] Issuer_ptr, int Issuer_len, byte[][] SerialNumber_ptr, int SerialNumber_len, byte[][] PublicKey_ptr, int PublicKey_len) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[4][];
      byte[][] bo = new byte[4][];
      int[] boSizes = new int[4];
      bi[0] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putInt(OptFlags_val).putInt(FeatureID_val).array();
      bi[1] = LicenseCert_val;
      bi[2] = IntermediateCert_val;
      bi[3] = ISVCertHash_val;
      boSizes[0] = Licensee_len;
      boSizes[1] = Issuer_len;
      boSizes[2] = SerialNumber_len;
      boSizes[3] = PublicKey_len;

      minkObject.invoke(IHavenTokenApp_OP_processLicense,bi,boSizes,bo,null,null);

      if (Licensee_ptr != null) {
        int Licensee_lenout = Math.min(bo[0].length, Licensee_len);
        Licensee_ptr[0] = new byte[Licensee_lenout];
        System.arraycopy(bo[0], 0, Licensee_ptr[0], 0, Licensee_lenout);
      }
      if (Issuer_ptr != null) {
        int Issuer_lenout = Math.min(bo[1].length, Issuer_len);
        Issuer_ptr[0] = new byte[Issuer_lenout];
        System.arraycopy(bo[1], 0, Issuer_ptr[0], 0, Issuer_lenout);
      }
      if (SerialNumber_ptr != null) {
        int SerialNumber_lenout = Math.min(bo[2].length, SerialNumber_len);
        SerialNumber_ptr[0] = new byte[SerialNumber_lenout];
        System.arraycopy(bo[2], 0, SerialNumber_ptr[0], 0, SerialNumber_lenout);
      }
      if (PublicKey_ptr != null) {
        int PublicKey_lenout = Math.min(bo[3].length, PublicKey_len);
        PublicKey_ptr[0] = new byte[PublicKey_lenout];
        System.arraycopy(bo[3], 0, PublicKey_ptr[0], 0, PublicKey_lenout);
      }

    }
    @Override
    public void processLicense_TEE(byte[] LicenseCert_val, int OptFlags_val, byte[] IntermediateCert_val, int FeatureID_val, byte[] ISVCertHash_val, byte[][] Licensee_ptr, int Licensee_len, byte[][] Issuer_ptr, int Issuer_len, byte[][] SerialNumber_ptr, int SerialNumber_len, byte[][] PublicKey_ptr, int PublicKey_len, long[] CalleeID_ptr) throws IMinkObject.InvokeException {
      byte[][] bi = new byte[4][];
      byte[][] bo = new byte[5][];
      int[] boSizes = new int[5];
      bi[0] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putInt(OptFlags_val).putInt(FeatureID_val).array();
      bi[1] = LicenseCert_val;
      bi[2] = IntermediateCert_val;
      bi[3] = ISVCertHash_val;
      boSizes[0] = Licensee_len;
      boSizes[1] = Issuer_len;
      boSizes[2] = SerialNumber_len;
      boSizes[3] = PublicKey_len;
      boSizes[4] = 8;

      minkObject.invoke(IHavenTokenApp_OP_processLicense_TEE,bi,boSizes,bo,null,null);

      if (Licensee_ptr != null) {
        int Licensee_lenout = Math.min(bo[0].length, Licensee_len);
        Licensee_ptr[0] = new byte[Licensee_lenout];
        System.arraycopy(bo[0], 0, Licensee_ptr[0], 0, Licensee_lenout);
      }
      if (Issuer_ptr != null) {
        int Issuer_lenout = Math.min(bo[1].length, Issuer_len);
        Issuer_ptr[0] = new byte[Issuer_lenout];
        System.arraycopy(bo[1], 0, Issuer_ptr[0], 0, Issuer_lenout);
      }
      if (SerialNumber_ptr != null) {
        int SerialNumber_lenout = Math.min(bo[2].length, SerialNumber_len);
        SerialNumber_ptr[0] = new byte[SerialNumber_lenout];
        System.arraycopy(bo[2], 0, SerialNumber_ptr[0], 0, SerialNumber_lenout);
      }
      if (PublicKey_ptr != null) {
        int PublicKey_lenout = Math.min(bo[3].length, PublicKey_len);
        PublicKey_ptr[0] = new byte[PublicKey_lenout];
        System.arraycopy(bo[3], 0, PublicKey_ptr[0], 0, PublicKey_lenout);
      }
      ByteBuffer bundleOut = ByteBuffer.wrap(bo[4]).order(ByteOrder.LITTLE_ENDIAN);
      if (CalleeID_ptr != null) {
        CalleeID_ptr[0] = bundleOut.getLong();
      }

    }

  }
/* Copyright (c) 2018 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
  class MinkObject extends JMinkObject {
    private IHavenTokenApp mObj;
    public MinkObject(IHavenTokenApp obj) {
      super();
      mObj = obj;
    }
    @Override
    public void retain() {
      super.retain();
    }
    @Override
    public void release() {
      super.release();
      if (mRefs.get() == 0) mObj = null;
    }
    @Override
    public boolean isNull() {
      return mObj == null;
    }
    public void invoke(int methodID, byte[][] bi, int[] boSizes, byte[][] bo, IMinkObject[] oi, IMinkObject[] oo)throws IMinkObject.InvokeException {
      if (null == mObj) throw new IMinkObject.InvokeException(IMinkObject.ERROR_BADOBJ);
      switch (methodID) {
        case IHavenTokenApp_OP_start: {
          if (bi[0].length != 12) {
            break;
          }
          ByteBuffer bundleIn = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN);
          long nOpts=bundleIn.getLong();
          int uKeySelect=bundleIn.getInt();
          byte[] LicenseCert = ByteBuffer.wrap(bi[1]).order(ByteOrder.LITTLE_ENDIAN).array();
          mObj.start(uKeySelect,nOpts,LicenseCert);
          return;
        }
        case IHavenTokenApp_OP_addDataItem: {
          byte[] DataItem = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] Label = ByteBuffer.wrap(bi[1]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] Data = ByteBuffer.wrap(bi[2]).order(ByteOrder.LITTLE_ENDIAN).array();
          mObj.addDataItem(DataItem,Label,Data);
          return;
        }
        case IHavenTokenApp_OP_getSize: {
          if (boSizes[0] != 8) {
            break;
          }
          long[] pnSize_ptr = new long[1];
          mObj.getSize(pnSize_ptr);
          bo[0] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(pnSize_ptr[0]).array();
          return;
        }
        case IHavenTokenApp_OP_getBytes: {
          if (bi[0].length != 8) {
            break;
          }
          long uOffset = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN).getLong();
          byte[][] pBuffer = new byte[1][];
          int pBuffer_len = boSizes[0];
          mObj.getBytes(uOffset,pBuffer,pBuffer_len);
          bo[0]=pBuffer[0];
          return;
        }
        case IHavenTokenApp_OP_finish: {
          mObj.finish();
          return;
        }
        case IHavenTokenApp_OP_setTime: {
          if (bi[0].length != 8) {
            break;
          }
          long UTCTime = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN).getLong();
          mObj.setTime(UTCTime);
          return;
        }
        case IHavenTokenApp_OP_processLicense: {
          if (bi[0].length != 8) {
            break;
          }
          ByteBuffer bundleIn = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN);
          int OptFlags=bundleIn.getInt();
          int FeatureID=bundleIn.getInt();
          byte[] LicenseCert = ByteBuffer.wrap(bi[1]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] IntermediateCert = ByteBuffer.wrap(bi[2]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] ISVCertHash = ByteBuffer.wrap(bi[3]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[][] Licensee = new byte[1][];
          int Licensee_len = boSizes[0];
          byte[][] Issuer = new byte[1][];
          int Issuer_len = boSizes[1];
          byte[][] SerialNumber = new byte[1][];
          int SerialNumber_len = boSizes[2];
          byte[][] PublicKey = new byte[1][];
          int PublicKey_len = boSizes[3];
          mObj.processLicense(LicenseCert,OptFlags,IntermediateCert,FeatureID,ISVCertHash,Licensee,Licensee_len,Issuer,Issuer_len,SerialNumber,SerialNumber_len,PublicKey,PublicKey_len);
          bo[0]=Licensee[0];
          bo[1]=Issuer[0];
          bo[2]=SerialNumber[0];
          bo[3]=PublicKey[0];
          return;
        }
        case IHavenTokenApp_OP_processLicense_TEE: {
          if (bi[0].length != 8||
            boSizes[4] != 8) {
            break;
          }
          ByteBuffer bundleIn = ByteBuffer.wrap(bi[0]).order(ByteOrder.LITTLE_ENDIAN);
          int OptFlags=bundleIn.getInt();
          int FeatureID=bundleIn.getInt();
          byte[] LicenseCert = ByteBuffer.wrap(bi[1]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] IntermediateCert = ByteBuffer.wrap(bi[2]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[] ISVCertHash = ByteBuffer.wrap(bi[3]).order(ByteOrder.LITTLE_ENDIAN).array();
          byte[][] Licensee = new byte[1][];
          int Licensee_len = boSizes[0];
          byte[][] Issuer = new byte[1][];
          int Issuer_len = boSizes[1];
          byte[][] SerialNumber = new byte[1][];
          int SerialNumber_len = boSizes[2];
          byte[][] PublicKey = new byte[1][];
          int PublicKey_len = boSizes[3];
          long[] CalleeID_ptr = new long[1];
          mObj.processLicense_TEE(LicenseCert,OptFlags,IntermediateCert,FeatureID,ISVCertHash,Licensee,Licensee_len,Issuer,Issuer_len,SerialNumber,SerialNumber_len,PublicKey,PublicKey_len,CalleeID_ptr);
          bo[0]=Licensee[0];
          bo[1]=Issuer[0];
          bo[2]=SerialNumber[0];
          bo[3]=PublicKey[0];
          bo[4] = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(CalleeID_ptr[0]).array();
          return;
        }
        default:throw new IMinkObject.InvokeException(IMinkObject.ERROR_INVALID);
      }
    }

  }

}
