/******************************************************************************
#  Copyright (c) 2012-2013, 2017 Qualcomm Technologies, Inc.
#  All Rights Reserved.
#  Confidential and Proprietary - Qualcomm Technologies, Inc.
#******************************************************************************/
/******************************************************************************
  @file    qcril_qmi_voice.c
  @brief   qcril qmi - voice

  DESCRIPTION
    Handles RIL requests, Callbacks, indications for QMI VOICE.

******************************************************************************/


/*===========================================================================

                           INCLUDE FILES

===========================================================================*/

#include <errno.h>
#include <cutils/memory.h>
#include <cutils/properties.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h>
#include "telephony/ril.h"
#include "IxErrno.h"
#include "comdef.h"
#include "qcrili.h"
#include "qcril_reqlist.h"
#include "modules/nas/qcril_arb.h"
#include "qcril_qmi_voice.h"
#include "qcril_qmi_client.h"
#include "qcril_cm_ss.h"
#include "qcril_cmi.h"
#include "qcril_pbm.h"
#include "qcril_memory_management.h"
#include "modules/nas/qcril_qmi_nas.h"
#include "qcril_qmi_ims_radio_agent.h"
#include "qcril_qmi_ims_misc.h"
#include "qcril_qmi_pil_monitor.h"
#include "qcril_am.h"
#include "qcril_qmi_npb_utils.h"
#include "qcril_pd_notifier.h"
#include <translators/android/utils.h>
#ifdef QMI_RIL_UTF
extern "C" {
#include <ril_utf_wake_lock_redef.h>
}
#else
#include <hardware_legacy/power.h>
#endif
#include "qcril_other.h"
#include "modules/nas/qcril_db.h"

// required for glibc compile
#include <limits.h>

#ifdef QMI_RIL_UTF
#include <netdb.h>
#endif

#include "qcril_qmi_oem_events.h"
#include <memory>
#include "modules/qmi/QmiStruct.h"
#include "modules/qmi/VoiceModemEndPoint.h"
#include "modules/qmi/ModemEndPointFactory.h"
#include "modules/voice/NasApi.h"
#include "modules/voice/VoiceModule.h"
#include "modules/uim/UimSetFacilityLockRequestMsg.h"
#include "modules/uim/UimGetFacilityLockRequestMsg.h"
#include "modules/voice/SetFacilityLockCallback.h"
#include "modules/voice/GetFacilityLockCallback.h"
#include "modules/android/ril_message_factory.h"
#include "framework/add_message_id.h"
#include "framework/PolicyManager.h"

// #define USING_NAS_PUBLIC_API
#ifdef USING_NAS_PUBLIC_API
#include "modules/nas/NasModuleGetSyncInterfaceMessage.h"
#include "modules/nas/CsfbCallInProgressMessage.h"
#include "modules/nas/InitiateVoiceRteChangePropagationMessage.h"
#endif
#include <inttypes.h>

/*===========================================================================

                    INTERNAL DEFINITIONS AND TYPES

===========================================================================*/
#define TAG                            "qcril_qmi_voice"
#define VOICE_NIL                     (0)
#define QCRIL_QMI_VOICE_CALLED_PARTY_BCD_NO_LENGTH       41
#define QCRIL_QMI_SUPS_SERVICE_PASSWORD_LENGTH 4

#define QCRIL_QMI_VOICE_SS_TA_UNKNOWN       129 /* 0x80|CM_TON_UNKNOWN      |CM_NPI_ISDN */
#define QCRIL_QMI_VOICE_SS_TA_INTERNATIONAL 145 /* 0x80|CM_TON_INTERNATIONAL|CM_NPI_ISDN */
#define QCRIL_QMI_VOICE_SS_TA_INTER_PREFIX  '+' /* ETSI international call dial prefix */

#define  QCRIL_QMI_VOICE_UPCASE( c ) ( ((c) >= 'a' && (c) <= 'z') ? ((c) - 0x20) : (c) )
#define QCRIL_QMI_VOICE_MAX_USS_CHAR        182

#define QCRIL_QMI_VOICE_CLASS_NONE              0X00
#define QCRIL_QMI_VOICE_CLASS_VOICE             0X01
#define QCRIL_QMI_VOICE_CLASS_DATA              0X02
#define QCRIL_QMI_VOICE_CLASS_FAX               0X04
#define QCRIL_QMI_VOICE_CLASS_SMS               0X08
#define QCRIL_QMI_VOICE_CLASS_DATACIRCUITSYNC   0X10
#define QCRIL_QMI_VOICE_CLASS_DATACIRCUITASYNC  0X20
#define QCRIL_QMI_VOICE_CLASS_PACKETACCESS      0X40
#define QCRIL_QMI_VOICE_CLASS_PADACCESS         0X80

#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL        ( QCRIL_QMI_VOICE_CLASS_VOICE | QCRIL_QMI_VOICE_CLASS_FAX | QCRIL_QMI_VOICE_CLASS_SMS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_TELEPHONY  ( QCRIL_QMI_VOICE_CLASS_VOICE  )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_DATA   ( QCRIL_QMI_VOICE_CLASS_FAX | QCRIL_QMI_VOICE_CLASS_SMS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_FAX        ( QCRIL_QMI_VOICE_CLASS_FAX )
#define QCRIL_QMI_VOICE_TELESEFRVICE_SMS        ( QCRIL_QMI_VOICE_CLASS_SMS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_EXCEPT_SMS  ( QCRIL_QMI_VOICE_CLASS_VOICE | QCRIL_QMI_VOICE_CLASS_SMS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_BEARER_SVC  ( QCRIL_QMI_VOICE_CLASS_DATACIRCUITSYNC | QCRIL_QMI_VOICE_CLASS_DATACIRCUITASYNC )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_ASYNC_SVC   ( QCRIL_QMI_VOICE_CLASS_DATACIRCUITASYNC | QCRIL_QMI_VOICE_CLASS_PADACCESS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_SYNC_SVC    ( QCRIL_QMI_VOICE_CLASS_DATACIRCUITSYNC | QCRIL_QMI_VOICE_CLASS_PACKETACCESS )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_DATA_CIRCUIT_SYNC_SVC    ( QCRIL_QMI_VOICE_CLASS_DATACIRCUITSYNC )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_DATA_CIRCUIT_ASYNC_SVC    ( QCRIL_QMI_VOICE_CLASS_DATACIRCUITASYNC )
#define QCRIL_QMI_VOICE_TELESEFRVICE_TELEPHONY_AND_ALL_SYNC_SVC    ( QCRIL_QMI_VOICE_CLASS_VOICE | QCRIL_QMI_VOICE_CLASS_DATACIRCUITSYNC )
#define QCRIL_QMI_VOICE_TELESEFRVICE_ALL_GPRS_BEARER_SVC    ( QCRIL_QMI_VOICE_CLASS_PADACCESS )

#define QCRIL_QMI_VOICE_SERVICE_STATUS_INACTIVE    0x00
#define QCRIL_QMI_VOICE_SERVICE_STATUS_ACTIVE      0x01

#define QCRIL_QMI_VOICE_RIL_CF_STATUS_NOT_ACTIVE    0
#define QCRIL_QMI_VOICE_RIL_CF_STATUS_ACTIVE        1

#define QCRIL_QMI_VOICE_RIL_CF_STATUS_DISABLE       0
#define QCRIL_QMI_VOICE_RIL_CF_STATUS_ENABLE        1
#define QCRIL_QMI_VOICE_RIL_CF_STATUS_INTERROGATE   2
#define QCRIL_QMI_VOICE_RIL_CF_STATUS_REGISTRATION  3
#define QCRIL_QMI_VOICE_RIL_CF_STATUS_ERASURE       4

#define QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER_PREFIX  '+'
#define QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER         145
#define QCRIL_QMI_VOICE_DOMESTIC_NUMBER              129

/* OEM HOOK DTMF forward burst payload length (72 bytes)
on_length   : 4 bytes
off_length  : 4 bytes
dtmf_digits: 64 bytes */
#define QCRIL_QMI_VOICE_DTMF_FWD_BURST_PAYLOAD_LENGTH 72
#define QCRIL_QMI_VOICE_EXT_BRST_INTL_PAYLOAD_LENGTH 5

#define QCRIL_QMI_MAX_PENDING_MNG_CALL_REQUESTS 3

#define QCRIL_QMI_VOICE_CFW_RESPONSE_BUF_SZ   7

#define PEND_EMER_LOCK()        pthread_mutex_lock(&qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex)
#define PEND_EMER_UNLOCK()      pthread_mutex_unlock(&qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex)

/* First Call Barring Facility Type ims_SuppSvcFacilityType */
#define ims_SuppSvcFacilityType_CB_MIN ims_SuppSvcFacilityType_FACILITY_BAOC

/* Last Call Barring Facility Type ims_SuppSvcFacilityType */
#define ims_SuppSvcFacilityType_CB_MAX ims_SuppSvcFacilityType_FACILITY_BA_MT

/* Min Facility Type ims_SuppSvcFacilityType */
#define ims_SuppSvcFacilityType_MIN ims_SuppSvcFacilityType_FACILITY_CLIP

/* Max Facility Type ims_SuppSvcFacilityType */
#define ims_SuppSvcFacilityType_MAX ims_SuppSvcFacilityType_FACILITY_BAICa

/* Max Operation Type ims_SuppSvcOperationType */
#define ims_SuppSvcOperationType_MAX ims_SuppSvcOperationType_QUERY

#define QMI_RIL_SYS_PROP_DIAG_LOGGING           "vendor.radio.voice_diag_logging"
#define QMI_RIL_SYS_PROP_DIAG_LOGGING_LENGTH    (4)
#define QCRIL_DIAG_PATH                         "/vendor/bin/diag_mdlog"
#define QCRIL_DIAG_CMD_LENGTH                   (512)
#define QCRIL_DIAG_APQ_MASK_NAME                "/vendor/etc/diag/voice-call-min-log.cfg"
#define QCRIL_DIAG_MDM_MASK_NAME                "/vendor/etc/diag/mdm/voice-call-min-log.cfg"
#define QCRIL_DIAG_LOG_LOCATION DATA_PARTITION_ROOT "diag_logs"
#define QMI_RIL_WPS_PROP                        "persist.vendor.radio.is_wps_enabled"
#define QMI_RIL_WPS_PROP_LENGTH                 (4)

#define AUDIO_PD_SERVICE_NAME                   "avs/audio"
#define AUDIO_PD_DOMAIN_NAME                    "msm/adsp/audio_pd"

#define QCRIL_NUM_1X_WAIT_WAKE_LOCK_NAME        "qcril_num_1x_wait"
#define QCRIL_NUM_1X_WAIT_WAKE_LOCK_PROP        "ril.num_1x_wait.wakelock"

// local struct definition
typedef struct
{
    bool                        voice_state_valid;
    bool                        voice_radio_tech_valid;
    bool                        status_overview_valid;
    bool                        voice_rte_valid;
    bool                        data_rte_valid;
    bool                        ims_rte_valid;
    int                         voice_state;
    RIL_RadioTechnology         voice_radio_tech;
    uint32_t                    status_overview;
    qmi_ril_nw_reg_rte_type     voice_rte;
    qmi_ril_nw_reg_rte_type     data_rte;
    qmi_ril_nw_reg_rte_type     ims_rte;
} qcril_qmi_voice_nas_reported_info_type;

/*===========================================================================

                    QMI VOICE GLOBALS

===========================================================================*/

static qcril_qmi_voice_info_type  qcril_qmi_voice_info;

static qcril_qmi_pending_emergency_call_info_type qcril_qmi_pending_emergency_call_info;

static qcril_qmi_voice_nas_reported_info_type qcril_qmi_voice_nas_reported_info;

static qcril_qmi_voice_voip_overview_type qmi_voice_voip_overview;

// STK CC info
qcril_qmi_voice_stk_cc_info_type              stk_cc_info;

call_type_enum_v02 qcril_qmi_voice_cdma_call_type_to_be_considered;

static int feature_report_speech_codec = 0;

static int feature_subaddress_support = 0;

static int feature_subaddress_support_amp = 1;

static int reject_cause_21_supported = FALSE;

static int feature_subaddress_ia5_id_support = 0;

static int feature_redir_party_num_support = 0;

static int feature_fac_not_supp_as_no_nw = 0;

static int feature_encrypted_calls_support = 1;

static int dtmf_rtp_event_interval = QCRIL_QMI_VOICE_DTMF_INTERVAL_VAL;

static int diag_odl_logging_in_progress = FALSE;
static pthread_mutex_t       diag_odl_logging_in_progress_mutex;
static pthread_mutexattr_t   diag_odl_logging_in_progress_mutex_attr;

static boolean disabled_screen_off_ind = FALSE;

boolean has_wps_pending_dial = FALSE;

voice_dial_call_req_msg_v02 wps_dial_request;

uint32 wps_user_data;

static boolean hangup_retry_attempted = FALSE;

static void qcril_qmi_voice_request_set_supp_svc
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
);

static void qcril_qmi_voice_request_query_colp
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
);

void qcril_qmi_voice_copy_colr_data
(
  const voice_get_colr_resp_msg_v02 *const get_colr_resp,
  ims_Colr *colr,
  RIL_Errno ril_result,
  ims_Error *ims_error
);

void qcril_qmi_voice_copy_colp_data
(
  const voice_get_colp_resp_msg_v02 *const get_colp_resp,
  ims_SuppSvcResponse *suppSvc,
  RIL_Errno ril_result,
  ims_Error *ims_error
);

static void  qcril_qmi_voice_update_audio_state_vcl(void);
static void qcril_qmi_voice_send_ims_unsol_resp_handover(RIL_SrvccState ril_srvccstate);
static uint8_t qcril_qmi_voice_cancel_pending_emergency_call(void);

/*  Function handler table for QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS
    Handler functions for operations ims_SuppSvcOperationType_ACTIVATE
    and ims_SuppSvcOperationType_DEACTIVATE for each SuppSvcFacilityType.
*/
static qcril_req_handler_type * supp_srv_status_set_handler_table\
[ims_SuppSvcFacilityType_MAX + 1] =
{
  NULL,                             /* Invalid facility type value = 0 */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_CLIP = 1   */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_COLP = 2   */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BAOC = 3   */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BAOIC = 4  */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BAOICxH = 5 */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BAIC = 6   */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BAICr = 7  */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BA_ALL = 8 */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BA_MO = 9  */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BA_MT = 10 */
  qcril_qmi_voice_request_set_supp_svc,       /* FACILITY_BS_MT = 11 */
  qcril_qmi_voice_request_set_supp_svc        /* FACILITY_BAICa = 12 */
};

/*  Function handler table for QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS
    Handler function for ims_SuppSvcOperationType_QUERY for each
    SuppSvcFacilityType.
*/
static qcril_req_handler_type * supp_srv_status_query_handler_table\
[ims_SuppSvcFacilityType_MAX + 1] =
{
  NULL,                             /* Invalid facility type value = 0 */
  NULL,                   /* Query not supported for FACILITY_CLIP = 1 */
                          /* use REQUEST_QUERY_CALL_CLIP               */
  qcril_qmi_voice_request_query_colp,           /* FACILITY_COLP = 2   */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BAOC = 3   */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BAOIC = 4  */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BAOICxH = 5 */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BAIC = 6   */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BAICr = 7  */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BA_ALL = 8 */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BA_MO = 9  */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BA_MT = 10 */
  qcril_qmi_voice_request_query_facility_lock,  /* FACILITY_BS_MT = 11 */
  qcril_qmi_voice_request_query_facility_lock   /* FACILITY_BAICa = 12 */
};

/* Lookup table to convert IMS facility of type ims_SuppSvcFacilityType
    to QCRIL facility of type qcril_qmi_voice_facility_e_type.
*/
static qcril_qmi_voice_facility_e_type
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_MAX + 1];

/*===========================================================================

                                FUNCTIONS

===========================================================================*/

void qcril_qmi_voice_handle_audio_pd_state_changed
(
   qcril_qmi_pd_entry *entry,
   qcril_qmi_pd_state state,
   void *userdata
);
int qcril_stop_diag_log(void);

static void qcril_qmi_voice_send_management_call_request
(
  qcril_instance_id_e_type instance_id,
  struct qcril_reqlist_buf_tag *req,
  void *data,
  size_t datalen
);

static RIL_Errno qcril_qmi_voice_post_manage_voip_calls_request( voip_sups_type_enum_v02 request, uint16 req_id  );

static void qcril_qmi_voice_invalid_last_call_failure_cause();
static void qcril_qmi_voice_respond_ril_last_call_failure_request();
static void qcril_qmi_voice_handle_new_last_call_failure_cause(int reason, boolean is_qmi_reason, uint8_t raw_code_valid,
                                                               uint8_t raw_code, uint8_t sip_code_valid, uint8_t sip_code,
                                                               uint8_t end_reason_text_valid, char *end_reason_text,
                                                               qcril_qmi_voice_voip_call_info_entry_type *call_obj);
static int qcril_qmi_voice_nas_control_is_call_mode_reported_voice_radio_tech_different(call_mode_enum_v02 call_mode);
#ifndef USING_NAS_PUBLIC_API
static RIL_RadioTechnology qcril_qmi_voice_nas_control_get_reported_voice_radio_tech();
#endif
static unsigned int qcril_qmi_voice_convert_call_mode_to_radio_tech_family(call_mode_enum_v02 call_mode);
static void qcril_qmi_voice_make_incoming_call_ring (qcril_timed_callback_handler_params_type *param);
static void qcril_qmi_voice_auto_answer_timeout_handler( void *param );
static void qmi_ril_voice_drop_homeless_incall_reqs( void );
static void qmi_ril_voice_drop_homeless_incall_reqs_main_threaded(void * param);
static void qmi_ril_voice_cleanup_reqs_after_call_completion(void);
static void qmi_ril_voice_cleanup_reqs_after_call_completion_main_threaded(void * param);
uint32_t qcril_qmi_voice_call_num_copy_with_toa_check(char *src, uint32_t src_size, char* dest,
                                                      uint32_t dest_buffer_size, voice_num_type_enum_v02 num_type);

static void qcril_qmi_voice_create_emer_voice_entry(qcril_qmi_voice_emer_voice_feature_info_type * emer_voice_number, voice_remote_party_number2_type_v02 * remote_party_number);
static int qcril_qmi_voice_is_emer_voice_entry_valid(qcril_qmi_voice_emer_voice_feature_info_type * emer_voice_number);
static int qcril_qmi_voice_handle_ril_call_entry(RIL_Call *info_ptr);
static int qcril_qmi_voice_is_cdma_voice_emergency_calls_present(qcril_qmi_voice_voip_call_info_entry_type **cdma_voice_call_info_entry,
                                                                 qcril_qmi_voice_voip_call_info_entry_type **cdma_no_srv_emer_call_info_entry);
static boolean qcril_qmi_voice_pend_emergency_call(const qcril_request_params_type* params_ptr);

static void qcril_qmi_voice_respond_pending_hangup_ril_response(uint8_t call_id);
static void qmi_ril_voice_pending_1x_num_timeout(void * param);
static void qcril_qmi_voice_cancel_num_1x_wait_timer();
static void qcril_qmi_voice_setup_num_1x_wait_timer();

static void qcril_qmi_voice_set_last_call_fail_request_timeout();
static void qcril_qmi_voice_last_call_fail_request_timeout_handler(void *param);
static void qcril_qmi_voice_consider_shadow_remote_number_cpy_creation( qcril_qmi_voice_voip_call_info_entry_type* entry );

static void qmi_ril_succeed_on_pending_hangup_req_on_no_calls_left(void);

static void qcril_qmi_voice_transfer_sim_ucs2_alpha_to_std_ucs2_alpha(const voice_alpha_ident_type_v02 *sim_alpha, voice_alpha_ident_type_v02 *std_alpha);

static void qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl( void );

static void qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl( void );

static void qmi_ril_voice_ended_call_obj_phase_out(void * param);

static boolean qcril_qmi_voice_call_to_ims(const qcril_qmi_voice_voip_call_info_entry_type * call_info_entry);

static void qmi_ril_voice_ims_command_oversight_timeout_handler(void * param);

static boolean qmi_ril_voice_is_calls_supressed_by_pil_vcl();
static boolean qmi_ril_voice_is_audio_inactive_vcl();
static void qcril_qmi_voice_handle_pil_state_changed(const qcril_qmi_pil_state* cur_state);
static void qcril_qmi_voice_hangup_all_non_emergency_calls_vcl();
static void qcril_qmi_voice_hangup_all_calls_vcl(boolean (*exception_filter)(const qcril_qmi_voice_voip_call_info_entry_type*), boolean qmi_async);
static void qcril_qmi_voice_process_in_main_thread_handler (qcril_timed_callback_handler_params_type *param);

static boolean qcril_qmi_voice_get_atel_call_type_info_by_call_info
(
   const qcril_qmi_voice_voip_call_info_entry_type *call_info,
   RIL_Call_Details *call_details
);

void qcril_qmi_voice_modified_ind_hdlr
(
  void   *data_ptr,
  uint32 data_len
);

static boolean qcril_qmi_voice_get_atel_call_type_info
(
   call_type_enum_v02 call_type,
   boolean video_attrib_valid,
   voice_call_attribute_type_mask_v02 video_attrib,
   boolean audio_attrib_valid,
   voice_call_attribute_type_mask_v02 audio_attrib,
   boolean attrib_status_valid,
   voice_call_attrib_status_enum_v02 attrib_status,
   boolean call_info_elab_valid,
   qcril_qmi_voice_voip_call_info_elaboration_type call_info_elab,
   boolean cached_call_type_valid,
   ims_CallType cached_call_type,
   RIL_Call_Details *call_details
);

static boolean qcril_qmi_voice_get_modem_call_type_info
(
   ims_CallType                          ril_callType,
   ims_CallDomain                        ril_callDomain,
   boolean                                is_emergency_ip,
   call_type_enum_v02                    *call_type,
   uint8_t                               *audio_attrib_valid,
   voice_call_attribute_type_mask_v02    *audio_attrib,
   uint8_t                               *video_attrib_valid,
   voice_call_attribute_type_mask_v02    *video_attrib
);

void qcril_qmi_voice_reset_info_xml(qcril_qmi_voice_info_ind_xml_type_e_type xml_type);
static RIL_Errno qcril_qmi_voice_send_request_answer(
  const qcril_request_params_type             *const params_ptr,
  int                                         reject_this_call
);

void qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp
(
   qmi_sups_errors_enum_v02 sups_failure_cause,
   uint8_t call_id
);

static boolean qcril_qmi_voice_is_ims_send_calls(qcril_evt_e_type event_id);
static void qcril_qmi_voice_send_ims_unsol_call_state_changed();

void qcril_qmi_voice_set_audio_call_type
(
    const voice_call_info2_type_v02* iter_call_info,
    qcril_qmi_voice_voip_call_info_entry_type *call_info_entry
);

void qcril_qmi_voice_send_hangup_on_call
(
    int conn_index
);

void qcril_qmi_voice_get_colp_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
);

static int qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust( qcril_qmi_voice_voip_call_info_elaboration_type elaboration_single_input,
                                                                          qcril_qmi_voice_voip_call_info_elaboration_type * elaboration_single_adjusted );


static void qcril_initialize_ims_to_ril_facility_lookup_table( void )
{
  /* Unused IMS Facility Type value = 0 */
  qcril_ims_to_ril_facility_lookup_table[0] =
    QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED;

  /* ims_SuppSvcFacilityType_FACILITY_CLIP = 1 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_CLIP] =
    QCRIL_QMI_VOICE_FACILITY_CLIP;

  /* ims_SuppSvcFacilityType_FACILITY_COLP = 2 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_COLP] =
    QCRIL_QMI_VOICE_FACILITY_COLP;

  /* ims_SuppSvcFacilityType_FACILITY_BAOC = 3 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAOC] =
    QCRIL_QMI_VOICE_CB_FACILITY_ALLOUTGOING;

  /*  ims_SuppSvcFacilityType_FACILITY_BAOIC = 4 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAOIC] =
    QCRIL_QMI_VOICE_CB_FACILITY_OUTGOINGINT;

  /* ims_SuppSvcFacilityType_FACILITY_BAOICxH = 5 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAOICxH]
    = QCRIL_QMI_VOICE_CB_FACILITY_OUTGOINGINTEXTOHOME;

  /* ims_SuppSvcFacilityType_FACILITY_BAIC = 6 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAIC] =
    QCRIL_QMI_VOICE_CB_FACILITY_ALLINCOMING;

  /* ims_SuppSvcFacilityType_FACILITY_BAICr = 7 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAICr] =
    QCRIL_QMI_VOICE_CB_FACILITY_INCOMINGROAMING;

  /* ims_SuppSvcFacilityType_FACILITY_BA_ALL = 8 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BA_ALL] =
    QCRIL_QMI_VOICE_CB_FACILITY_ALLBARRING;

  /* ims_SuppSvcFacilityType_FACILITY_BA_MO = 9 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BA_MO] =
    QCRIL_QMI_VOICE_CB_FACILITY_ALLOUTGOINGBARRING;

  /* ims_SuppSvcFacilityType_FACILITY_BA_MT = 10 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BA_MT] =
    QCRIL_QMI_VOICE_CB_FACILITY_ALLINCOMINGBARRING;

  /* ims_SuppSvcFacilityType_FACILITY_BS_MT = 11 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BS_MT] =
    (qcril_qmi_voice_facility_e_type) VOICE_REASON_BARR_INCOMING_NUMBER_V02;

  /* ims_SuppSvcFacilityType_FACILITY_BAICa = 12 */
  qcril_ims_to_ril_facility_lookup_table[ims_SuppSvcFacilityType_FACILITY_BAICa] =
    (qcril_qmi_voice_facility_e_type) VOICE_REASON_BARR_INCOMING_ANONYMOUS_V02;

};

static void qcril_qmi_voice_setup_answer_resp_hdlr
(
   const qcril_request_params_type *const params_ptr
);

static qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state(call_state_enum_v02 qmi_call_state);
static RIL_Errno qcril_qmi_voice_perform_null_check_and_reqlist_entry
(
   const qcril_request_params_type *const params_ptr,
   uint32_t *user_data_ptr,
   qcril_reqlist_public_type *reqlist_entry_ptr
);
static RIL_Errno qcril_qmi_voice_gather_current_call_information
(
   unsigned int iter,
   const qcril_request_params_type *const params_ptr,
   qcril_qmi_voice_current_calls_type *payload_ptr,
   const qcril_qmi_voice_voip_call_info_entry_type *const call_info_entry
);

static void qcril_qmi_voice_update_set_local_call_hold_response_state
(
  qcril_reqlist_public_type *req_info,
  uint32 completed_state,
  qmi_result_type_v01 qmi_result,
  qmi_error_type_v01 qmi_error
);

extern "C" int32_t qcril_log_get_token_id( RIL_Token t );

#ifdef USING_NAS_PUBLIC_API
//===========================================================================
// qcril_qmi_voice_get_nas_interface
//===========================================================================
std::shared_ptr<NasModuleInterface>
qcril_qmi_voice_get_nas_interface(void)
{
  static std::shared_ptr<NasModuleInterface> nas_interface = nullptr;
  if (nas_interface == nullptr) {
    auto shared_msg = std::make_shared<NasModuleGetSyncInterfaceMessage>();
    std::shared_ptr<NasModuleInterface> shared_resp;
    Message::Callback::Status status = shared_msg->dispatchSync(shared_resp);
    if (status == Message::Callback::Status::SUCCESS
                        && shared_resp != nullptr) {
      nas_interface = shared_resp;
    }
  }
  return nas_interface;
}
#endif
//===========================================================================
// qcril_qmi_voice_init_pending_emergency_structure
//===========================================================================
boolean qcril_qmi_voice_init_pending_emergency_structure()
{
  // allocate RIL_Dial holder
  qcril_qmi_pending_emergency_call_info.dial_holder = (RIL_Dial*)malloc(sizeof(RIL_Dial));
  if( NULL == qcril_qmi_pending_emergency_call_info.dial_holder )
  {
    QCRIL_LOG_ERROR("malloc failed");
  }
  else
  {
    memset(qcril_qmi_pending_emergency_call_info.dial_holder, 0, sizeof(RIL_Dial));
    qcril_qmi_pending_emergency_call_info.dial_holder->address = (char*)malloc(QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
    if( NULL == qcril_qmi_pending_emergency_call_info.dial_holder->address )
    {
      QCRIL_LOG_ERROR("malloc failed");
      free(qcril_qmi_pending_emergency_call_info.dial_holder);
      qcril_qmi_pending_emergency_call_info.dial_holder = NULL;
    }
  }

  // allocate ims_Dial holder
  qcril_qmi_pending_emergency_call_info.ims_dial_holder = (ims_Dial*)malloc(sizeof(ims_Dial));
  if ( NULL == qcril_qmi_pending_emergency_call_info.ims_dial_holder )
  {
    QCRIL_LOG_ERROR("malloc failed");
  }
  else
  {
    memset(qcril_qmi_pending_emergency_call_info.ims_dial_holder, 0, sizeof(ims_Dial));
    qcril_qmi_pending_emergency_call_info.ims_dial_holder->address.arg =
            (char*)malloc(QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
    if (NULL == qcril_qmi_pending_emergency_call_info.ims_dial_holder->address.arg)
    {
      QCRIL_LOG_ERROR("malloc failed");
      free(qcril_qmi_pending_emergency_call_info.ims_dial_holder);
      qcril_qmi_pending_emergency_call_info.ims_dial_holder = NULL;
    }
  }

  // initialize the lock
  pthread_mutexattr_init( &qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex_atr);
  pthread_mutexattr_settype( &qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex_atr, PTHREAD_MUTEX_RECURSIVE );
  pthread_mutex_init( &qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex,
          &qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex_atr );

  // initialize the variable
  qcril_qmi_pending_emergency_call_info.is_emergency_call_pending = FALSE;

  return (qcril_qmi_pending_emergency_call_info.dial_holder ||
        qcril_qmi_pending_emergency_call_info.ims_dial_holder);
}

//===========================================================================
// qcril_qmi_voice_cleanup_pending_emergency_structure
//===========================================================================
void qcril_qmi_voice_cleanup_pending_emergency_structure()
{
  pthread_mutex_destroy(&qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex);
  pthread_mutexattr_destroy(&qcril_qmi_pending_emergency_call_info.pending_emergency_lock_mutex_atr);

  if (qcril_qmi_pending_emergency_call_info.dial_holder)
  {
    if (qcril_qmi_pending_emergency_call_info.dial_holder->address)
      free(qcril_qmi_pending_emergency_call_info.dial_holder->address);
    free(qcril_qmi_pending_emergency_call_info.dial_holder);
    qcril_qmi_pending_emergency_call_info.dial_holder = NULL;
  }

  if (qcril_qmi_pending_emergency_call_info.ims_dial_holder)
  {
    if (qcril_qmi_pending_emergency_call_info.ims_dial_holder->address.arg)
      free(qcril_qmi_pending_emergency_call_info.ims_dial_holder->address.arg);
    free(qcril_qmi_pending_emergency_call_info.ims_dial_holder);
    qcril_qmi_pending_emergency_call_info.ims_dial_holder = NULL;
  }
}

//===========================================================================
// qcril_qmi_voice_pre_init
//===========================================================================
RIL_Errno qcril_qmi_voice_pre_init(void)
{
  RIL_Errno res = RIL_E_GENERIC_FAILURE;
  char args[ PROPERTY_VALUE_MAX ];
  int len;
  char *end_ptr;
  unsigned long ret_val;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    memset( &qcril_qmi_voice_info, 0, sizeof(qcril_qmi_voice_info));

    property_get( QCRIL_PROCESS_SUPS_IND, args, "" );

    len = strlen( args );
    if ( len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ( ret_val == ULONG_MAX ) || ( ret_val == 0 ) ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert process_sups_ind setting %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved process_sups_ind setting %ld, use default", ret_val );
      }
      else
      {
        qcril_qmi_voice_info.process_sups_ind = ( boolean ) ret_val;
      }
    }

    QCRIL_LOG_INFO("qcril_qmi_voice_info.process_sups_ind set to: %d", qcril_qmi_voice_info.process_sups_ind);

    property_get( QCRIL_INFORCE_0X9E_TREAT_AS_TAG, args, "" );

    len = strlen( args );
    if ( len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ( ret_val == ULONG_MAX ) || ( ret_val == 0 ) ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert is_0x9e_not_treat_as_name setting %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved is_0x9e_not_treat_as_name setting %ld, use default", ret_val );
      }
      else
      {
        qcril_qmi_voice_info.is_0x9e_not_treat_as_name = ( boolean ) ret_val;
      }
    }
    QCRIL_LOG_INFO("qcril_qmi_voice_info.is_0x9e_not_treat_as_name set to: %d", qcril_qmi_voice_info.is_0x9e_not_treat_as_name);

    qcril_qmi_voice_info.is_original_number_display = FALSE;
    property_get( QCRIL_PROCESS_ORIGINAL_NUMBER_DISPLAY, args, "" );
    qcril_qmi_voice_info.is_original_number_display = ( (strcmp(args, "true") == 0) || (strcmp(args, "1") == 0) );
    QCRIL_LOG_INFO("qcril_qmi_voice_info.is_original_number_display set to: %d", qcril_qmi_voice_info.is_original_number_display);

    pthread_mutexattr_init( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex_atr );
    pthread_mutex_init( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex,
                        &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex_atr );

    // voip
    memset( &qmi_voice_voip_overview, 0, sizeof( qmi_voice_voip_overview ) );
    pthread_mutexattr_init( &qmi_voice_voip_overview.overview_lock_mtx_atr );
    pthread_mutexattr_settype( &qmi_voice_voip_overview.overview_lock_mtx_atr, PTHREAD_MUTEX_RECURSIVE );
    pthread_mutex_init( &qmi_voice_voip_overview.overview_lock_mutex, &qmi_voice_voip_overview.overview_lock_mtx_atr );

    (void)qcril_qmi_voice_init_pending_emergency_structure();

    pthread_mutexattr_init( &qcril_qmi_voice_info.voice_info_lock_mutex_atr );
    pthread_mutex_init( &qcril_qmi_voice_info.voice_info_lock_mutex, &qcril_qmi_voice_info.voice_info_lock_mutex_atr );

    pthread_mutexattr_init(&diag_odl_logging_in_progress_mutex_attr);
    pthread_mutex_init(&diag_odl_logging_in_progress_mutex, &diag_odl_logging_in_progress_mutex_attr);

    res = RIL_E_SUCCESS;

  } while (FALSE);

  QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) res );

  return res;
} // qcril_qmi_voice_pre_init

//===========================================================================
// get_voice_modem_endpoint
//===========================================================================
std::shared_ptr<VoiceModemEndPoint> get_voice_modem_endpoint
(
  void
)
{
  return ModemEndPointFactory<VoiceModemEndPoint>::getInstance().buildEndPoint();
} // get_voice_modem_endpoint

//===========================================================================
// qmi_client_voice_send_async
//===========================================================================
qmi_client_error_type qmi_client_voice_send_async
(
 unsigned long                   msg_id,
 void                            *req_ptr,
 int                             req_struct_len,
 int                             resp_struct_len,
 qmiAsyncCbType                  resp_cb,
 void                            *resp_cb_data
)
{
  qmi_client_error_type rc = QMI_INTERNAL_ERR;

  QCRIL_LOG_FUNC_ENTRY();

  rc = get_voice_modem_endpoint()->sendRawAsync(msg_id,
      req_ptr,
      req_struct_len,
      resp_struct_len,
      resp_cb,
      resp_cb_data,
      getVoiceModule());

  QCRIL_LOG_FUNC_RETURN_WITH_RET(rc);
  return rc;
}

//===========================================================================
// qcril_qmi_voice_ind_registrations
//===========================================================================
void qcril_qmi_voice_ind_registrations
(
  void
)
{
  voice_indication_register_req_msg_v02  indication_req;
  voice_indication_register_resp_msg_v02 indication_resp_msg;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));

  indication_req.reg_voice_privacy_events_valid = TRUE;
  indication_req.reg_voice_privacy_events = 0x01;

  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("Voice_privacy events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("Voice_privacy events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));

  indication_req.ext_brst_intl_events_valid = TRUE;
  indication_req.ext_brst_intl_events = 0x01;

  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("Extended_burst events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("Extended_burst events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));

  indication_req.speech_events_valid = TRUE;
  indication_req.speech_events = 0x01;

  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("Speech events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("Speech events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.handover_events_valid = TRUE;
  indication_req.handover_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("Handover events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("Handover events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.conference_events_valid = TRUE;
  indication_req.conference_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("Conference events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("Conference events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.tty_info_events_valid = TRUE;
  indication_req.tty_info_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
    QCRIL_LOG_INFO("tty_info events indication register failed!");
  }
  else
  {
    QCRIL_LOG_INFO("tty_info events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.cc_result_events_valid = TRUE;
  indication_req.cc_result_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("cc_result events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("cc_result events registration error code: %d", indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.additional_call_info_events_valid = TRUE;
  indication_req.additional_call_info_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("additional_call_info events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("additional_call_info events registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.audio_rat_change_events_valid = TRUE;
  indication_req.audio_rat_change_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("audio_rat_change events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("audio_rat_change events registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.vice_dialog_event_valid = TRUE;
  indication_req.vice_dialog_event = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("vice_dialog events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("vice_dialog events registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.conf_participants_events_valid = TRUE;
  indication_req.conf_participants_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("conf_participants_events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("conf_participants_events registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.sups_events_valid = TRUE;
  indication_req.sups_events = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("sups_events indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("sups_events registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  memset(&indication_req, 0, sizeof(indication_req));
  memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));
  indication_req.auto_rejected_incoming_call_end_event_valid = TRUE;
  indication_req.auto_rejected_incoming_call_end_event = 0x01;
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                  &indication_req,
                                  sizeof(indication_req),
                                  &indication_resp_msg,
                                  sizeof(indication_resp_msg)
                                  ) != QMI_NO_ERR )
  {
     QCRIL_LOG_INFO("auto_rejected_incoming_call_end_event indication register failed!");
  }
  else
  {
     QCRIL_LOG_INFO("auto_rejected_incoming_call_end_event registration error code: %d",
                    indication_resp_msg.resp.error);
  }

  disabled_screen_off_ind = FALSE;

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_ind_registrations

//===========================================================================
// qcril_qmi_voice_is_active_ims_call
//===========================================================================
static boolean qcril_qmi_voice_is_active_ims_call
(
 const qcril_qmi_voice_voip_call_info_entry_type * call_info_entry
)
{
  boolean ret = FALSE;

  if (call_info_entry)
  {
    ret = (qcril_qmi_voice_call_to_ims(call_info_entry) &&
            (call_info_entry->voice_scv_info.call_state != CALL_STATE_END_V02));
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int)ret);
  return ret;
} // qcril_qmi_voice_is_active_ims_call

//===========================================================================
// qcril_qmi_voice_enable_voice_indications
//===========================================================================
void qcril_qmi_voice_enable_voice_indications
(
  boolean enable
)
{
  boolean need_to_register = FALSE;
  voice_indication_register_req_msg_v02  indication_req;
  voice_indication_register_resp_msg_v02 indication_resp_msg;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_INFO("disabled_screen_off_ind = %d\n", disabled_screen_off_ind);

  if (enable == FALSE)
  {
    // De-register for the indications if PS calls are not present
    if (!disabled_screen_off_ind)
    {
      need_to_register = !qcril_qmi_voice_has_specific_call(qcril_qmi_voice_is_active_ims_call, NULL);
      disabled_screen_off_ind = need_to_register;
    }
  }
  else
  {
    // Register again only if previously de-registered the indications
    need_to_register = disabled_screen_off_ind;
    disabled_screen_off_ind = FALSE;
  }

  QCRIL_LOG_INFO("enable = %d, need_to_register = %d, disabled_screen_off_ind = %d\n",
                 enable, need_to_register, disabled_screen_off_ind);

  if (need_to_register)
  {
    memset(&indication_req, 0, sizeof(indication_req));
    memset(&indication_resp_msg, 0, sizeof(indication_resp_msg));

    indication_req.handover_events_valid = TRUE;
    indication_req.handover_events = enable;

    if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                    &indication_req,
                                    sizeof(indication_req),
                                    &indication_resp_msg,
                                    sizeof(indication_resp_msg)) != QMI_NO_ERR)
    {
      QCRIL_LOG_INFO("Indication register failed!");
    }
    else
    {
      QCRIL_LOG_INFO("Events registration error code: %d", indication_resp_msg.resp.error);
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_enable_voice_indications


void *qcril_qmi_audio_pd_init_thread(void *arg)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(arg);
    QCRIL_LOG_DEBUG("Initializing pd_handle");
    qcril_qmi_voice_info.pd_info.handle =
    qcril_qmi_pd_notifier_new(AUDIO_PD_SERVICE_NAME, "QCRIL_VOICE");

    if (qcril_qmi_voice_info.pd_info.handle &&
        qcril_pd_notifier_available(qcril_qmi_voice_info.pd_info.handle))
    {
      QCRIL_LOG_DEBUG("pd_notifier is available");
      qcril_pd_notifier_register_for(qcril_qmi_voice_info.pd_info.handle, AUDIO_PD_DOMAIN_NAME, qcril_qmi_voice_handle_audio_pd_state_changed, NULL);
      qcril_pd_notifier_start_listening(qcril_qmi_voice_info.pd_info.handle, AUDIO_PD_DOMAIN_NAME);
    }
    else
    {
      QCRIL_LOG_DEBUG("pd_notifier is unavailable");
      qcril_qmi_voice_info.pd_info.state = QCRIL_QMI_PD_UNUSED;
    }

    QCRIL_LOG_DEBUG("Locking overview");
    qcril_qmi_voice_voip_lock_overview();
    QCRIL_LOG_DEBUG("Updating audio state");
    qcril_qmi_voice_update_audio_state_vcl();
    qcril_qmi_voice_voip_unlock_overview();
    QCRIL_LOG_DEBUG("Unlocked overview");

    QCRIL_LOG_FUNC_RETURN();
    return NULL;
}
//===========================================================================
// qcril_qmi_audio_pd_init
//===========================================================================
RIL_Errno qcril_qmi_audio_pd_init
(
)
{
    int rc = -1;
    RIL_Errno ret = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();
    if(!qcril_qmi_voice_info.pd_info.pd_init_thread_valid)
    {
        qcril_qmi_voice_info.pd_info.state = QCRIL_QMI_PD_UNKNOWN;

        rc = pthread_create(&qcril_qmi_voice_info.pd_info.pd_init_thread,
                                NULL, qcril_qmi_audio_pd_init_thread, NULL);
        if(!rc)
        {
            qcril_qmi_voice_info.pd_info.pd_init_thread_valid =TRUE;
        }
        else
        {
            QCRIL_LOG_ERROR("Unable to create Audio pd thread");
            ret = RIL_E_GENERIC_FAILURE;
        }
    }
    else
    {
        QCRIL_LOG_INFO("Audio pd thread already created. Skipping.");
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_audio_pd_init

//===========================================================================
// qcril_qmi_voice_init
//===========================================================================
RIL_Errno qcril_qmi_voice_init
(
  void
)
{
  char property_name[ PROPERTY_NAME_MAX ];
  char args[ PROPERTY_VALUE_MAX ];
  int property_param_len;
  char *end_ptr;
  unsigned long ret_val = 0;
  RIL_Errno res = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  get_voice_modem_endpoint() = ModemEndPointFactory<VoiceModemEndPoint>::getInstance().buildEndPoint();
  if (get_voice_modem_endpoint() == nullptr) {
    return RIL_E_RADIO_NOT_AVAILABLE;
  }

  qcril_qmi_voice_ind_registrations();
  /* Default CLIR */
  qcril_qmi_voice_info.clir = ( uint8 ) QCRIL_QMI_VOICE_SS_CLIR_PRESENTATION_INDICATOR;

  /* Use saved CLIR setting if available */
  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s%d", QCRIL_QMI_VOICE_CLIR,qmi_ril_get_process_instance_id());
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ( ret_val == ULONG_MAX ) || ( ret_val == 0 ) ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert CLIR %s", args );
    }
    else if ( ret_val > QCRIL_QMI_VOICE_SS_CLIR_SUPPRESSION_OPTION )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Invalid saved CLIR %ld, use default", ret_val );
    }
    else
    {
      qcril_qmi_voice_info.clir = ( uint8 ) ret_val;
    }
  }
  QCRIL_LOG_DEBUG( "CLIR=%d", qcril_qmi_voice_info.clir );

  /* Default Auto Answer timerID */
  qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;

  /* Default Speech Codec */
  feature_report_speech_codec = FALSE;

  QCRIL_SNPRINTF(property_name, sizeof( property_name ), "%s", QCRIL_QMI_VOICE_REPORT_SPEECH_CODEC);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QCRIL_QMI_VOICE_REPORT_SPEECH_CODEC %s", args );
    }
    else
    {
      QCRIL_LOG_INFO("QCRIL_QMI_VOICE_REPORT_SPEECH_CODEC %d",ret_val);
      feature_report_speech_codec = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("REPORT_SPEECH_CODEC=%d", feature_report_speech_codec);

  qcril_qmi_voice_reset_stk_cc();

  imsRadioInit();
  qcril_qmi_voice_reset_info_xml(QCRIL_QMI_VOICE_CONFERENCE_INFO_IND_XML);
  qcril_qmi_voice_reset_info_xml(QCRIL_QMI_VOICE_DIALOG_INFO_IND_XML);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SYS_PROP_NAME_SUBADDRESS);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QMI_RIL_SYS_PROP_NAME_SUBADDRESS %s", args );
    }
    else
    {
      feature_subaddress_support = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("QMI_RIL_SYS_PROP_NAME_SUBADDRESS=%d", feature_subaddress_support);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SYS_PROP_NAME_SUBADDRESS_AMPERSAND);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QMI_RIL_SYS_PROP_NAME_SUBADDRESS_AMPERSAND %s", args );
    }
    else
    {
      feature_subaddress_support_amp = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("QMI_RIL_SYS_PROP_NAME_SUBADDRESS_AMPERSAND=%d", feature_subaddress_support_amp);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_REJECT_CAUSE_21_SUPPORTED);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Failed to convert QCRIL_REJECT_CAUSE_21_SUPPORTED %s", args );
    }
    else
    {
      reject_cause_21_supported = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("QCRIL_REJECT_CAUSE_21_SUPPORTED=%d", reject_cause_21_supported);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
      QMI_RIL_SYS_PROP_NAME_SUBADDRESS_IA5_IDENTIFIER);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QMI_RIL_SYS_PROP_NAME_SUBADDRESS_IA5_IDENTIFIER %s",
          args );
    }
    else
    {
      feature_subaddress_ia5_id_support = ret_val;
    }
  }

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
      QMI_RIL_SYS_PROP_NAME_REDIR_PARTY_NUM);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QMI_RIL_SYS_PROP_NAME_REDIR_PARTY_NUM %s",
          args );
    }
    else
    {
      feature_redir_party_num_support = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("QMI_RIL_SYS_PROP_NAME_REDIR_PARTY_NUM=%d", feature_redir_party_num_support);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
      QCRIL_QMI_VOICE_DTMF_INTERVAL);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QCRIL_QMI_VOICE_DTMF_INTERVAL %s",
          args );
    }
    else
    {
      dtmf_rtp_event_interval = ret_val;
    }
  }
  QCRIL_LOG_DEBUG("QCRIL_QMI_VOICE_DTMF_INTERVAL=%d", dtmf_rtp_event_interval);

  qcril_initialize_ims_to_ril_facility_lookup_table();
  QCRIL_LOG_DEBUG("Initialized IMS to RIL facility lookup table");

  QCRIL_LOG_FUNC_RETURN_WITH_RET( (int)res );

  qcril_qmi_voice_cdma_call_type_to_be_considered = CALL_TYPE_VOICE_V02;
  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
      QCRIL_QMI_CDMA_VOICE_EMER_VOICE);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QCRIL_QMI_CDMA_VOICE_EMER_VOICE %s",
          args );
    }
    else
    {
      QCRIL_LOG_DEBUG("QCRIL_QMI_CDMA_VOICE_EMER_VOICE=%d", ret_val);
      if (ret_val == 0)
      {
        qcril_qmi_voice_cdma_call_type_to_be_considered = CALL_TYPE_EMERGENCY_V02;
      }
    }
  }
  QCRIL_LOG_DEBUG("qcril_qmi_voice_cdma_call_type_to_be_considered=%d",
      qcril_qmi_voice_cdma_call_type_to_be_considered);

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
      QCRIL_QMI_VOICE_CLIR_FACNOTSUP_AS_NONW);
  property_get( property_name, args, "" );
  property_param_len = strlen( args );
  if ( property_param_len > 0 )
  {
    ret_val = strtoul( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QCRIL_QMI_VOICE_CLIR_FACNOTSUP_AS_NONW %s",
          args );
    }
    else
    {
      feature_fac_not_supp_as_no_nw = ret_val;
    }
  }

  QCRIL_LOG_DEBUG("QCRIL_QMI_VOICE_CLIR_FACNOTSUP_AS_NONW=%d", feature_fac_not_supp_as_no_nw);

  QCRIL_SNPRINTF(property_name, sizeof(property_name), "%s", QCRIL_QMI_SUPPORT_ENCRYPTED_CALLS);
  property_get(property_name, args, "");
  property_param_len = strlen(args);
  if (property_param_len > 0)
  {
    ret_val = strtoul(args, &end_ptr, 0);
    if ((errno == ERANGE) && (ret_val == ULONG_MAX))
    {
      QCRIL_LOG_ERROR("QCRIL QMI VOICE Fail to convert QCRIL_QMI_SUPPORT_ENCRYPTED_CALLS %s", args);
    }
    else
    {
      feature_encrypted_calls_support = ret_val;
    }
  }

  QCRIL_LOG_DEBUG("QCRIL_QMI_SUPPORT_ENCRYPTED_CALLS=%d", feature_encrypted_calls_support);

  hangup_retry_attempted = FALSE;

  // Check if num_1x_wait_timer_wakelock_is_acquired is already acquired
  // and release if required.
  qmi_ril_get_property_value_from_boolean(QCRIL_NUM_1X_WAIT_WAKE_LOCK_PROP,
          &qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired, FALSE);
  qcril_qmi_voice_cancel_num_1x_wait_timer();

  //Reset wps pending dial request
  has_wps_pending_dial = FALSE;
  memset(&wps_dial_request, 0, sizeof(wps_dial_request));

  qcril_qmi_voice_reset_ussd_power_opt_buffer();

  qcril_qmi_voice_info.send_vice_unsol_on_socket_connect = FALSE;

  // Initialize PIL Monitor and Audio PD notifier.
  qcril_qmi_voice_info.pil_state.state = QCRIL_QMI_PIL_STATE_UNKNOWN;
  qcril_qmi_pil_register_for_state_change(qcril_qmi_voice_handle_pil_state_changed);
  qcril_qmi_pil_init_monitor();
  qcril_qmi_voice_info.pil_state = *(qcril_qmi_pil_get_pil_state());

  QCRIL_LOG_DEBUG("Initializing audio pd");
  qcril_qmi_audio_pd_init();

  QCRIL_LOG_FUNC_RETURN_WITH_RET( (int)res );

  return res;

} // qcril_qmi_voice_init

//===========================================================================
// qcril_qmi_voice_post_cleanup
//===========================================================================
void qcril_qmi_voice_post_cleanup( void )
{
  // mutex deletion
  pthread_mutex_destroy( &qmi_voice_voip_overview.overview_lock_mutex );
  pthread_mutexattr_destroy( &qmi_voice_voip_overview.overview_lock_mtx_atr );
  pthread_mutex_destroy( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex );
  pthread_mutexattr_destroy( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex_atr);
  pthread_mutex_destroy( &qcril_qmi_voice_info.voice_info_lock_mutex );
  pthread_mutexattr_destroy( &qcril_qmi_voice_info.voice_info_lock_mutex_atr);
  pthread_mutex_destroy(&diag_odl_logging_in_progress_mutex);
  pthread_mutexattr_destroy(&diag_odl_logging_in_progress_mutex_attr);

  qcril_qmi_voice_cleanup_pending_emergency_structure();
} // qcril_qmi_voice_post_cleanup

//===========================================================================
// qcril_qmi_voice_cleanup
//===========================================================================
void qcril_qmi_voice_cleanup(void)
{
  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
  boolean unsol_resp = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  // clean call objects, will have to extend

  qcril_qmi_voice_voip_lock_overview();
  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info_entry )
  {
      if(qcril_qmi_voice_call_to_ims(call_info_entry))
      {
         unsol_resp = TRUE;
      }
      call_info_entry->voice_scv_info.call_state = CALL_STATE_END_V02;
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  qcril_qmi_voice_voip_unlock_overview();
  if(unsol_resp)
  {
      qcril_qmi_voice_send_ims_unsol_call_state_changed();
  }
  qcril_qmi_voice_voip_lock_overview();
  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info_entry )
  {
      qcril_qmi_voice_voip_destroy_call_info_entry( call_info_entry );
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  qcril_qmi_voice_voip_unlock_overview();

  QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
  if (!qcril_stop_diag_log())
  {
      QCRIL_LOG_INFO("qxdm logging disabled successfully");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_cleanup

//===========================================================================
// qcril_qmi_voice_call_to_atel
//===========================================================================
boolean qcril_qmi_voice_call_to_atel
(
 const qcril_qmi_voice_voip_call_info_entry_type* call_info_entry
)
{
  boolean ret = FALSE;

  if (call_info_entry)
  {
    ret = (QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN & call_info_entry->elaboration);
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int)ret);
  return ret;
} // qcril_qmi_voice_call_to_atel

//===========================================================================
// qcril_qmi_voice_call_to_ims
//===========================================================================
boolean qcril_qmi_voice_call_to_ims
(
 const qcril_qmi_voice_voip_call_info_entry_type* call_info_entry
)
{
  boolean ret = FALSE;

  if (call_info_entry)
  {
    ret = !qcril_qmi_voice_call_to_atel(call_info_entry);
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int)ret);
  return ret;
} // qcril_qmi_voice_call_to_ims

//===========================================================================
// qcril_qmi_voice_is_call_has_ims_audio
//===========================================================================
boolean qcril_qmi_voice_is_call_has_ims_audio
(
 const qcril_qmi_voice_voip_call_info_entry_type * call_info_entry
)
{
  boolean ret = FALSE;
  boolean is_cs = FALSE;

  if (call_info_entry)
  {
    is_cs = ((call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN) ||
        (call_info_entry->audio_call_type == QMI_RIL_VOICE_IMS_AUDIO_CALL_TYPE_VOICE)) ?
      TRUE : FALSE;
    QCRIL_LOG_INFO("is cs call: %d", is_cs);
    ret = !is_cs && !(call_info_entry->srvcc_in_progress);
  }
  return ret;
} // qcril_qmi_voice_is_call_has_ims_audio

//===========================================================================
// qcril_qmi_voice_is_call_has_voice_audio
//===========================================================================
boolean qcril_qmi_voice_is_call_has_voice_audio
(
 const qcril_qmi_voice_voip_call_info_entry_type * call_info_entry
)
{
  boolean ret = FALSE;
  if (call_info_entry)
  {
    ret = call_info_entry->srvcc_in_progress ||
      !qcril_qmi_voice_is_call_has_ims_audio(call_info_entry);
  }
  return ret;
} // qcril_qmi_voice_is_call_has_voice_audio

//===========================================================================
// qcril_qmi_voice_get_answer_am_event
//===========================================================================
qcril_am_event_type qcril_qmi_voice_get_answer_am_event
(
 const qcril_qmi_voice_voip_call_info_entry_type * call_info_entry
)
{
  qcril_am_event_type am_event = QCRIL_AM_EVENT_INVALID;
  if (call_info_entry)
  {
    if (qcril_qmi_voice_is_call_has_ims_audio(call_info_entry))
    {
      am_event = QCRIL_AM_EVENT_IMS_ANSWER;
    }
    else
    {
      am_event = QCRIL_AM_EVENT_VOICE_ANSWER;
    }
  }
  return am_event;
} // qcril_qmi_voice_get_answer_am_event

//===========================================================================
// qcril_qmi_voice_get_answer_call_mode
//===========================================================================
call_mode_enum_v02 qcril_qmi_voice_get_answer_call_mode()
{
  boolean ret = FALSE;
  call_mode_enum_v02 call_mode = CALL_MODE_UNKNOWN_V02;

  qcril_qmi_voice_voip_lock_overview();
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry =
    qcril_qmi_voice_voip_call_info_entries_enum_first();

  while (NULL != call_info_entry)
  {
    if(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL)
    {
      call_mode = call_info_entry->voice_scv_info.mode;
      break;
    }
    ret = TRUE;
    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  qcril_qmi_voice_voip_unlock_overview();

  return call_mode;
} // qcril_qmi_voice_get_answer_call_mode

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_lookup_command_name

===========================================================================*/
/*!
    @brief
    Lookup state name.

    @return
    A pointer to the state name.
*/
/*=========================================================================*/
static const char *qcril_qmi_voice_lookup_command_name
(
  unsigned long msg
)
{
  switch( msg )
  {
    case QMI_VOICE_DIAL_CALL_RESP_V02:
      return "DIAL CALL RESP";
    case QMI_VOICE_ANSWER_CALL_RESP_V02:
      return "ANSWER CALL RESP";
    case QMI_VOICE_END_CALL_RESP_V02:
      return "END CALL RESP";
    case QMI_VOICE_BURST_DTMF_RESP_V02:
      return "BURST DTMF RESP";
    case QMI_VOICE_START_CONT_DTMF_RESP_V02:
      return "START CONT DTMF RESP";
    case QMI_VOICE_STOP_CONT_DTMF_RESP_V02:
      return "STOP CONT DTMF RESP";
    case QMI_VOICE_SEND_FLASH_RESP_V02:
      return "SEND FLASH RESP";
    case QMI_VOICE_INDICATION_REGISTER_RESP_V02:
      return "INDICATION REGISTER RESP";
    case QMI_VOICE_MANAGE_CALLS_RESP_V02:
      return "MNG CALLS RESP";
    case QMI_VOICE_SET_SUPS_SERVICE_RSEP_V02:
      return "SET SUPS RESP";
    case QMI_VOICE_GET_CLIR_RESP_V02:
      return "GET CLIR RESP";
    case QMI_VOICE_GET_CLIP_RESP_V02:
      return "GET CLIP RESP";
    case QMI_VOICE_GET_COLP_RESP_V02:
      return "GET COLP RESP";
    case QMI_VOICE_SET_CALL_BARRING_PASSWORD_RESP_V02:
      return "SET CALL BARRING PASSWORD RESP";
    case QMI_VOICE_GET_CALL_WAITING_RESP_V02:
      return "GET CALL WAITING RESP";
    case QMI_VOICE_GET_CALL_BARRING_RESP_V02:
      return "GET CALL BARRING RESP";
    case QMI_VOICE_GET_CALL_FORWARDING_RESP_V02:
      return "GET CALL FORWARDING RESP";
    case QMI_VOICE_ORIG_USSD_RESP_V02:
      return "ORIG USSD RESP";
    case QMI_VOICE_ANSWER_USSD_RESP_V02:
      return "ANSWER USSD RESP";
    case QMI_VOICE_CANCEL_USSD_RESP_V02:
      return "CANCEL USSD RESP";
    case QMI_VOICE_MANAGE_IP_CALLS_RESP_V02:
      return "MNG IP CALLS RESP";
    case QMI_VOICE_SETUP_ANSWER_RESP_V02:
      return "SETUP ANSWER RESP";
    case QMI_VOICE_GET_COLR_RESP_V02:
      return "GET COLR RESP";
    case QMI_VOICE_IMS_CALL_CANCEL_RESP_V02:
      return "IMS CALL CANCEL RESP";
    default:
      return "Unknown";
  } /* end switch */
} /* qcril_qmi_voice_lookup_command_name */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_qmi_to_ril_num_pi

===========================================================================*/
/*!
    @brief
    Maps qmi num presentation enum to RIL pi values.

    @return
    None.
*/
/*=========================================================================*/
int qcril_qmi_voice_map_qmi_to_ril_num_pi
(
  pi_num_enum_v02  qmi_num_pi
)
{
  int ril_num_pi = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;

  switch(qmi_num_pi)
  {
    case PRESENTATION_NUM_ALLOWED_V02:
      ril_num_pi = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;
      break;
    case PRESENTATION_NUM_RESTRICTED_V02:
      ril_num_pi = QCRIL_QMI_VOICE_RIL_PI_RESTRICTED;
      break;
    case PRESENTATION_NUM_RESERVED_V02:               // fallthough
    case PRESENTATION_NUM_NUM_UNAVAILABLE_V02:
      ril_num_pi = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;
      break;
    case PRESENTATION_NUM_PAYPHONE_V02:
      ril_num_pi = QCRIL_QMI_VOICE_RIL_PI_PAYPHONE;
      break;
    default:
      QCRIL_LOG_INFO("Invalid num presentation %d",qmi_num_pi);
      break;
  }
  return ril_num_pi;
}/* qcril_qmi_voice_map_qmi_to_ril_num_pi */

boolean qcril_qmi_voice_map_qmi_to_ril_active_status
(
 active_status_enum_v02 qmi_active_status,
 int *ril_active_status
)
{
  boolean result = FALSE;

  if (ril_active_status)
  {
    result = TRUE;
    switch(qmi_active_status)
    {
      case ACTIVE_STATUS_INACTIVE_V02 :
        *ril_active_status = ims_ServiceClassStatus_DISABLED;
        break;
      case ACTIVE_STATUS_ACTIVE_V02 :
        *ril_active_status = ims_ServiceClassStatus_ENABLED;
        break;
      default :
        QCRIL_LOG_INFO("Invalid active status %d", qmi_active_status);
        result = FALSE;
        break;
    }
  }

  return result;
}

boolean qcril_qmi_voice_map_qmi_to_ril_provision_status
(
 provision_status_enum_v02 qmi_provision_status,
 int *ril_provision_status
)
{
  boolean result = FALSE;

  if (ril_provision_status)
  {
    result = TRUE;
    switch(qmi_provision_status)
    {
      case PROVISION_STATUS_NOT_PROVISIONED_V02 :
        *ril_provision_status = QCRIL_QMI_VOICE_CLIR_SRV_NOT_PROVISIONED;
        break;
      case PROVISION_STATUS_PRESENTATION_ALLOWED_V02 :
        *ril_provision_status = QCRIL_QMI_VOICE_CLIR_SRV_PRESENTATION_ALLOWED;
        break;
      case PROVISION_STATUS_PROVISIONED_PERMANENT_V02 :
        *ril_provision_status = QCRIL_QMI_VOICE_CLIR_SRV_PROVISIONED_PERMANENT;
        break;
      case PROVISION_STATUS_PRESENTATION_RESTRICTED_V02:
        *ril_provision_status = QCRIL_QMI_VOICE_CLIR_SRV_PRESENTATION_RESTRICTED;
        break;
      default :
        QCRIL_LOG_INFO("Invalid provision status %d", qmi_provision_status);
        result = FALSE;
        break;
    }
  }

  return result;
}

int  qcril_qmi_voice_get_facility_value
(
  const char * facility,
  char* facility_name )
{
  char temp[ 3 ];

  if( facility != NULL )
  {
  if ( strlen( facility ) != sizeof( char ) * 2 )
    return ( (int) QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED );

  memcpy( &temp[ 0 ], facility, sizeof( char ) * 2 );
  temp[ 2 ] = '\0';

  temp[ 0 ] = QCRIL_QMI_VOICE_UPCASE( temp[ 0 ] );
  temp[ 1 ] = QCRIL_QMI_VOICE_UPCASE( temp[ 1 ] );

  memcpy( facility_name, temp, 3 );

  if ( strcmp( temp, "SC" ) == FALSE )
   return ( (int) QCRIL_QMI_VOICE_FACILITY_LOCK_SC );

  if ( strcmp( temp, "AO" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_ALLOUTGOING );

  if ( strcmp( temp, "OI" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_OUTGOINGINT);

  if ( strcmp( temp, "OX" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_OUTGOINGINTEXTOHOME);

  if ( strcmp( temp, "AI") == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_ALLINCOMING);

  if ( strcmp( temp, "IR" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_INCOMINGROAMING);

  if ( strcmp( temp, "AB" ) == FALSE )
    return( (int) QCRIL_QMI_VOICE_CB_FACILITY_ALLBARRING);

  if ( strcmp( temp, "AG" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_ALLOUTGOINGBARRING);

  if ( strcmp( temp, "AC" ) == FALSE )
    return ( (int) QCRIL_QMI_VOICE_CB_FACILITY_ALLINCOMINGBARRING);

  if (strcmp( temp, "FD" ) == FALSE)
    return ( (int) QCRIL_QMI_VOICE_FACILITY_LOCK_FD );

  return ( (int) QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED );
  }
  else
  {
    return ( (int) QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED );
  }

} /* qcril_qmi_voice_get_facility_value */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_convert_ims_to_ril_facility_type

===========================================================================*/
/*!
    @brief
    Converts IMS facility of type ims_SuppSvcFacilityType to QCRIL
    facility of type qcril_qmi_voice_facility_e_type using lookup table
    qcril_ims_to_ril_facility_lookup_table.

    @return
    Success: qcril_qmi_voice_facility_e_type
    Error:   QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED
*/
/*=========================================================================*/
static qcril_qmi_voice_facility_e_type
  qcril_qmi_voice_convert_ims_to_ril_facility_type
(
  /* Facility type as definied in ims_SuppSvcRequest */
  ims_SuppSvcFacilityType ims_facility_type
)
{
  if (ims_facility_type >= ims_SuppSvcFacilityType_MIN &&
      ims_facility_type <= ims_SuppSvcFacilityType_MAX)
  {
    return qcril_ims_to_ril_facility_lookup_table[ims_facility_type];
  }
  else
  {
    return QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED;
  }
} /* qcril_qmi_voice_convert_ims_to_ril_facility_type */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_qmi_cfw_reason_to_ril_reason

===========================================================================*/
/*!
    @brief
    Maps qmi CFW Reason to QCRIL CFW Reason.

    @return
    None.
*/
/*=========================================================================*/

uint8 qcril_qmi_voice_map_qmi_cfw_reason_to_ril_reason(int qmi_cfw_reason)
{
  uint8 ril_reason=0;

  switch(qmi_cfw_reason)
  {
    case VOICE_REASON_FWD_UNCONDITIONAL_V02 :
     ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_UNCOND;
     break;

    case VOICE_REASON_FWD_MOBILEBUSY_V02:
      ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_BUSY ;
      break;

    case VOICE_REASON_FWD_NOREPLY_V02 :
      ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_NOREPLY;
      break;

    case VOICE_REASON_FWD_UNREACHABLE_V02:
      ril_reason = (uint8) QCRIL_QMI_VOICE_CCFC_REASON_NOTREACH ;
      break;

    case VOICE_REASON_FWD_ALLFORWARDING_V02:
      ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_ALLCALL ;
      break;

    case VOICE_REASON_FWD_ALLCONDITIONAL_V02:
      ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_ALLCOND ;
      break;

    default:
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("qmi_reason : %d",qmi_cfw_reason);
      ril_reason = (uint8)QCRIL_QMI_VOICE_CCFC_REASON_UNCOND;
      break;
  }

  return ril_reason;
}/*qcril_qmi_voice_map_qmi_cfw_reason_to_ril_reason*/

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_ril_reason_to_qmi_cfw_reason

===========================================================================*/
/*!
    @brief
    Maps QCRIL CFW Reson to qmi CFW Reason

    @return
    None.
*/
/*=========================================================================*/
voice_reason_enum_v02 qcril_qmi_voice_map_ril_reason_to_qmi_cfw_reason(int ril_reason)
{
  voice_reason_enum_v02 qmi_reason = VOICE_REASON_ENUM_MAX_ENUM_VAL_V02;

  switch(ril_reason)
  {
    case QCRIL_QMI_VOICE_CCFC_REASON_UNCOND:
      qmi_reason = VOICE_REASON_FWD_UNCONDITIONAL_V02;
      break;

    case QCRIL_QMI_VOICE_CCFC_REASON_BUSY:
      qmi_reason = VOICE_REASON_FWD_MOBILEBUSY_V02;
      break;

    case QCRIL_QMI_VOICE_CCFC_REASON_NOREPLY:
      qmi_reason = VOICE_REASON_FWD_NOREPLY_V02;
      break;

    case QCRIL_QMI_VOICE_CCFC_REASON_NOTREACH:
      qmi_reason = VOICE_REASON_FWD_UNREACHABLE_V02;
      break;

    case QCRIL_QMI_VOICE_CCFC_REASON_ALLCALL:
      qmi_reason = VOICE_REASON_FWD_ALLFORWARDING_V02;
      break;

    case QCRIL_QMI_VOICE_CCFC_REASON_ALLCOND:
      qmi_reason = VOICE_REASON_FWD_ALLCONDITIONAL_V02;
      break;

    default:
      qmi_reason = VOICE_REASON_ENUM_MAX_ENUM_VAL_V02;
      break;
  }

  QCRIL_LOG_DEBUG("Mapped ril_reason %d to qmi_reason %d", ril_reason, qmi_reason);

  return qmi_reason;
}/*qcril_qmi_voice_map_ril_reason_to_qmi_cfw_reason*/

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_qmi_to_ril_name_pi

===========================================================================*/
/*!
    @brief
    Maps qmi name presentation enum to RIL pi values.

    @return
    None.
*/
/*=========================================================================*/
int qcril_qmi_voice_map_qmi_to_ril_name_pi
(
  pi_name_enum_v02  qmi_name_pi
)
{
  int ril_name_pi = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;

  switch(qmi_name_pi)
  {
    case PRESENTATION_NAME_PRESENTATION_ALLOWED_V02:
      ril_name_pi = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;
      break;
    case PRESENTATION_NAME_PRESENTATION_RESTRICTED_V02:
      ril_name_pi = QCRIL_QMI_VOICE_RIL_PI_RESTRICTED;
      break;
    case PRESENTATION_NAME_UNAVAILABLE_V02:
      ril_name_pi = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;
      break;
    case PRESENTATION_NAME_NAME_PRESENTATION_RESTRICTED_V02:
      ril_name_pi = QCRIL_QMI_VOICE_RIL_PI_RESTRICTED;
      break;
    default:
      QCRIL_LOG_INFO("Invalid name presentation %d",qmi_name_pi);
      break;
  }
  return ril_name_pi;
}/* qcril_qmi_voice_map_qmi_to_ril_name_pi */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_qmi_to_ril_last_call_failure_cause

===========================================================================*/
/*!
    @brief
    Maps qmi last call failure cause enum to RIL last call failure cause values.

    @return
    RIL last call failure cause values.
*/
/*=========================================================================*/
RIL_LastCallFailCause qcril_qmi_voice_map_qmi_to_ril_last_call_failure_cause
(
  call_end_reason_enum_v02  reason,
  uint8_t                   raw_code_valid,
  uint8_t                   raw_code,
  uint8_t                   sip_code_valid,
  uint8_t                   sip_code,
  uint8_t                   end_reason_text_valid,
  char                     *end_reason_text,
  char                     *fail_cause_str, /*!< Output parameter */
  int                       fail_cause_str_len
)
{
  const char *cause_str = NULL;
  RIL_LastCallFailCause ret;
  switch ( reason )
  {
    case CALL_END_CAUSE_CLIENT_END_V02:
      if (!cause_str) cause_str = "Normal call clearing; Client ended the call";
    case CALL_END_CAUSE_REL_NORMAL_V02:
      if (!cause_str) cause_str = "Normal call clearing";
      ret = CALL_FAIL_NORMAL;
      break;

    case CALL_END_CAUSE_NETWORK_END_V02:
      cause_str = "Normal call clearing";
      ret = CALL_FAIL_NORMAL;
      break;

    case CALL_END_CAUSE_IMSI_UNKNOWN_IN_VLR_V02:
      cause_str = "IMSI unknown in VLR";
      ret = CALL_FAIL_IMSI_UNKNOWN_IN_VLR;
      break;

    case CALL_END_CAUSE_IMEI_NOT_ACCEPTED_V02:
      cause_str = "IMEI not accepted";
      ret = CALL_FAIL_IMEI_NOT_ACCEPTED;
      break;

    case CALL_END_CAUSE_INCOM_REJ_V02:
      if (!cause_str) cause_str = "User busy; client rejected incoming call";
    case CALL_END_CAUSE_SETUP_REJ_V02:
      if (!cause_str) cause_str = "User busy; client rejected setup indication";
      ret = CALL_FAIL_BUSY;
      break;

    case CALL_END_CAUSE_MAX_PS_CALLS_V02:
      if (!cause_str) cause_str = "Resources are not available to handle new MO/MT PS call";
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
      break;

    case CALL_END_CAUSE_NETWORK_CONGESTION_V02:
    case CALL_END_CAUSE_RESOURCES_NOT_AVAILABLE_V02:
    case CALL_END_CAUSE_NO_RESOURCES_V02:
      cause_str = "No circuit/channel available";
      ret = CALL_FAIL_CONGESTION;
      break;

    case CALL_END_CAUSE_NO_FUNDS_V02:
      cause_str = "ACM limit exceeded, no funds";
      ret = CALL_FAIL_ACM_LIMIT_EXCEEDED;
      break;

    case CALL_END_CAUSE_CDMA_LOCK_V02:
      cause_str = "CDMA locked";
      ret = CALL_FAIL_CDMA_LOCKED_UNTIL_POWER_CYCLE;
      break;

    case CALL_END_CAUSE_INTERCEPT_V02:
    case CALL_END_CAUSE_1XCSFB_FAIL_CALL_REL_INTERCEPT_ORDER_V02:
      cause_str = "CDMA intercept";
      ret = CALL_FAIL_CDMA_INTERCEPT;
      break;

    case CALL_END_CAUSE_REORDER_V02:
    case CALL_END_CAUSE_1XCSFB_FAIL_CALL_REL_REORDER_V02:
      cause_str = "CDMA reorder";
      ret = CALL_FAIL_CDMA_REORDER;
      break;

    case CALL_END_CAUSE_REL_SO_REJ_V02:
    case CALL_END_CAUSE_1XCSFB_FAIL_CALL_REL_SO_REJ_V02:
      cause_str = "CDMA so reject";
      ret = CALL_FAIL_CDMA_SO_REJECT;
      break;

    case CALL_END_CAUSE_RETRY_ORDER_V02:
      cause_str = "CDMA retry order";
      ret = CALL_FAIL_CDMA_RETRY_ORDER;
      break;

    case CALL_END_CAUSE_ACC_FAIL_V02:
    case CALL_END_CAUSE_IS707B_MAX_ACC_V02:
      if (!cause_str) cause_str = "CDMA access failure";
    case CALL_END_CAUSE_MAX_ACCESS_PROBE_V02:
      if (!cause_str) cause_str = "CDMA access failure; Maximum access probes transmitted";
      ret = CALL_FAIL_CDMA_ACCESS_FAILURE;
      break;

    case CALL_END_CAUSE_INCOM_CALL_V02:
      cause_str = "CDMA preemted";
      ret = CALL_FAIL_CDMA_PREEMPTED;
      break;

    case CALL_END_CAUSE_EMERGENCY_FLASHED_V02:
      cause_str = "CDMA not emergency";
      ret = CALL_FAIL_CDMA_NOT_EMERGENCY;
      break;

    case CALL_END_CAUSE_ACCESS_BLOCK_ALL_V02:
    case CALL_END_CAUSE_ACCESS_BLOCK_V02:
      if (!cause_str) cause_str = "CDMA access blocked";
    case CALL_END_CAUSE_PSIST_N_V02:
      if (!cause_str) cause_str = "CDMA access blocked; Persistence test failure";
      ret = CALL_FAIL_CDMA_ACCESS_BLOCKED;
      break;

    case CALL_END_CAUSE_UNASSIGNED_NUMBER_V02:
      cause_str = "Unassigned (unallocated) number";
      ret = CALL_FAIL_UNOBTAINABLE_NUMBER;
      break;

    case CALL_END_CAUSE_USER_BUSY_V02:
    case CALL_END_CAUSE_USSD_BUSY_V02:
    case CALL_END_CAUSE_REJECTED_BY_USER_V02:
      cause_str = "User busy";
      ret = CALL_FAIL_BUSY;
      break;

    case CALL_END_CAUSE_NORMAL_CALL_CLEARING_V02:
      if (!cause_str) cause_str = "Normal call clearing";
    case CALL_END_CAUSE_RINGING_RINGBACK_TIMEOUT_V02:
      if (!cause_str) cause_str = "Call terminated due to ringing/ringback timeout";
      ret = CALL_FAIL_NORMAL;
      break;

    case CALL_END_CAUSE_PROTOCOL_Q850_ERROR_V02:
      if (end_reason_text_valid)
      {
        cause_str = end_reason_text;
      }
      else
      {
        cause_str = "Sip Q850 error";
      }
      if (sip_code_valid)
      {
        ret = (RIL_LastCallFailCause)sip_code;
      }
      else
      {
        ret = CALL_FAIL_ERROR_UNSPECIFIED;
      }
      break;

    case CALL_END_CAUSE_PEER_NOT_REACHABLE_V02:
      cause_str = "Peer not reachable";
      ret= CALL_FAIL_SUBSCRIBER_ABSENT;
      break;

    case CALL_END_CAUSE_NO_ROUTE_TO_DESTINATION_V02:
      cause_str = "No route to destination";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_NO_ROUTE_TO_DESTINATION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_CHANNEL_UNACCEPTABLE_V02:
      cause_str = "Channel unacceptable";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_CHANNEL_UNACCEPTABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_OPERATOR_DETERMINED_BARRING_V02:
      cause_str = "Operator determined Barring";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_OPERATOR_DETERMINED_BARRING;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_NO_USER_RESPONDING_V02:
      cause_str = "No user responding";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_NO_USER_RESPONDING;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_USER_ALERTING_NO_ANSWER_V02:
      cause_str = "User alerting, no answer";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_NO_ANSWER_FROM_USER;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_CALL_REJECTED_V02:
      cause_str = "Call rejected";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_CALL_REJECTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_NUMBER_CHANGED_V02:
      cause_str = "Number changed";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_NUMBER_CHANGED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_PREEMPTION_V02:
      cause_str = "Pre-emption";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_PREEMPTION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_DESTINATION_OUT_OF_ORDER_V02:
      cause_str = "Destination out of order";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_DESTINATION_OUT_OF_ORDER;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INVALID_NUMBER_FORMAT_V02:
      cause_str = "Invalid number format (incomplete number)";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INVALID_NUMBER_FORMAT;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_FACILITY_REJECTED_V02:
      cause_str = "Facility rejected";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_FACILITY_REJECTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_RESP_TO_STATUS_ENQUIRY_V02:
      cause_str = "Response to STATUS ENQUIRY";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_RESP_TO_STATUS_ENQUIRY;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_NORMAL_UNSPECIFIED_V02:
      cause_str = "Normal, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      if (!raw_code_valid)
      {
        ret = CALL_FAIL_NORMAL_UNSPECIFIED;
      }
      else
      {
        ret = (RIL_LastCallFailCause)raw_code;
        // no macro defined for this particular value
        if (raw_code == 26)
        {
            cause_str = "Non-selected user clearing";
        }
      }
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_NO_CIRCUIT_OR_CHANNEL_AVAILABLE_V02:
      cause_str = "No circuit/channel available";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_CONGESTION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_NETWORK_OUT_OF_ORDER_V02:
    case CALL_END_CAUSE_SERVICE_TEMPORARILY_OUT_OF_ORDER_V02:
      cause_str = "Network out of order";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_NETWORK_OUT_OF_ORDER;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_TEMPORARY_FAILURE_V02:
      cause_str = "Temporary failure";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_TEMPORARY_FAILURE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_SWITCHING_EQUIPMENT_CONGESTION_V02:
      cause_str = "Switching equipment congestion";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_SWITCHING_EQUIPMENT_CONGESTION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_ACCESS_INFORMATION_DISCARDED_V02:
      cause_str = "Access information discarded";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_ACCESS_INFORMATION_DISCARDED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE_V02:
      cause_str = "Requested circuit/channel not available";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED_V02:
      cause_str = "Resource unavailable, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_QOS_UNAVAILABLE_V02:
      cause_str = "Quality of service unavailable";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_QOS_UNAVAILABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_REQUESTED_FACILITY_NOT_SUBSCRIBED_V02:
      cause_str = "Requested facility not subscribed";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_REQUESTED_FACILITY_NOT_SUBSCRIBED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INCOMING_CALLS_BARRED_WITHIN_CUG_V02:
      cause_str = "Incoming calls barred within the CUG";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INCOMING_CALLS_BARRED_WITHIN_CUG;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_BEARER_CAPABILITY_NOT_AUTH_V02:
      cause_str = "Bearer capability not authorized";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_BEARER_CAPABILITY_NOT_AUTHORIZED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_BEARER_CAPABILITY_UNAVAILABLE_V02:
      cause_str = "Bearer capability not presently available";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_BEARER_CAPABILITY_UNAVAILABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_SERVICE_OPTION_NOT_AVAILABLE_V02:
      cause_str = "Service or option not available, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_SERVICE_OPTION_NOT_AVAILABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_BEARER_SERVICE_NOT_IMPLEMENTED_V02:
      cause_str = "Bearer service not implemented";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_BEARER_SERVICE_NOT_IMPLEMENTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_ACM_LIMIT_EXCEEDED_V02:
      cause_str = "ACM equal to or greater than ACMmax";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_ACM_LIMIT_EXCEEDED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_REQUESTED_FACILITY_NOT_IMPLEMENTED_V02:
      cause_str = "Requested facility not implemented";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_REQUESTED_FACILITY_NOT_IMPLEMENTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE_V02:
      cause_str = "Only restricted digital information bearer capability is available";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_SERVICE_OR_OPTION_NOT_IMPLEMENTED_V02:
      cause_str = "Service or option not implemented, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_SERVICE_OR_OPTION_NOT_IMPLEMENTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INVALID_TRANSACTION_IDENTIFIER_V02:
      cause_str = "Invalid transaction identifier value";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INVALID_TRANSACTION_IDENTIFIER;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_USER_NOT_MEMBER_OF_CUG_V02:
      cause_str = "User not member of CUG";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_USER_NOT_MEMBER_OF_CUG;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INCOMPATIBLE_DESTINATION_V02:
      cause_str = "Incompatible destination";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INCOMPATIBLE_DESTINATION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INVALID_TRANSIT_NW_SELECTION_V02:
      cause_str = "Invalid transit network selection";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INVALID_TRANSIT_NW_SELECTION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_SEMANTICALLY_INCORRECT_MESSAGE_V02:
      cause_str = "Semantically incorrect message";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_SEMANTICALLY_INCORRECT_MESSAGE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INVALID_MANDATORY_INFORMATION_V02:
      cause_str = "Invalid mandatory information";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INVALID_MANDATORY_INFORMATION;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_MESSAGE_TYPE_NON_IMPLEMENTED_V02:
      cause_str = "Message type non-existent or not implemented";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_MESSAGE_TYPE_NON_IMPLEMENTED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE_V02:
      cause_str = "Message type not compatible with protocol state";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INFORMATION_ELEMENT_NON_EXISTENT_V02:
      cause_str = "Information element non-existent or not implemented";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INFORMATION_ELEMENT_NON_EXISTENT;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_CONDITONAL_IE_ERROR_V02:
      cause_str = "Conditional IE error";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_CONDITIONAL_IE_ERROR;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE_V02:
      cause_str = "Message not compatible with protocol state";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_RECOVERY_ON_TIMER_EXPIRED_V02:
      cause_str = "Recovery on timer expiry";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_RECOVERY_ON_TIMER_EXPIRED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_PROTOCOL_ERROR_UNSPECIFIED_V02:
      cause_str = "Protocol error, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_PROTOCOL_ERROR_UNSPECIFIED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    case CALL_END_CAUSE_INTERWORKING_UNSPECIFIED_V02:
      cause_str = "Interworking, unspecified";
#ifdef EXTENDED_FAIL_ERROR_CAUSE_FOR_VOICE_CALL
      ret = CALL_FAIL_INTERWORKING_UNSPECIFIED;
#else
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
#endif
      break;

    // DSDS: To enable emergency redial. Android Telephony
    // shall redial emergency call on the other sub on receiving
    // the fail cause. This cause is specific to DSDS and not
    // per spec. Telephony has locally defined the same cause codes.
    case CALL_END_CAUSE_TEMP_REDIAL_ALLOWED_V02:
      if (!cause_str) cause_str = "Temp redial allowed";
    case CALL_END_CAUSE_PERM_REDIAL_NOT_NEEDED_V02:
      if (!cause_str) cause_str = "Perm redial not needed";
      // FIXME: there is no definition for 0x145, 0x146 for RIL_LastCallFailCause
      ret = (RIL_LastCallFailCause)reason;
      break;

    case CALL_END_CAUSE_HOLD_RESUME_FAILED_V02:
      if (!cause_str) cause_str = "Resume failed";
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
      break;

    case CALL_END_CAUSE_HOLD_RESUME_CANCELED_V02:
      if (!cause_str) cause_str = "Resume canceled";
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
      break;

    case CALL_END_CAUSE_REINVITE_COLLISION_V02:
      if (!cause_str) cause_str = "Re-invite collision";
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
      break;

    case CALL_END_CAUSE_OFFLINE_V02:
      cause_str = "Radio is offline";
      ret = CALL_FAIL_RADIO_OFF;
      break;

    case CALL_END_CAUSE_NO_SRV_V02:
    case CALL_END_CAUSE_NO_GW_SRV_V02:
    case CALL_END_CAUSE_NO_FULL_SRV_V02:
    case CALL_END_CAUSE_NO_CDMA_SRV_V02:
    case CALL_END_CAUSE_NO_CELL_AVAILABLE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_NOT_CAMPED_V02:
      cause_str = "Radio is out of service";
      ret = CALL_FAIL_OUT_OF_SERVICE;
      break;

    case CALL_END_CAUSE_UIM_NOT_PRESENT_V02:
    case CALL_END_CAUSE_INVALID_SIM_V02:
      cause_str = "No valid SIM present";
      ret = CALL_FAIL_NO_VALID_SIM;
      break;

    case CALL_END_CAUSE_INCOMPATIBLE_V02:
    case CALL_END_CAUSE_ALREADY_IN_TC_V02:
    case CALL_END_CAUSE_USER_CALL_ORIG_DURING_GPS_V02:
    case CALL_END_CAUSE_USER_CALL_ORIG_DURING_SMS_V02:
    case CALL_END_CAUSE_USER_CALL_ORIG_DURING_DATA_V02:
    case CALL_END_CAUSE_TRM_REQ_FAIL_V02:
    case CALL_END_CAUSE_CALL_CANNOT_BE_IDENTIFIED_V02:
    case CALL_END_CAUSE_INCORRECT_SEMANTICS_IN_MESSAGE_V02:
    case CALL_END_CAUSE_MANDATORY_INFORMATION_INVALID_V02:
    case CALL_END_CAUSE_WRONG_STATE_V02:
    case CALL_END_CAUSE_INVALID_USER_DATA_V02:
    case CALL_END_CAUSE_CNM_MM_REL_PENDING_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_LOW_LEVEL_FAIL_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_LOW_LEVEL_FAIL_REDIAL_NOT_ALLOWED_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_LOW_LEVEL_IMMED_RETRY_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_ABORT_RADIO_UNAVAILABLE_V02:
    case CALL_END_CAUSE_THERMAL_EMERGENCY_V02:
    case CALL_END_CAUSE_INTERNAL_ERROR_V02:
      cause_str = "Radio internal error";
      ret = CALL_FAIL_RADIO_INTERNAL_ERROR;
      break;

    case CALL_END_CAUSE_CCS_NOT_SUPPORTED_BY_BS_V02:
    case CALL_END_CAUSE_REJECTED_BY_BS_V02:
    case CALL_END_CAUSE_ACC_FAIL_REJ_ORD_V02:
    case CALL_END_CAUSE_ACC_FAIL_RETRY_ORD_V02:
    case CALL_END_CAUSE_UNKNOWN_SUBSCRIBER_V02:
    case CALL_END_CAUSE_ILLEGAL_SUBSCRIBER_V02:
    case CALL_END_CAUSE_BEARER_SERVICE_NOT_PROVISIONED_V02:
    case CALL_END_CAUSE_TELE_SERVICE_NOT_PROVISIONED_V02:
    case CALL_END_CAUSE_ILLEGAL_EQUIPMENT_V02:
    case CALL_END_CAUSE_ILLEGAL_SS_OPERATION_V02:
    case CALL_END_CAUSE_SS_ERROR_STATUS_V02:
    case CALL_END_CAUSE_SS_NOT_AVAILABLE_V02:
    case CALL_END_CAUSE_SS_SUBSCRIPTION_VIOLATION_V02:
    case CALL_END_CAUSE_SS_INCOMPATIBILITY_V02:
    case CALL_END_CAUSE_FACILITY_NOT_SUPPORTED_V02:
    case CALL_END_CAUSE_ABSENT_SUBSCRIBER_V02:
    case CALL_END_CAUSE_SHORT_TERM_DENIAL_V02:
    case CALL_END_CAUSE_LONG_TERM_DENIAL_V02:
    case CALL_END_CAUSE_SYSTEM_FAILURE_V02:
    case CALL_END_CAUSE_REJECTED_BY_NETWORK_V02:
    case CALL_END_CAUSE_IMSI_UNKNOWN_IN_HLR_V02:
    case CALL_END_CAUSE_ILLEGAL_MS_V02:
    case CALL_END_CAUSE_ILLEGAL_ME_V02:
    case CALL_END_CAUSE_PLMN_NOT_ALLOWED_V02:
    case CALL_END_CAUSE_LOCATION_AREA_NOT_ALLOWED_V02:
    case CALL_END_CAUSE_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA_V02:
    case CALL_END_CAUSE_NO_SUITABLE_CELLS_IN_LOCATION_AREA_V02:
    case CALL_END_CAUSE_NETWORK_FAILURE_V02:
    case CALL_END_CAUSE_MAC_FAILURE_V02:
    case CALL_END_CAUSE_SYNCH_FAILURE_V02:
    case CALL_END_CAUSE_GSM_AUTHENTICATION_UNACCEPTABLE_V02:
    case CALL_END_CAUSE_SERVICE_NOT_SUBSCRIBED_V02:
    case CALL_END_CAUSE_ABORT_MSG_RECEIVED_V02:
    case CALL_END_CAUSE_SERVICE_OPTION_NOT_SUPPORTED_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_CONN_REJECT_V02:
    case CALL_END_CAUSE_UNAUTHORIZED_V02:
    case CALL_END_CAUSE_PAYMENT_REQUIRED_V02:
    case CALL_END_CAUSE_EMM_REJ_SERVICE_REQ_FAILURE_LTE_NW_REJECT_V02:
    case CALL_END_CAUSE_EMM_REJ_SERVICE_REQ_FAILURE_CS_DOMAIN_NOT_AVAILABLE_V02:
    case CALL_END_CAUSE_EMM_REJ_V02:
      cause_str = "Explicit network reject";
      ret = CALL_FAIL_NETWORK_REJECT;
      break;

    case CALL_END_CAUSE_NO_RESPONSE_FROM_BS_V02:
    case CALL_END_CAUSE_TIMEOUT_T42_V02:
    case CALL_END_CAUSE_TIMEOUT_T40_V02:
    case CALL_END_CAUSE_T50_EXP_V02:
    case CALL_END_CAUSE_T51_EXP_V02:
    case CALL_END_CAUSE_RL_ACK_TIMEOUT_V02:
    case CALL_END_CAUSE_BAD_FL_V02:
    case CALL_END_CAUSE_TIMEOUT_T41_V02:
    case CALL_END_CAUSE_TIMER_T3230_EXPIRED_V02:
    case CALL_END_CAUSE_TIMER_T303_EXPIRED_V02:
    case CALL_END_CAUSE_MT_CSFB_NO_RESPONSE_FROM_NW_V02:
    case CALL_END_CAUSE_EMM_REJ_TIMER_T3417_EXT_EXP_V02:
    case CALL_END_CAUSE_EMM_REJ_TIMER_T3417_EXP_V02:
      cause_str = "No response from network";
      ret = CALL_FAIL_NETWORK_RESP_TIMEOUT;
      break;

    case CALL_END_CAUSE_CALL_BARRED_V02:
      cause_str = "Call is barred";
      ret = CALL_FAIL_CALL_BARRED;
      break;

    case CALL_END_CAUSE_ACCESS_STRATUM_FAILURE_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_RR_RANDOM_ACCESS_FAILURE_V02:
    case CALL_END_CAUSE_ESR_FAILURE_V02:
    case CALL_END_CAUSE_CS_ACQ_FAILURE_V02:
      cause_str = "Radio access failure";
      ret = CALL_FAIL_RADIO_ACCESS_FAILURE;
      break;

    case CALL_END_CAUSE_ACCESS_CLASS_BLOCKED_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_ACCESS_BARRED_V02:
    case CALL_END_CAUSE_SSAC_REJECT_V02:
      cause_str = "Access class blocked";
      ret = CALL_FAIL_ACCESS_CLASS_BLOCKED;
      break;

    case CALL_END_CAUSE_FADE_V02:
    case CALL_END_CAUSE_RADIO_LINK_LOST_V02:
      cause_str = "Radio link lost";
      ret = CALL_FAIL_RADIO_LINK_LOST;
      break;

    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_RR_REL_IND_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_RRC_REL_IND_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_NORMAL_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_OOS_DURING_CRE_V02:
      cause_str = "RRC connection release, normal";
      ret = CALL_FAIL_RADIO_RELEASE_NORMAL;
      break;

    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_RRC_CLOSE_SESSION_IND_V02:
    case CALL_END_CAUSE_ACCESS_STRATUM_REJ_RRC_OPEN_SESSION_FAILURE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_CRE_FAILURE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_ABORTED_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_SIB_READ_ERROR_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_ABORTED_IRAT_SUCCESS_V02:
      cause_str = "RRC connection release, abnormal";
      ret = CALL_FAIL_RADIO_RELEASE_ABNORMAL;
      break;

    case CALL_END_CAUSE_AS_REJ_LRRC_UL_DATA_CNF_FAILURE_TXN_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_UL_DATA_CNF_FAILURE_HO_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_UL_DATA_CNF_FAILURE_CONN_REL_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_UL_DATA_CNF_FAILURE_CTRL_NOT_CONN_V02:
      cause_str = "Radio uplink failure";
      ret = CALL_FAIL_RADIO_UPLINK_FAILURE;
      break;

    case CALL_END_CAUSE_AS_REJ_LRRC_UL_DATA_CNF_FAILURE_RLF_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_LINK_FAILURE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_REL_RLF_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_RADIO_LINK_FAILURE_V02:
    case CALL_END_CAUSE_CONNECTION_FAILURE_V02:
    case CALL_END_CAUSE_RLF_DURING_CC_DISCONNECT_V02:
      cause_str = "Radio link failure";
      ret = CALL_FAIL_RADIO_LINK_FAILURE;
      break;

    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_ABORTED_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_CELL_RESEL_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_CONFIG_FAILURE_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_TIMER_EXPIRED_V02:
    case CALL_END_CAUSE_AS_REJ_LRRC_CONN_EST_FAILURE_SI_FAILURE_V02:
    case CALL_END_CAUSE_CONNECTION_EST_FAILURE_V02:
      cause_str = "Radio setup failure";
      ret = CALL_FAIL_RADIO_SETUP_FAILURE;
      break;

    case CALL_END_CAUSE_AS_REJ_DETACH_WITH_REATTACH_LTE_NW_DETACH_V02:
    case CALL_END_CAUSE_AS_REJ_DETACH_WITH_OUT_REATTACH_LTE_NW_DETACH_V02:
    case CALL_END_CAUSE_PDN_DISCONNECTED_V02:
      cause_str = "Explicit Network Detach";
      ret = CALL_FAIL_NETWORK_DETACH;
      break;

    default:
      cause_str = "Error unspecified";
      ret = CALL_FAIL_ERROR_UNSPECIFIED;
      break;
  } /* end switch */
  QCRIL_LOG_ESSENTIAL("map qmi reason: %d to ril reason: %d", reason, ret);

  if (fail_cause_str)
  {
    strlcpy(fail_cause_str, cause_str, fail_cause_str_len);
    QCRIL_LOG_ESSENTIAL("ril reason str: %s\n", fail_cause_str);
  }

  return ret;
}/* qcril_qmi_voice_map_qmi_to_ril_last_call_failure_cause */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_map_ril_reason_to_str

===========================================================================*/
/*!
    @brief
    Maps last call failure cause enum to string

    @return
    String corresponds to RIL last call failure cause
*/
/*=========================================================================*/
void qcril_qmi_voice_map_ril_reason_to_str
(
 int reason,
 char                 *reason_str, /*!< Output parameter */
 size_t                reason_str_sz
)
{
  const char *cause_str = NULL;
  switch ( reason )
  {
    case CALL_FAIL_FDN_BLOCKED:
      cause_str = "FDN Blocked";
      break;

    case CALL_FAIL_DIAL_MODIFIED_TO_DIAL:
      cause_str = "Call Control; dial modified to dial";
      break;

    case CALL_FAIL_DIAL_MODIFIED_TO_USSD:
      cause_str = "Call Control; dial modified to USSD";
      break;

    case CALL_FAIL_DIAL_MODIFIED_TO_SS:
      cause_str = "Call Control; dial modified to SS";
      break;

    case QCRIL_CALL_FAIL_DIAL_MODIFIED_TO_DIAL_VIDEO:
      cause_str = "Call Control; dial modified to dial video";
      break;

    case QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_DIAL:
      cause_str = "Call Control; dial video modified to dial";
      break;

    case QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
      cause_str = "Call Control; dial video modified to dial video";
      break;

    case QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_USSD:
      cause_str = "Call Control; dial video modified to USSD";
      break;

    case QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_SS:
      cause_str = "Call Control; dial video modified to SS";
      break;

    case CALL_FAIL_ERROR_UNSPECIFIED:
    default:
      cause_str = "Error unspecified";
      break;
  }

  if (reason_str)
  {
    strlcpy(reason_str, cause_str, reason_str_sz);
    QCRIL_LOG_ESSENTIAL("ril reason str: %s\n", reason_str);
  }
}

//===========================================================================
// qcril_qmi_voice_last_call_failure_cause_lock
//===========================================================================
static inline void qcril_qmi_voice_last_call_failure_cause_lock()
{
  pthread_mutex_lock( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex );
} // qcril_qmi_voice_last_call_failure_cause_lock

//===========================================================================
// qcril_qmi_voice_last_call_failure_cause_unlock
//===========================================================================
static inline void qcril_qmi_voice_last_call_failure_cause_unlock()
{
  pthread_mutex_unlock( &qcril_qmi_voice_info.last_call_failure_cause.call_failure_cause_lock_mutex );
} // qcril_qmi_voice_last_call_failure_cause_unlock

//===========================================================================
// qcril_qmi_voice_info_lock
//===========================================================================
static inline void qcril_qmi_voice_info_lock()
{
  pthread_mutex_lock( &qcril_qmi_voice_info.voice_info_lock_mutex );
} // qcril_qmi_voice_info_lock

//===========================================================================
// qcril_qmi_voice_info_unlock
//===========================================================================
static inline void qcril_qmi_voice_info_unlock()
{
  pthread_mutex_unlock( &qcril_qmi_voice_info.voice_info_lock_mutex );
} // qcril_qmi_voice_info_unlock

//===========================================================================
// qcril_qmi_voice_diag_odl_lock
//===========================================================================
static inline void qcril_qmi_voice_diag_odl_lock()
{
  pthread_mutex_lock(&diag_odl_logging_in_progress_mutex);
} // qcril_qmi_voice_diag_odl_lock

//===========================================================================
// qcril_qmi_voice_diag_odl_unlock
//===========================================================================
static inline void qcril_qmi_voice_diag_odl_unlock()
{
  pthread_mutex_unlock(&diag_odl_logging_in_progress_mutex);

} // qcril_qmi_voice_diag_odl_unlock

//===========================================================================
// qcril_qmi_voice_store_last_call_failure_cause_ex
//===========================================================================
void qcril_qmi_voice_store_last_call_failure_cause_ex
(
  RIL_LastCallFailCause  reason,
  uint8 *extended_codes,
  int extended_codes_len,
  char *reason_str,
  int reason_str_len,
  uint8_t sip_error_code_valid,
  uint16_t sip_error_code
)
{
  QCRIL_LOG_INFO("store ril reason: %d", reason);
  qcril_qmi_voice_last_call_failure_cause_lock();
  qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause_valid = TRUE;
  qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause = reason;
  qcril_qmi_voice_info.sip_error_code_valid = sip_error_code_valid;
  qcril_qmi_voice_info.sip_error_code = sip_error_code;

  if (qcril_qmi_voice_info.last_call_failure_extended_codes)
  {
    qcril_free(qcril_qmi_voice_info.last_call_failure_extended_codes);
    qcril_qmi_voice_info.last_call_failure_extended_codes_len = 0;
  }

  if (extended_codes_len && extended_codes)
  {
    qcril_qmi_voice_info.last_call_failure_extended_codes = (uint8*)qcril_malloc(extended_codes_len);
    if (qcril_qmi_voice_info.last_call_failure_extended_codes)
    {
       memcpy(qcril_qmi_voice_info.last_call_failure_extended_codes, extended_codes, extended_codes_len);
       qcril_qmi_voice_info.last_call_failure_extended_codes_len = extended_codes_len;
    }
    else
    {
       QCRIL_LOG_ERROR("malloc failed");
    }
  }

  if (qcril_qmi_voice_info.last_call_failure_cause_str)
  {
    qcril_free(qcril_qmi_voice_info.last_call_failure_cause_str);
    qcril_qmi_voice_info.last_call_failure_cause_str = NULL;
    qcril_qmi_voice_info.last_call_failure_cause_str_len = 0;
  }
  if (reason_str_len && reason_str)
  {
    qcril_qmi_voice_info.last_call_failure_cause_str = (char*)qcril_malloc(reason_str_len+1);
    if (qcril_qmi_voice_info.last_call_failure_cause_str)
    {
       memcpy(qcril_qmi_voice_info.last_call_failure_cause_str, reason_str, reason_str_len+1);
       qcril_qmi_voice_info.last_call_failure_cause_str_len = reason_str_len+1;
    }
    else
    {
       QCRIL_LOG_ERROR("malloc failed");
    }
  }
  qcril_qmi_voice_last_call_failure_cause_unlock();
} // qcril_qmi_voice_store_last_call_failure_cause_ex

//===========================================================================
// qcril_qmi_voice_invalid_last_call_failure_cause
//===========================================================================
void qcril_qmi_voice_invalid_last_call_failure_cause()
{
  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_last_call_failure_cause_lock();
  qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause_valid = FALSE;
  qcril_qmi_voice_last_call_failure_cause_unlock();
} // qcril_qmi_voice_invalid_last_call_failure_cause

//===========================================================================
// qcril_qmi_voice_set_last_call_fail_request_timeout
//===========================================================================
void qcril_qmi_voice_set_last_call_fail_request_timeout()
{
  const struct timeval timeout_value = {3,0}; // 3 seconds
  uint32 timer_id = 0;

  QCRIL_LOG_FUNC_ENTRY();
  qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                              QCRIL_DEFAULT_MODEM_ID,
                              qcril_qmi_voice_last_call_fail_request_timeout_handler,
                              &timeout_value,
                              &timer_id );

  qcril_qmi_voice_last_call_failure_cause_lock();
  qcril_qmi_voice_info.last_call_failure_cause.pending_req = TRUE;
  qcril_qmi_voice_info.last_call_failure_cause.pending_request_timeout_timer_id = timer_id;
  qcril_qmi_voice_last_call_failure_cause_unlock();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_set_last_call_fail_request_timeout

//===========================================================================
// qcril_qmi_voice_last_call_fail_request_timeout_handler
//===========================================================================
void qcril_qmi_voice_last_call_fail_request_timeout_handler(void * param)
{
  qcril_request_resp_params_type resp;
  boolean response_sent = FALSE;

  QCRIL_NOTUSED( param );

  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_last_call_failure_cause_lock();
  if (qcril_qmi_voice_info.last_call_failure_cause.pending_req)
  {
    qcril_reqlist_public_type request_info;
    if (E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_LAST_CALL_FAIL_CAUSE, &request_info))
    {
      QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : %d", qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause);
      qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID, request_info.t, request_info.request,
                                        RIL_E_INTERNAL_ERR, &resp );
      qcril_send_request_response( &resp );
      response_sent = TRUE;
    }

    if (E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_IMS_SOCKET_REQ_LAST_CALL_FAIL_CAUSE, &request_info))
    {
      imsRadioSendMessage(request_info.t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_LAST_CALL_FAIL_CAUSE, ims_Error_E_GENERIC_FAILURE, NULL, 0);
      response_sent = TRUE;
    }

    qcril_qmi_voice_info.last_call_failure_cause.pending_req = FALSE;
  }
  qcril_qmi_voice_last_call_failure_cause_unlock();

  if (response_sent)
  {

    qcril_qmi_voice_voip_lock_overview();
    qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl();
    qcril_qmi_voice_voip_unlock_overview();

    if (qcril_qmi_voice_voip_call_info_entries_is_empty())
    {
        QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
        if (!qcril_stop_diag_log())
        {
            QCRIL_LOG_INFO("qxdm logging disabled successfully");
        }
    }

  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_last_call_fail_request_timeout_handler

//===========================================================================
// qcril_qmi_voice_respond_ril_last_call_failure_request
//===========================================================================
void qcril_qmi_voice_respond_ril_last_call_failure_request()
{
  qcril_request_resp_params_type resp;

  int                       call_obj_review_needed;
  qcril_reqlist_public_type request_info;

  QCRIL_LOG_FUNC_ENTRY();

  call_obj_review_needed    = FALSE;

  qcril_qmi_voice_last_call_failure_cause_lock();

  if ( TRUE == qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause_valid )
  {
    // find all pending request if we have and send the resoponse
    QCRIL_LOG_INFO("last_call_failure_cause is valid. Will send the response if there is any pending ril request.");
    while ( E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_LAST_CALL_FAIL_CAUSE, &request_info) ||
            E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_IMS_SOCKET_REQ_LAST_CALL_FAIL_CAUSE, &request_info)
          )
    {
      call_obj_review_needed = TRUE;

      if ( QCRIL_EVT_RIL_REQUEST_LAST_CALL_FAIL_CAUSE == request_info.request )
      {
        QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : %d", qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause);
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, request_info.t, request_info.request,
                                          RIL_E_SUCCESS, &resp );

        RIL_LastCallFailCauseInfo cause_info;
        memset(&cause_info, 0, sizeof(cause_info));
        cause_info.cause_code   =
            qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause;
        cause_info.vendor_cause =
            (char*)qcril_malloc(qcril_qmi_voice_info.last_call_failure_cause_str_len);
        if (cause_info.vendor_cause)
        {
          if (qcril_qmi_voice_info.last_call_failure_cause_str &&
                  qcril_qmi_voice_info.last_call_failure_cause_str_len)
          {
            strlcpy(cause_info.vendor_cause,
                    qcril_qmi_voice_info.last_call_failure_cause_str,
                    qcril_qmi_voice_info.last_call_failure_cause_str_len);
          }
        }

        resp.resp_pkt = (void *) &cause_info;
        resp.resp_len = sizeof(cause_info);
        qcril_send_request_response( &resp );

        qcril_free(cause_info.vendor_cause);
      }
      else
      {
        qcril_binary_data_type bin_data;
        ims_CallFailCauseResponse lfc;
        memset(&lfc, 0, sizeof(lfc));

        lfc.has_failcause = TRUE;
        lfc.failcause = (ims_CallFailCause) qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause;

        if (qcril_qmi_voice_info.last_call_failure_extended_codes_len > 0)
        {
          lfc.failcause = qcril_qmi_ims_map_ril_failcause_to_ims_failcause(
              qcril_qmi_voice_info.last_call_failure_cause.last_call_failure_cause,
              atoi((char*)qcril_qmi_voice_info.last_call_failure_extended_codes),
              qcril_qmi_voice_info.sip_error_code_valid,
              qcril_qmi_voice_info.sip_error_code
          );
          bin_data.len = qcril_qmi_voice_info.last_call_failure_extended_codes_len;
          bin_data.data = qcril_qmi_voice_info.last_call_failure_extended_codes;
          lfc.errorinfo.arg = (void*)&bin_data;
        }

        imsRadioSendMessage(request_info.t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_LAST_CALL_FAIL_CAUSE, (ims_Error)RIL_E_SUCCESS, &lfc, sizeof(lfc));
      }

      qcril_qmi_voice_stk_cc_relay_alpha_if_necessary( QCRIL_DEFAULT_INSTANCE_ID, FALSE );
    }

    if ( call_obj_review_needed )
    {
      qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl();
    }

    if ( qcril_qmi_voice_info.last_call_failure_cause.pending_req )
    {
      qcril_qmi_voice_info.last_call_failure_cause.pending_req = FALSE;
      qcril_cancel_timed_callback((void *)(uintptr_t) qcril_qmi_voice_info.last_call_failure_cause.pending_request_timeout_timer_id);
    }
  }
  else
  {
    QCRIL_LOG_INFO("last_call_failure_cause is not valid. The response will be delayed after we get the valid value.");
  }
  qcril_qmi_voice_last_call_failure_cause_unlock();

  if (qcril_qmi_voice_voip_call_info_entries_is_empty())
  {
      QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
      if (!qcril_stop_diag_log())
      {
          QCRIL_LOG_INFO("qxdm logging disabled successfully");
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_respond_ril_last_call_failure_request

//===========================================================================
// qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl
//===========================================================================
void qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl( void )
{
  qcril_qmi_voice_voip_call_info_entry_type* call_info = NULL;

  int                       cleanup_evaluation_needed;

  QCRIL_LOG_FUNC_ENTRY();

  cleanup_evaluation_needed = FALSE;

  call_info = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info )
  {
    if ( VOICE_INVALID_CALL_ID != call_info->android_call_id &&
         CALL_STATE_END_V02 == call_info->voice_scv_info.call_state &&
         !( call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LAST_CALL_FAILURE_REPORTED )
       )
    {
      call_info->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LAST_CALL_FAILURE_REPORTED;

      cleanup_evaluation_needed = TRUE;
    }
    call_info = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }

  if ( cleanup_evaluation_needed )
  {
    qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl();
  }
  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_review_call_objs_after_last_call_failure_response_vcl

//===========================================================================
// qcril_qmi_voice_handle_new_last_call_failure_cause
//===========================================================================
void qcril_qmi_voice_handle_new_last_call_failure_cause(int reason, boolean is_qmi_reason,
    uint8_t raw_code_valid, uint8_t raw_code, uint8_t sip_code_valid, uint8_t sip_code,
    uint8_t end_reason_text_valid, char *end_reason_text, qcril_qmi_voice_voip_call_info_entry_type *call_obj)
{
  QCRIL_LOG_FUNC_ENTRY();
  RIL_LastCallFailCause ril_reason;
  char extended_codes[MAX_DEC_INT_STR + 1] = {0};
  char reason_str[QCRIL_QMI_VOICE_FAIL_CAUSE_STR_LEN] = {0};

  if ( is_qmi_reason )
  {
    ril_reason = qcril_qmi_voice_map_qmi_to_ril_last_call_failure_cause(
            (call_end_reason_enum_v02)reason,
            raw_code_valid,
            raw_code,
            sip_code_valid,
            sip_code,
            end_reason_text_valid,
            end_reason_text,
            reason_str,
            QCRIL_QMI_VOICE_FAIL_CAUSE_STR_LEN);
  }
  else
  {
    ril_reason = (RIL_LastCallFailCause)reason;
    qcril_qmi_voice_map_ril_reason_to_str((int)ril_reason, reason_str, sizeof(reason_str));
  }
  QCRIL_LOG_INFO("reason_str = %s", reason_str);
  snprintf(extended_codes, MAX_DEC_INT_STR, "%d\n", reason);
  qcril_qmi_voice_store_last_call_failure_cause_ex(
          ril_reason,
          (uint8_t*)extended_codes,
          strlen(extended_codes),
          reason_str,
          strlen(reason_str),
          sip_code_valid,
          sip_code);
  qcril_qmi_voice_respond_ril_last_call_failure_request();
  if (call_obj)
  {
     call_obj->lcf_valid = TRUE;
     call_obj->lcf = ril_reason;
     snprintf(call_obj->lcf_extended_codes, MAX_DEC_INT_STR, "%d", reason);
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_handle_new_last_call_failure_cause

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_send_unsol_call_state_changed

===========================================================================*/
/*!
    @brief
    Send RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED.

    @return
    none
*/
/*=========================================================================*/
void qcril_qmi_voice_send_unsol_call_state_changed
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_unsol_resp_params_type unsol_resp;

  QCRIL_LOG_FUNC_ENTRY();

  if( instance_id < QCRIL_MAX_INSTANCE_ID )
  {
    /* Report the call state change for voice or CS data calls */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, &unsol_resp );
    qcril_send_unsol_response( &unsol_resp );
  }
} /* qcril_qmi_voice_send_unsol_call_state_changed */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_make_incoming_call_ring
===========================================================================*/
void qcril_qmi_voice_make_incoming_call_ring (qcril_timed_callback_handler_params_type *param)
{
  qcril_qmi_voice_voip_call_info_entry_type*    call_info = NULL;
  qcril_unsol_resp_params_type unsol_resp;
  int                                           need_ring_to_ui;
  int                                           need_reiterate;
  int                                           is_1x;
  int                                           is_ims_call;

  static const struct timeval TIMEVAL_DELAY = {3,0}; // 3 seconds

  QCRIL_LOG_FUNC_ENTRY();

  need_ring_to_ui = FALSE;
  need_reiterate  = FALSE;
  is_1x           = FALSE;
  qcril_qmi_voice_voip_lock_overview();

  call_info = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING, TRUE );
  QCRIL_LOG_INFO(".. call obj %p", call_info );
  if ( call_info )
  {
    qcril_qmi_voice_voip_call_info_dump( call_info );

    call_info->ringing_time_id = QMI_RIL_ZERO;

    is_1x = (CALL_MODE_CDMA_V02 == call_info->voice_scv_info.mode) ? TRUE : FALSE;

    is_ims_call = qcril_qmi_voice_call_to_ims(call_info);

    if ( call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_RING_DONE || !is_1x )
    {
      call_info->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_RING_DONE;
      need_ring_to_ui = TRUE;
    }

    if ( !is_1x && (call_info->voice_scv_info.call_state == CALL_STATE_SETUP_V02) ) // no follow up will be needed for 1x or non-setup call
    {
      need_reiterate = TRUE;
    }

    if ( !need_reiterate )
    {
      call_info->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING;
    }
    else
    {
      call_info->elaboration |= QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID;
      qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_voice_make_incoming_call_ring,
                                                NULL, // nothing to pass through as no param for non 1x
                                                TRUE,
                                                &TIMEVAL_DELAY,
                                                &call_info->ringing_time_id );
    }
  }

  qcril_qmi_voice_voip_unlock_overview();

  QCRIL_LOG_INFO(".. need ring ui %d, need reiterate %d", (int) need_ring_to_ui, (int) need_reiterate );
  if ( need_ring_to_ui )
  {
    if (!is_ims_call)
    {
      qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_CALL_RING, &unsol_resp );
      if ( is_1x && NULL != param->custom_param )
      {
        QCRIL_LOG_INFO("signal_info signal_type: %d, alert_pitch: %d, signal: %d",
                      ((RIL_CDMA_SignalInfoRecord *)param->custom_param)->signalType,
                      ((RIL_CDMA_SignalInfoRecord *)param->custom_param)->alertPitch,
                      ((RIL_CDMA_SignalInfoRecord *)param->custom_param)->signal);

        unsol_resp.resp_pkt = ( void * ) param->custom_param;
        unsol_resp.resp_len = sizeof( RIL_CDMA_SignalInfoRecord );
      }
      qcril_send_unsol_response( &unsol_resp );
    }
    else
    {
      imsRadioSendEmptyUnsolResponse(ims_MsgId_UNSOL_CALL_RING);
    }
  }

  if ( param->custom_param )
  {
    qcril_free( param->custom_param );
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_make_incoming_call_ring */

//===========================================================================
// qmi_ril_succeed_on_pending_hangup_req_on_no_calls_left
//===========================================================================
void qmi_ril_succeed_on_pending_hangup_req_on_no_calls_left(void)
{
  qcril_reqlist_public_type       request_info;
  IxErrnoType                     lookup_res;
  qcril_request_resp_params_type  resp;


  QCRIL_LOG_FUNC_ENTRY();

  do
  {
     lookup_res = qcril_reqlist_query_by_request( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_HANGUP, &request_info );
     if ( E_SUCCESS == lookup_res )
       break;

     lookup_res = qcril_reqlist_query_by_request( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, &request_info );
     if ( E_SUCCESS == lookup_res )
       break;

     lookup_res = qcril_reqlist_query_by_request( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, &request_info );
  } while (FALSE);

  if ( E_SUCCESS == lookup_res )
  { // a pending HANGUP_xxx request
      qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                        request_info.t,
                                        request_info.request,
                                        RIL_E_SUCCESS,
                                        &resp );
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_succeed_on_pending_hangup_req_on_no_calls_left

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_otasp_status_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_QMI_VOICE_OTASP_STATUS_IND

    @return
    RIL_CDMA_OTA_ProvisionStatus.
*/
/*=========================================================================*/
void qcril_qmi_voice_otasp_status_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_otasp_status_ind_msg_v02* otasp_status_ind_ptr = NULL;
  RIL_CDMA_OTA_ProvisionStatus response;
  qcril_unsol_resp_params_type unsol_resp;
  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
  QCRIL_NOTUSED(ind_data_len);


  if( ind_data_ptr != NULL )
  {

      otasp_status_ind_ptr = (voice_otasp_status_ind_msg_v02*)ind_data_ptr;

      QCRIL_LOG_DEBUG( "QCRIL_EVT_QMI_VOICE_OTASP_STATUS_IND status = %d for conn id %d",
                           otasp_status_ind_ptr->otasp_status_info.otasp_status,
                           otasp_status_ind_ptr->otasp_status_info.call_id);

      response = (RIL_CDMA_OTA_ProvisionStatus)otasp_status_ind_ptr->otasp_status_info.otasp_status;
      qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &response;
      unsol_resp.resp_len = sizeof( response );
      qcril_send_unsol_response( &unsol_resp );

      qcril_qmi_voice_voip_lock_overview();
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( otasp_status_ind_ptr->otasp_status_info.call_id );
      if ( call_info_entry )
      {
        call_info_entry->voice_svc_otasp_status = otasp_status_ind_ptr->otasp_status_info.otasp_status;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_OTASP_STATUS_VALID;
        QCRIL_LOG_INFO( ".. caching otasp" );
      }
      qcril_qmi_voice_voip_unlock_overview();
  }

} /* qcril_qmi_voice_otasp_status_ind_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_privacy_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_VOICE_PRIVACY_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_privacy_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_privacy_ind_msg_v02* privacy_ind_ptr = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
  boolean unsol_call_state_change_to_atel = FALSE;
  boolean unsol_call_state_change_to_ims = FALSE;
  QCRIL_NOTUSED(ind_data_len);

  if( ind_data_ptr != NULL )
  {
      privacy_ind_ptr = (voice_privacy_ind_msg_v02*)ind_data_ptr;

      QCRIL_LOG_INFO("Privacy indication received with privacy %d for conn id %d",
                                   privacy_ind_ptr->voice_privacy_info.voice_privacy,
                                   privacy_ind_ptr->voice_privacy_info.call_id);

      qcril_qmi_voice_voip_lock_overview();
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( privacy_ind_ptr->voice_privacy_info.call_id );
      if ( call_info_entry )
      {
        call_info_entry->voice_svc_voice_privacy = privacy_ind_ptr->voice_privacy_info.voice_privacy;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VOICE_PRIVACY_VALID;
        QCRIL_LOG_INFO( ".. caching voice privacy" );
        unsol_call_state_change_to_atel = qcril_qmi_voice_call_to_atel(call_info_entry);
        unsol_call_state_change_to_ims  = qcril_qmi_voice_call_to_ims (call_info_entry);
      }
      qcril_qmi_voice_voip_unlock_overview();

      if (unsol_call_state_change_to_atel)
      {
         qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
      }

      if (unsol_call_state_change_to_ims)
      {
         qcril_qmi_voice_send_ims_unsol_call_state_changed();
      }
  }

}/* qcril_qmi_voice_privacy_ind_hdlr */

//===========================================================================
// qcril_qmi_voice_uus_ind_hdlr
//===========================================================================
void qcril_qmi_voice_uus_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_uus_ind_msg_v02* uus_ind_ptr = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
  QCRIL_NOTUSED(ind_data_len);

  if( ind_data_ptr != NULL )
  {
      uus_ind_ptr = (voice_uus_ind_msg_v02*)ind_data_ptr;

      QCRIL_LOG_INFO("UUS indication received for call id %d with type %d, dcs %d, data len %d ",
                                   (int)uus_ind_ptr->uus_information.call_id,
                                   (int)uus_ind_ptr->uus_information.uus_type,
                                   (int)uus_ind_ptr->uus_information.uus_dcs,
                                   (int)uus_ind_ptr->uus_information.uus_data_len
                     );

      qcril_qmi_voice_voip_lock_overview();
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( uus_ind_ptr->uus_information.call_id );
      if ( call_info_entry )
      {
        qcril_qmi_voice_voip_update_call_info_uus(
                                                  call_info_entry,
                                                  uus_ind_ptr->uus_information.uus_type,
                                                  uus_ind_ptr->uus_information.uus_dcs,
                                                  uus_ind_ptr->uus_information.uus_data_len,
                                                  uus_ind_ptr->uus_information.uus_data
                                                 );
      }
      qcril_qmi_voice_voip_unlock_overview();
  }

} // qcril_qmi_voice_uus_ind_hdlr

//===========================================================================
// qcril_qmi_voice_respond_pending_hangup_ril_response
//===========================================================================
void qcril_qmi_voice_respond_pending_hangup_ril_response(uint8_t call_id)
{
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  qcril_reqlist_public_type request_info;

  QCRIL_LOG_FUNC_ENTRY();

  call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( call_id );

  if ( (NULL != call_info_entry) && (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_HANGUP_RESP) )
  {
    if (E_SUCCESS == qcril_reqlist_query(QCRIL_DEFAULT_INSTANCE_ID, call_info_entry->pending_end_call_req_tid, &request_info))
    {
      qcril_qmi_send_hangup_response(request_info.request, request_info.t, RIL_E_SUCCESS);
      call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_HANGUP_RESP;
    }
    else
    {
      QCRIL_LOG_ERROR("no pending Telphony end call request is found");
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_respond_pending_hangup_ril_response

//===========================================================================
// qcril_qmi_voice_setup_num_1x_wait_timer
//===========================================================================
static void qcril_qmi_voice_setup_num_1x_wait_timer()
{
  const struct timeval num_1x_wait_timeout  = { 1 , 0 }; // 1 second
  uint32               num_1x_wait_timer_id = QMI_RIL_ZERO;

  QCRIL_LOG_FUNC_ENTRY();
  if (QMI_RIL_ZERO != qmi_voice_voip_overview.num_1x_wait_timer_id)
  {
    qcril_cancel_timed_callback((void*)(uintptr_t) qmi_voice_voip_overview.num_1x_wait_timer_id);
    qmi_voice_voip_overview.num_1x_wait_timer_id = QMI_RIL_ZERO;
  }

  qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
      QCRIL_DEFAULT_MODEM_ID,
      qmi_ril_voice_pending_1x_num_timeout,
      &num_1x_wait_timeout,
      &num_1x_wait_timer_id);

  if (QMI_RIL_ZERO != num_1x_wait_timer_id)
  {
    qmi_voice_voip_overview.num_1x_wait_timer_id = num_1x_wait_timer_id;

    QCRIL_LOG_INFO("num_1x_wait_timer_wakelock_is_acquired = %d",
            qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired);
    // Acquire wake lock
    if (qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired == FALSE)
    {
      acquire_wake_lock(PARTIAL_WAKE_LOCK, QCRIL_NUM_1X_WAIT_WAKE_LOCK_NAME);
      qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired = TRUE;
      qmi_ril_set_property_value_to_string(QCRIL_NUM_1X_WAIT_WAKE_LOCK_PROP, "true");
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_setup_num_1x_wait_timer

//===========================================================================
// qcril_qmi_voice_cancel_num_1x_wait_timer
//===========================================================================
static void qcril_qmi_voice_cancel_num_1x_wait_timer()
{
  QCRIL_LOG_FUNC_ENTRY();
  if (QMI_RIL_ZERO != qmi_voice_voip_overview.num_1x_wait_timer_id)
  {
    qcril_cancel_timed_callback((void*)(uintptr_t) qmi_voice_voip_overview.num_1x_wait_timer_id);
    qmi_voice_voip_overview.num_1x_wait_timer_id = QMI_RIL_ZERO;
  }

  // Release wake lock
  QCRIL_LOG_INFO("num_1x_wait_timer_wakelock_is_acquired = %d",
          qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired);
  if (qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired == TRUE)
  {
    release_wake_lock(QCRIL_NUM_1X_WAIT_WAKE_LOCK_NAME);
    qmi_voice_voip_overview.num_1x_wait_timer_wakelock_is_acquired = FALSE;
    qmi_ril_set_property_value_to_string(QCRIL_NUM_1X_WAIT_WAKE_LOCK_PROP, "false");
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_cancel_num_1x_wait_timer

//===========================================================================
// qmi_ril_voice_pending_1x_num_timeout
//===========================================================================
void qmi_ril_voice_pending_1x_num_timeout(void * param)
{
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_qmi_voice_voip_lock_overview();

    qcril_qmi_voice_cancel_num_1x_wait_timer();

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration ( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING, TRUE );
    if ( call_info_entry )
    {
      call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;

      qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
    }

    qcril_qmi_voice_voip_unlock_overview();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_pending_1x_num_timeout

//===========================================================================
// qcril_qmi_voice_set_ps_cs_call_elab_vcl
//===========================================================================
void qcril_qmi_voice_set_ps_cs_call_elab_vcl(const voice_call_info2_type_v02* iter_call_info, qcril_qmi_voice_voip_call_info_entry_type *call_info_entry)
{
   call_mode_enum_v02 call_mode;
   call_type_enum_v02 call_type;

   if (NULL == call_info_entry)
   {
      QCRIL_LOG_ERROR("call_info_entry is NULL");
   }
   else
   {
      if (NULL != iter_call_info)
      {
         call_type = iter_call_info->call_type;
         call_mode = iter_call_info->mode;
      }
      else
      {
         call_type = call_info_entry->voice_scv_info.call_type;
         call_mode = call_info_entry->voice_scv_info.mode;
      }

      if ((CALL_TYPE_VOICE_IP_V02 == call_type ||
           CALL_TYPE_VT_V02 == call_type ||
           CALL_TYPE_EMERGENCY_IP_V02 == call_type ||
           CALL_TYPE_EMERGENCY_VT_V02 == call_type) &&
              isImsRadioConnected())
      {
         if ( !(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN) ||
              CALL_MODE_NO_SRV_V02 != call_mode
            )
         {
            // if the call type is a PS call, and we either get a determined call_mode or it is not a dialed call on auto domain, set it as a PS call
            QCRIL_LOG_INFO("set the call as a PS call");
            call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
            call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
         }
      }
      else if (CALL_MODE_NO_SRV_V02 != call_mode && CALL_MODE_UNKNOWN_V02 != call_mode && CALL_MODE_LTE_V02 != call_mode)
      {
         // if the call type is a CS call and the call_mode is determined(not no_srv), set it as a CS call
         QCRIL_LOG_INFO("set the call as a CS call");
         call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
         call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
         call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
      }
   }
} // qcril_qmi_voice_set_ps_cs_call_elab_vcl

void qcril_qmi_voice_set_domain_elab_from_call_type
(
  call_type_enum_v02 call_type,
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry
)
{
    if ((CALL_TYPE_VOICE_IP_V02 == call_type ||
         CALL_TYPE_VT_V02 == call_type ||
         CALL_TYPE_EMERGENCY_IP_V02 == call_type ||
         CALL_TYPE_EMERGENCY_VT_V02 == call_type) &&
            isImsRadioConnected())
    {
        QCRIL_LOG_INFO("set the call as a PS call");
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
    }
    else
    {
        QCRIL_LOG_INFO("set the call as a CS call");
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
    }
}

//===========================================================================
// qcril_qmi_voice_auto_answer_if_needed
//===========================================================================
void qcril_qmi_voice_auto_answer_if_needed()
{
  char                                        property_name[ PROPERTY_NAME_MAX ];
  char                                        args[ PROPERTY_VALUE_MAX ];
  int                                         auto_ans_len;
  char                                        *end_ptr;
  long int                                    ret_val = 0;
  uint32                                      auto_answer_timerid;
  int                                         auto_answer_tmr_res;
  struct timeval auto_answer_timeout = { 0 , 0 };

  QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_QMI_AUTO_ANSWER);
  property_get( property_name, args, "" );
  auto_ans_len = strlen( args );
  if ( auto_ans_len > 0 )
  {
    ret_val = strtol( args, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ret_val == LONG_MAX ) )
    {
      QCRIL_LOG_ERROR( "QCRIL QMI VOICE Fail to convert QCRIL_QMI_AUTO_ANSWER %s", args );
    }
    else
    {
      QCRIL_LOG_INFO("QCRIL_QMI_AUTO_ANSWER %d",ret_val);
    }
  }
  if( ret_val > 0 )
  {
    if ( QMI_RIL_ZERO != qmi_voice_voip_overview.auto_answer_timer_id )
    {
      QCRIL_LOG_INFO("Cancel Auto Answer timed callback");
      qcril_cancel_timed_callback( (void*)(uintptr_t) qmi_voice_voip_overview.auto_answer_timer_id );
      qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;
    }
    auto_answer_timerid = QMI_RIL_ZERO;
    auto_answer_timeout.tv_sec = ret_val/1000;
    QCRIL_LOG_INFO("Auto answer timeout %d", (int)auto_answer_timeout.tv_sec);
    auto_answer_tmr_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                  QCRIL_DEFAULT_MODEM_ID,
                                                  qcril_qmi_voice_auto_answer_timeout_handler,
                                                  &auto_answer_timeout,
                                                  &auto_answer_timerid );
    QCRIL_LOG_INFO("Auto answer tmr post res %d, id %d", (int) auto_answer_tmr_res, (int)auto_answer_timerid );
    if ( QMI_RIL_ZERO != auto_answer_timerid )
    {
      qmi_voice_voip_overview.auto_answer_timer_id = auto_answer_timerid;
    }
  }
  else
  {
    QCRIL_LOG_INFO("Auto answer disabled!");
  }
} // qcril_qmi_voice_auto_answer_if_needed

//===========================================================================
// qcril_qmi_voice_is_qmi_call_emergency
//===========================================================================
boolean qcril_qmi_voice_is_qmi_call_emergency(const voice_call_info2_type_v02* iter_call_info)
{
   return (CALL_TYPE_EMERGENCY_V02 == iter_call_info->call_type ||
           CALL_TYPE_EMERGENCY_IP_V02 == iter_call_info->call_type ||
           CALL_TYPE_EMERGENCY_VT_V02 == iter_call_info->call_type);
} // qcril_qmi_voice_is_qmi_call_emergency

//===========================================================================
// qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received
//===========================================================================
void qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received(qcril_qmi_voice_voip_call_info_entry_type *call_info_entry)
{
   if (call_info_entry)
   {
      if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_QMI_ID_RECEIVED)
      {
         call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_QMI_ID_RECEIVED;
         call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;
      }
   }
   else
   {
      QCRIL_LOG_ERROR("call_info_entry is NULL");
   }
} // qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received

//===========================================================================
// qcril_start_diag_log
//===========================================================================
int qcril_start_diag_log(void)
{
    int   rc = 0;
    char  prop_str[PROPERTY_VALUE_MAX]    = {0};
    char  diag_cmd[QCRIL_DIAG_CMD_LENGTH] = {0};

    property_get(QMI_RIL_SYS_PROP_DIAG_LOGGING, prop_str, "");
    if ( !(strncmp(prop_str, "true", QMI_RIL_SYS_PROP_DIAG_LOGGING_LENGTH) == 0))
    {
        return rc;
    }
    else
    {
        qcril_qmi_voice_diag_odl_lock();

        if (diag_odl_logging_in_progress == FALSE)
        {
            diag_odl_logging_in_progress = TRUE;
            qcril_qmi_voice_diag_odl_unlock();
            snprintf(diag_cmd, QCRIL_DIAG_CMD_LENGTH,
                    "%s -p -f %s -m %s -o %s &",
                    QCRIL_DIAG_PATH, QCRIL_DIAG_APQ_MASK_NAME,
                    QCRIL_DIAG_MDM_MASK_NAME,
                    QCRIL_DIAG_LOG_LOCATION);
            rc = system(diag_cmd);
            QCRIL_LOG_INFO("diag logging intialization status %d\n", rc);
            if (rc != 0)
            {
                qcril_qmi_voice_diag_odl_lock();
                diag_odl_logging_in_progress = FALSE;
                qcril_qmi_voice_diag_odl_unlock();
            }
        }
        else
        {
            qcril_qmi_voice_diag_odl_unlock();
            QCRIL_LOG_INFO("diag logging already in progress\n");
        }

        return rc;
    }
}

//===========================================================================
// qcril_stop_diag_log
//===========================================================================
int qcril_stop_diag_log(void)
{
    int rc = 0;
    char diag_cmd[QCRIL_DIAG_CMD_LENGTH] = {0};
    int tmp_qcril_qmi_voice_diag_odl_lock;

    qcril_qmi_voice_diag_odl_lock();
    tmp_qcril_qmi_voice_diag_odl_lock = diag_odl_logging_in_progress;
    qcril_qmi_voice_diag_odl_unlock();

    do {

        if (tmp_qcril_qmi_voice_diag_odl_lock == FALSE)
        {
            break;
        }

        snprintf(diag_cmd, QCRIL_DIAG_CMD_LENGTH,
                "%s -k", QCRIL_DIAG_PATH);
        rc = system(diag_cmd);
        if (rc == 0)
        {
            qcril_qmi_voice_diag_odl_lock();
            diag_odl_logging_in_progress = FALSE;
            qcril_qmi_voice_diag_odl_unlock();
            QCRIL_LOG_INFO("diag logging disabled");
        }

    } while (0);

    return rc;
}

//===========================================================================
// qcril_qmi_voice_create_call_info_from_srvcc_parent_call_info
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_create_call_info_from_srvcc_parent_call_info
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02 *call_status_ind_ptr
)
{
  voice_srvcc_parent_call_id_type_v02 *srvcc_parent_call_info = NULL;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  qcril_qmi_voice_voip_call_info_entry_type *parent_call_info_entry = NULL;
  char  parentCallID[25] = "\0";
  unsigned int j;

  QCRIL_LOG_FUNC_ENTRY();
  if (call_status_ind_ptr)
  {
    // Mid Call SRVCC
    srvcc_parent_call_info = NULL;
    if (call_status_ind_ptr->srvcc_parent_call_info_valid)
    {
      for (j = 0; (j < call_status_ind_ptr->srvcc_parent_call_info_len &&
            j < QMI_VOICE_SRVCC_PARENT_CALL_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind_ptr->srvcc_parent_call_info[j].call_id == call_id)
        {
          srvcc_parent_call_info = &call_status_ind_ptr->srvcc_parent_call_info[j];
          break;
        }
      }
    }
  }

  if ((NULL != srvcc_parent_call_info))
  {
    // This is the case of conference call SRVCC
    // Create call_info_entry with new call_id.
    call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
        srvcc_parent_call_info->call_id,
        INVALID_MEDIA_ID,
        TRUE,
        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID,
        NULL);

    if ((NULL != call_info_entry) && (srvcc_parent_call_info->is_parent_id_cleared == TRUE))
    {
      //Delete the call_info_entry with parent call_id
      parent_call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
          srvcc_parent_call_info->parent_call_id);
      if (parent_call_info_entry)
      {
        memset(&parentCallID, 0, sizeof(parentCallID));
        snprintf(parentCallID, sizeof(parentCallID), QCRIL_PARENT_CALL_ID_STR"%d",
            parent_call_info_entry->android_call_id);
        strlcpy(call_info_entry->parent_call_id, parentCallID,
            sizeof(call_info_entry->parent_call_id));
        parent_call_info_entry->elaboration |=
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_AFTER_SRVCC;
      }
      else
      {
        QCRIL_LOG_INFO( "Call info with parent_call_id doesn't exist... " );
      }
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_create_call_info_from_is_srvcc
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_create_call_info_from_is_srvcc
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02 *call_status_ind_ptr
)
{
  voice_is_srvcc_call_with_id_type_v02 *is_srvcc = NULL;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  unsigned int j;

  QCRIL_LOG_FUNC_ENTRY();

  if (call_status_ind_ptr)
  {
    // SRVCC Call
    is_srvcc = NULL;
    if (call_status_ind_ptr->is_srvcc_valid)
    {
      for (j = 0; (j < call_status_ind_ptr->is_srvcc_len &&
            j < QMI_VOICE_IS_SRVCC_CALL_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind_ptr->is_srvcc[j].call_id == call_id)
        {
          is_srvcc = &call_status_ind_ptr->is_srvcc[j];
          break;
        }
      }
    }
  }

  if (is_srvcc && is_srvcc->is_srvcc_call)
  {
    // fresh creation of call_info_entry in case of SRVCC call from 3rd party
    call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
        is_srvcc->call_id,
        INVALID_MEDIA_ID,
        TRUE,
        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID,
        NULL);
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_get_call_info
//===========================================================================
voice_call_info2_type_v02 *
qcril_qmi_voice_all_call_status_ind_get_call_info
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02 *call_status_ind_ptr
 )
{
  voice_call_info2_type_v02 *call_info = NULL;
  unsigned int j;

  if (call_status_ind_ptr)
  {
    for (j = 0; (j < call_status_ind_ptr->call_info_len &&
          j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
    {
      if (call_status_ind_ptr->call_info[j].call_id == call_id)
      {
        call_info = &call_status_ind_ptr->call_info[j];
        break;
      }
    }
  }
  return call_info;
}

//===========================================================================
// qcril_qmi_voice_notify_unsol_ringback_tone
//===========================================================================
void qcril_qmi_voice_notify_unsol_ringback_tone
(
 uint8_t call_id,
 alerting_type_enum_v02 alerting_type,
 boolean is_ims
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_unsol_resp_params_type unsol_resp;
  int local_ringback_payload = FALSE;
  ims_RingBackTone ring_tone;
  boolean notify_ind = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  if (alerting_type == ALERTING_REMOTE_V02 &&
      !qcril_qmi_voice_info.last_call_is_local_ringback)
  {
    QCRIL_LOG_INFO("Ringback Tone started with QMI id %d", call_id);
    local_ringback_payload = TRUE;
    qcril_qmi_voice_info.last_call_is_local_ringback = TRUE;
    qcril_qmi_voice_info.last_local_ringback_call_id = call_id;
    notify_ind = TRUE;
  }
  else if (qcril_qmi_voice_info.last_call_is_local_ringback &&
      (qcril_qmi_voice_info.last_local_ringback_call_id == call_id) &&
      (alerting_type == ALERTING_LOCAL_V02))
  {
    QCRIL_LOG_INFO("Ringback Tone stopped with QMI id %d", call_id);
    local_ringback_payload = FALSE;
    qcril_qmi_voice_info.last_call_is_local_ringback = FALSE;
    qcril_qmi_voice_info.last_local_ringback_call_id = VOICE_INVALID_CALL_ID;
    notify_ind = TRUE;
  }

  if (notify_ind)
  {
    if (!is_ims)
    {
      qcril_default_unsol_resp_params(instance_id, (int)RIL_UNSOL_RINGBACK_TONE, &unsol_resp);
      unsol_resp.resp_pkt = (void *) &local_ringback_payload;
      unsol_resp.resp_len = sizeof(local_ringback_payload);
      qcril_send_unsol_response(&unsol_resp);
    }
    else
    {
      memset(&ring_tone, 0, sizeof(ring_tone));
      ring_tone.has_flag = TRUE;
      if (local_ringback_payload)
      {
        ring_tone.flag = ims_RingBackTone_ToneFlag_START;
      }
      else
      {
        ring_tone.flag = ims_RingBackTone_ToneFlag_STOP;
      }

      imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE,
          ims_MsgId_UNSOL_RINGBACK_TONE,
          ims_Error_E_SUCCESS,
          (void *)&ring_tone, sizeof(ring_tone));
    }
  }
  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_incoming_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_incoming_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr,
 boolean is_voice_rte_lte
)
{
  int rc = 0;
  uint8_t  ril_call_state_valid;
  RIL_CallState ril_call_state;

  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);

  if (call_status_ind_ptr && call_info)
  {
    rc = qcril_start_diag_log();
    QCRIL_LOG_INFO("MT call: start diag logging : %s\n", (rc == 0 ? "SUCCESS" : "FAILURE"));

    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_INCOMING;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (!call_info_entry)
    {
      // fresh
      call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
          call_id,
          INVALID_MEDIA_ID,
          TRUE,
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING,
          NULL );
    }
    else
    {
      // what we got?
      call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING;
      qcril_qmi_voice_voip_call_info_dump(call_info_entry);
    }

    if (call_info_entry)
    {
      if (CALL_STATE_SETUP_V02 == call_info_entry->voice_scv_info.call_state &&
          call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID)
      {
        qcril_cancel_timed_callback((void *)(uintptr_t) call_info_entry->ringing_time_id);
        call_info_entry->ringing_time_id = QMI_RIL_ZERO;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING;
      }

      if (CALL_TYPE_VOICE_IP_V02 == call_info->call_type ||
          CALL_TYPE_VT_V02 == call_info->call_type)
      {
        imsRadioSendEmptyUnsolResponse(ims_MsgId_UNSOL_CALL_RING);
      }

      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);
      qcril_qmi_voice_consider_shadow_remote_number_cpy_creation(call_info_entry);
      qcril_qmi_voice_set_domain_elab_from_call_type(call_info->call_type, call_info_entry);
      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);

      if (is_voice_rte_lte &&
          (CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type))
      {
        // 1x CSFB MT call
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1x_CSFB_CALL;
      }
      else if (CALL_MODE_NO_SRV_V02 == call_info_entry->voice_scv_info.mode &&
          CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type)
      {
        // 1x or GW CSFB MT call
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1x_CSFB_CALL;
      }

      switch (call_info->call_type)
      {
        case CALL_TYPE_VOICE_V02:
        case CALL_TYPE_VOICE_FORCED_V02:
          if (CALL_MODE_CDMA_V02 == call_info->mode &&
              (!(call_info_entry->elaboration &
                 QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID)))
          {
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;
            qcril_qmi_voice_setup_num_1x_wait_timer();
          }
          break;

        default:
          // nothing
          break;
      }
    }
    // Answer call if auto answer is enabled
    qcril_qmi_voice_auto_answer_if_needed();
  }
  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_alerting_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_alerting_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  uint8_t  ril_call_state_valid;
  RIL_CallState ril_call_state;

  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);

  if (call_status_ind_ptr && call_info)
  {
    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_ALERTING;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (call_info_entry)
    {
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);

      if (CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_IP_V02 == call_info_entry->voice_scv_info.call_type)
      {
#ifndef QMI_RIL_UTF
        if (call_info_entry->voice_scv_info.mode == CALL_MODE_LTE_V02 ||
            call_info_entry->voice_scv_info.mode == CALL_MODE_WLAN_V02)
        {
          qcril_am_set_emergency_rat(call_info_entry->voice_scv_info.mode);
        }
#endif
      }

      if (call_info_entry &&
          ((call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID) &&
           call_info_entry->is_srvcc.is_srvcc_call))
      {
        /* Call domain changes are not expected in normal scenario and even
           if it changes we have to handle them only in conversation state.
           This is due to the limitation in telephony that CS->PS transition
           is not handled. So we need evaluate CS/PS call elaboration only in
           case of SRVCC where call domain is changed intentionally to CS*/
        qcril_qmi_voice_set_ps_cs_call_elab_vcl(call_info, call_info_entry);
      }
      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);
    }

    /* Ringback tone handling */
    if (call_info_entry &&
        (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALERTING_TYPE_VALID))
    {
      qcril_qmi_voice_notify_unsol_ringback_tone(call_id,
          call_info_entry->voice_svc_alerting_type.alerting_type,
          qcril_qmi_voice_call_to_ims(call_info_entry));
    }
  }
  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_conversation_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_conversation_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  uint8_t  ril_call_state_valid;
  RIL_CallState ril_call_state;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_ACTIVE;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);

    if (call_info_entry == NULL)
    {
      call_info_entry = qcril_qmi_voice_create_call_info_from_srvcc_parent_call_info(
          call_id, call_status_ind_ptr);
    }
    if (call_info_entry == NULL)
    {
      call_info_entry = qcril_qmi_voice_create_call_info_from_is_srvcc(
          call_id, call_status_ind_ptr);
    }

    if (call_info_entry)
    {
      if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING)
      {
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;
        qcril_qmi_voice_cancel_num_1x_wait_timer();
      }

      switch (call_info_entry->voice_scv_info.call_state) // check previous state
      {
        case CALL_STATE_ORIGINATING_V02:
        case CALL_STATE_CONVERSATION_V02:
        case CALL_STATE_CC_IN_PROGRESS_V02:
        case CALL_STATE_ALERTING_V02:
          // no action
          break;

        default:
          qmi_ril_voice_drop_homeless_incall_reqs();
          break;
      }

      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);
      call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_GOT_CONNECTED;
      qcril_qmi_voice_set_ps_cs_call_elab_vcl(call_info, call_info_entry);

      if (CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_IP_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_VT_V02 == call_info_entry->voice_scv_info.call_type)
      {
#ifndef QMI_RIL_UTF
        qcril_am_set_emergency_rat(call_info_entry->voice_scv_info.mode);
#endif
      }

      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);

      // Reset the PENDING_INCOMING and ANSWERING_CALL elabs
      call_info_entry->elaboration &= ~(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING |
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL);
    }

    /* Ringback tone handling */
    if (call_info_entry &&
        (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALERTING_TYPE_VALID))
    {
      qcril_qmi_voice_notify_unsol_ringback_tone(call_id,
          call_info_entry->voice_svc_alerting_type.alerting_type,
          qcril_qmi_voice_call_to_ims(call_info_entry));
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_end_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_end_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;
  const struct timeval call_obj_phaseout_auto_delay = {3 , 0}; // 3 seconds
  char end_reason_text[QCRIL_QMI_VOICE_FAIL_CAUSE_STR_LEN] = {0};

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);

    // Cancel auto answer timed callback if previous state is INCOMING
    if (call_info_entry)
    {
      if ((CALL_STATE_INCOMING_V02 == call_info_entry->voice_scv_info.call_state) &&
          (CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type))
      {
        if (QMI_RIL_ZERO != qmi_voice_voip_overview.auto_answer_timer_id)
        {
          QCRIL_LOG_INFO("Cancel Auto Answer timed callback");
          qcril_cancel_timed_callback(
              (void*)(uintptr_t) qmi_voice_voip_overview.auto_answer_timer_id);
          qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;
        }
      }
    }

    if (call_info_entry)
    {
      qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received(call_info_entry);
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          FALSE, (RIL_CallState)0);

      QCRIL_LOG_INFO("call mode %d, call type %d, call got connected %d",
          (int)call_info->mode,
          (int)call_info->call_type,
          (int)(QMI_RIL_ZERO != (call_info_entry->elaboration &
                                 QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_GOT_CONNECTED)));

      if (CALL_TYPE_EMERGENCY_V02 == call_info->call_type ||
          CALL_TYPE_EMERGENCY_IP_V02 == call_info->call_type ||
          CALL_TYPE_EMERGENCY_VT_V02 == call_info->call_type)
      {
        qcril_nas_emer_call_end_hndlr_params eme_call_end_hdlr_param;
        eme_call_end_hdlr_param.is_eme_ip_call =
          (CALL_TYPE_EMERGENCY_IP_V02 == call_info->call_type ||
           CALL_TYPE_EMERGENCY_VT_V02 == call_info->call_type);

        eme_call_end_hdlr_param.is_eme_call_connected =
          call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_GOT_CONNECTED;

        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            QCRIL_DATA_ON_STACK,
            QCRIL_EVT_QMI_RIL_CONNECTED_EMEGENCY_CALL_END,
            &eme_call_end_hdlr_param,
            sizeof(eme_call_end_hdlr_param),
            (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
#ifndef QMI_RIL_UTF
        qcril_am_reset_emergency_rat();
#endif
      }

      if (!qcril_qmi_voice_call_to_ims(call_info_entry))
      {
        (void)qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            qmi_ril_voice_ended_call_obj_phase_out,
            &call_obj_phaseout_auto_delay,
            &call_info_entry->call_obj_phase_out_timer_id);
      }
    }

    // Ringback tone handling
    if (call_info_entry &&
        (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALERTING_TYPE_VALID))
    {
      qcril_qmi_voice_notify_unsol_ringback_tone(call_id,
          call_info_entry->voice_svc_alerting_type.alerting_type,
          qcril_qmi_voice_call_to_ims(call_info_entry));
    }

    if (qcril_qmi_voice_voip_call_info_is_single_elaboration_set(call_info_entry,
          QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_ALTERNATE_EMERGENCY_CALL))
    {
      // Reset alternative emergency call info and clear the ril.ecclist if required
      qmi_ril_reset_alternate_emergency_call_info();
    }

    // Last call failure cause
    if (call_status_ind_ptr->call_end_reason_valid)
    {
      QCRIL_LOG_INFO("call failure cause %d",
          call_status_ind_ptr->call_end_reason[0].call_end_reason);

      if (call_status_ind_ptr->call_end_reason[0].call_end_reason ==
          CALL_END_CAUSE_ALTERNATE_EMERGENCY_CALL_V02)
      {
        char *number = NULL;
        uint32_t emer_cat = 0;
        if (qcril_qmi_voice_voip_call_info_is_single_elaboration_set(call_info_entry,
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID))
        {
          number = call_info_entry->voice_svc_remote_party_number.number;
        }
        if (call_status_ind_ptr->emerg_srv_categ_valid)
        {
          unsigned n_calls = call_status_ind_ptr->emerg_srv_categ_len;
          for (unsigned j = 0; (j < n_calls && j < QMI_VOICE_EMERG_SRV_CATEG_ARRAY_MAX_V02); j++)
          {
            if (call_status_ind_ptr->emerg_srv_categ[j].call_id == call_id)
            {
              emer_cat = call_status_ind_ptr->emerg_srv_categ[j].emerg_srv_categ;
              break;
            }
          }
        }
        qmi_ril_set_alternate_emergency_call_info(number, emer_cat);
      }
      if (call_status_ind_ptr->raw_call_end_cause_code_valid)
      {
        QCRIL_LOG_INFO("raw call end cause code: %d",
            call_status_ind_ptr->raw_call_end_cause_code[0].raw_call_end_cause_code);
      }
      if (call_status_ind_ptr->sip_error_code_valid)
      {
        QCRIL_LOG_INFO("sip error code: %d",
            call_status_ind_ptr->sip_error_code[0].sip_error_code);
      }
      if (call_status_ind_ptr->end_reason_text_valid)
      {
        qcril_cm_ss_convert_ucs2_to_utf8(
            (char *)call_status_ind_ptr->end_reason_text[0].end_reason_text,
            call_status_ind_ptr->end_reason_text[0].end_reason_text_len*2,
            end_reason_text,
            sizeof(end_reason_text));
      }
      qcril_qmi_voice_handle_new_last_call_failure_cause(
          call_status_ind_ptr->call_end_reason[0].call_end_reason,
          TRUE, call_status_ind_ptr->raw_call_end_cause_code_valid,
          call_status_ind_ptr->raw_call_end_cause_code[0].raw_call_end_cause_code,
          call_status_ind_ptr->sip_error_code_valid,
          call_status_ind_ptr->sip_error_code[0].sip_error_code,
          call_status_ind_ptr->end_reason_text_valid,
          end_reason_text,
          call_info_entry);
    }
    qcril_qmi_voice_respond_pending_hangup_ril_response(call_id);

    if (call_info_entry)
    {
      // qmi call id will no longer be valid for this call object
      call_info_entry->qmi_call_id = VOICE_INVALID_CALL_ID;
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_originating_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_originating_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr,
 boolean is_voice_rte_lte
)
{
  uint8_t ril_call_state_valid = FALSE;
  RIL_CallState ril_call_state = RIL_CALL_ACTIVE; // 0
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_DIALING;

    // update call info entry
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (!call_info_entry)
    {
      // ghost call
      call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
          call_id,
          INVALID_MEDIA_ID,
          TRUE,
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE,
          NULL );
      if (call_info_entry)
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PHANTOM_CALL;

        if ((CALL_MODE_LTE_V02 == call_info->mode ||
              CALL_TYPE_VOICE_IP_V02 == call_info->call_type ||
              CALL_TYPE_VT_V02 == call_info->call_type ||
              CALL_TYPE_EMERGENCY_IP_V02 == call_info->call_type ||
              CALL_TYPE_EMERGENCY_VT_V02 == call_info->call_type) &&
            isImsRadioConnected())
        {
          //Even though call mode is LTE, there may be a chance call gets connected on
          //CS domain. So better to declare elab as AUTO to handle transition scenario.
          QCRIL_LOG_INFO("Set call domain as AUTO");
          call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
          call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        }
        else
        {
          QCRIL_LOG_INFO("set the call as a CS call");
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
          call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
          call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        }
      }
    }
    else
    {
      qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received(call_info_entry);
    }

    if (call_info_entry)
    {
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);
      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);
      qcril_qmi_voice_consider_shadow_remote_number_cpy_creation(call_info_entry);

      // related eme from non oos or 1xcsfb
      if (CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_IP_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_VT_V02 == call_info_entry->voice_scv_info.call_type)
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMERGENCY_CALL;
        if (!(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING))
        {
          // related emergency call from non oos
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
        }
#ifndef QMI_RIL_UTF
        qcril_am_set_emergency_rat(call_info_entry->voice_scv_info.mode);
#endif
      }
      else
      {
        // non emergency
        if (is_voice_rte_lte &&
            (CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type))
        {
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1x_CSFB_CALL;
          if (!(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING))
          {
            // 1x CSFB call
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
          }
        }
        else if ((CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type ||
              CALL_TYPE_STD_OTASP_V02 == call_info_entry->voice_scv_info.call_type ||
              CALL_TYPE_NON_STD_OTASP_V02 == call_info_entry->voice_scv_info.call_type) &&
            (CALL_MODE_NO_SRV_V02 == call_info_entry->voice_scv_info.mode))
        {
          // call type is voice or OTASP, but call mode is not yet known -> we may not identify
          // if calls' RAT matches to current voice RAT, and that will hide call from UI
          // mark call as "DIAL_FROM_OOS" to reveal the call info to UI
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_DIAL_FROM_OOS;
          if (!(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING))
          {
            // also set extended dialing flag, this enabling RIL reports DIALING state
            // at least once, that way ensuring call info is rendered if we change RAT
            // during call setup
            // call originated from unknown RAT
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
          }
        }
      }
    }
    if (qcril_qmi_voice_is_stk_cc_in_progress() && stk_cc_info.call_id_info == call_info->call_id)
    {
      // stk cc for this call
      qcril_qmi_voice_stk_cc_relay_alpha_if_necessary(instance_id, FALSE);
      qcril_qmi_voice_reset_stk_cc();
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_disconnecting_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_disconnecting_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (call_info_entry)
    {
      qcril_qmi_voice_voip_change_call_elab_when_first_call_ind_received(call_info_entry);
      switch (call_info_entry->voice_scv_info.call_state) // check previous state
      {
        case CALL_STATE_ORIGINATING_V02:
        case CALL_STATE_CONVERSATION_V02:
        case CALL_STATE_CC_IN_PROGRESS_V02:
        case CALL_STATE_ALERTING_V02:
          qmi_ril_voice_drop_homeless_incall_reqs();
          break;

        case CALL_STATE_INCOMING_V02:
          if ((CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type) &&
              (QMI_RIL_ZERO != qmi_voice_voip_overview.auto_answer_timer_id))
          {
            QCRIL_LOG_INFO("Cancel Auto Answer timed callback");
            qcril_cancel_timed_callback(
                (void*)(uintptr_t)qmi_voice_voip_overview.auto_answer_timer_id);
            qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;
          }
          break;

        default:
          // no action
          break;
      }
      if (CALL_STATE_SETUP_V02 == call_info_entry->voice_scv_info.call_state &&
          call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID)
      {
        qcril_cancel_timed_callback((void *)(uintptr_t)call_info_entry->ringing_time_id);
        call_info_entry->ringing_time_id = QMI_RIL_ZERO;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID;
      }
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          FALSE, (RIL_CallState)0);
    }
    qcril_qmi_voice_invalid_last_call_failure_cause();
    /* Ringback tone handling */
    if (call_info_entry &&
        (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALERTING_TYPE_VALID))
    {
      qcril_qmi_voice_notify_unsol_ringback_tone(call_id,
          call_info_entry->voice_svc_alerting_type.alerting_type,
          qcril_qmi_voice_call_to_ims(call_info_entry));
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_waiting_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_waiting_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  uint8_t ril_call_state_valid = FALSE;
  RIL_CallState ril_call_state = RIL_CALL_ACTIVE; // 0
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;
  int rc = 0;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_WAITING;

    rc = qcril_start_diag_log();
    QCRIL_LOG_INFO("MT call: start diag logging : %s\n", (rc == 0 ? "SUCCESS" : "FAILURE"));

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (!call_info_entry)
    {
      // fresh
      call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
          call_id,
          INVALID_MEDIA_ID,
          TRUE,
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING,
          NULL );
    }
    else
    {
      call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING;
      qcril_qmi_voice_voip_call_info_dump(call_info_entry);
    }
    if (call_info_entry)
    {
      if (CALL_STATE_SETUP_V02 == call_info_entry->voice_scv_info.call_state &&
          call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID)
      {
        qcril_cancel_timed_callback((void *)(uintptr_t)call_info_entry->ringing_time_id);
        call_info_entry->ringing_time_id = QMI_RIL_ZERO;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_RINING_TIME_ID_VALID;
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING;
      }

      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);
      qcril_qmi_voice_consider_shadow_remote_number_cpy_creation(call_info_entry);
      qcril_qmi_voice_set_ps_cs_call_elab_vcl(call_info, call_info_entry);
      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);
    }
    qcril_event_queue(QCRIL_DEFAULT_INSTANCE_ID,
        QCRIL_DEFAULT_MODEM_ID,
        QCRIL_DATA_ON_STACK,
        QCRIL_EVT_QMI_VOICE_GET_WAITING_CALL,
        &(call_info->call_id),
        sizeof(call_info->call_id),
        (RIL_Token) QCRIL_TOKEN_ID_INTERNAL);
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_hold_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_hold_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  uint8_t ril_call_state_valid = FALSE;
  RIL_CallState ril_call_state = RIL_CALL_ACTIVE; // 0
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    ril_call_state_valid = TRUE;
    ril_call_state = RIL_CALL_HOLDING;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id );
    if (call_info_entry == NULL)
    {
      call_info_entry = qcril_qmi_voice_create_call_info_from_srvcc_parent_call_info(
          call_id, call_status_ind_ptr);
    }
    if (call_info_entry)
    {
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);
      qcril_qmi_voice_set_ps_cs_call_elab_vcl(call_info, call_info_entry);
      qcril_qmi_voice_set_audio_call_type(call_info, call_info_entry);
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_cc_in_progress_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_cc_in_progress_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP, TRUE);
    if (call_info_entry)
    {
      call_info_entry->qmi_call_id = call_id;
    }
    else
    {
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    }
    if (call_info_entry)
    {
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          FALSE, (RIL_CallState)0);
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

//===========================================================================
// qcril_qmi_voice_all_call_status_ind_setup_hdlr
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type *
qcril_qmi_voice_all_call_status_ind_setup_hdlr
(
 uint8_t call_id,
 voice_all_call_status_ind_msg_v02* call_status_ind_ptr
)
{
  uint8_t ril_call_state_valid = FALSE;
  RIL_CallState ril_call_state = RIL_CALL_ACTIVE; // 0
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  voice_call_info2_type_v02 *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  call_info = qcril_qmi_voice_all_call_status_ind_get_call_info(call_id, call_status_ind_ptr);
  if (call_status_ind_ptr && call_info)
  {
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(call_id);
    if (!call_info_entry)
    {
      // fresh
      call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
          call_id,
          INVALID_MEDIA_ID,
          TRUE,
          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE,
          NULL);
    }
    else
    {
      // what we got?
      qcril_qmi_voice_voip_call_info_dump(call_info_entry);
    }
    if (call_info_entry)
    {
      qcril_qmi_voice_set_domain_elab_from_call_type(call_info->call_type, call_info_entry);
      qcril_qmi_voice_voip_update_call_info_entry_mainstream(call_info_entry, call_status_ind_ptr,
          ril_call_state_valid, ril_call_state);

      if (!(call_info_entry->elaboration &
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING))
      {
        // got to initiate ringing
        call_info_entry->elaboration |=
          (QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING |
           QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_RING_DONE);
        QCRIL_LOG_INFO( "launch ringer" );
        qcril_setup_timed_callback_ex_params(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            qcril_qmi_voice_make_incoming_call_ring,
            NULL,   // no param
            NULL,   // immediate
            NULL);
      }
    }
  }

  QCRIL_LOG_FUNC_RETURN();
  return call_info_entry;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_all_call_status_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_ALL_CALL_STATUS_IND_V02.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_all_call_status_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_all_call_status_ind_msg_v02* call_status_ind_ptr = NULL;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  unsigned int i;
  uint32_t nof_ims_calls = 0;
  uint32_t nof_atel_calls = 0;
  boolean  hangup_call = FALSE;
  QCRIL_NOTUSED(ind_data_len);

  /* variables defined to track modem initiated silent redial */
  boolean is_request_on_autodomain = FALSE;
  boolean is_call_on_cs_domain     = FALSE;
  boolean is_silent_redialed       = FALSE;

  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  voice_call_info2_type_v02*                  iter_call_info = NULL;
  int                                         calls_nof_remaining;
  int                                         calls_iter;
  int                                         is_deviant_call;
  int                                         is_mode_resonable;

  int                                         imperative_report;
  int                                         post_call_cleanup_may_be_necessary;

  qmi_ril_nw_reg_rte_type                     current_voice_rte;
  int                                         reported_voice_radio_tech;

  qcril_qmi_voice_voip_call_info_entry_type * cdma_voice_call_info_entry = NULL;

  qcril_qmi_voice_voip_current_call_summary_type
                                              calls_summary_beginning;
  qcril_qmi_voice_voip_current_call_summary_type
                                              calls_summary_end;

  char                                        log_essence[ QCRIL_MAX_LOG_MSG_SIZE ];
  char                                        log_addon[ QCRIL_MAX_LOG_MSG_SIZE ];

  int rc = 0;

  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type oversight_event_params;

  uint8_t is_alerting_data_snapshot = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  memset( &calls_summary_beginning, 0, sizeof( calls_summary_beginning ) );
  memset( &calls_summary_end, 0, sizeof( calls_summary_end ) );

  snprintf( log_essence, QCRIL_MAX_LOG_MSG_SIZE,
            "RILVIMS: update" );

  if( ind_data_ptr != NULL )
  {
      call_status_ind_ptr = (voice_all_call_status_ind_msg_v02*)ind_data_ptr;

      post_call_cleanup_may_be_necessary = FALSE;

      snprintf( log_addon, QCRIL_MAX_LOG_MSG_SIZE,
                " %d calls", call_status_ind_ptr->call_info_len );
      strlcat( log_essence, log_addon, sizeof( log_essence ) );

#ifndef USING_NAS_PUBLIC_API
      current_voice_rte           = qmi_ril_nw_reg_get_current_rte_of_kind( QMI_RIL_RTE_KIND_VOICE );
      reported_voice_radio_tech   = qcril_qmi_nas_get_reported_voice_radio_tech();
#else
      if (qcril_qmi_voice_nas_reported_info.voice_rte_valid)
        current_voice_rte = qcril_qmi_voice_nas_reported_info.voice_rte;
      else
        current_voice_rte = QMI_RIL_RTE_NONE;

      if (qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid)
        reported_voice_radio_tech = qcril_qmi_voice_nas_reported_info.voice_radio_tech;
      else
        reported_voice_radio_tech = RADIO_TECH_UNKNOWN;
#endif

      cdma_voice_call_info_entry = NULL;

      qcril_qmi_voice_voip_lock_overview();

      qcril_qmi_voice_voip_generate_summary( &calls_summary_beginning );

      for (i = 0; (i < call_status_ind_ptr->call_info_len && i < QMI_VOICE_CALL_INFO_MAX_V02); i++)
      {
        // call info
        iter_call_info = &call_status_ind_ptr->call_info[i];
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
            iter_call_info->call_id);
        if (call_info_entry)
        {
          snprintf(log_addon, QCRIL_MAX_LOG_MSG_SIZE,
                    "[a-c-id: %d, q-c-id %d, c-s %d -> %d, c-t: %d / %d, c-m: %d / %d]",
                        (int)call_info_entry->android_call_id,
                        (int)iter_call_info->call_id,
                        (int)call_info_entry->voice_scv_info.call_state,
                        (int)iter_call_info->call_state,
                        (int)call_info_entry->voice_scv_info.call_type,
                        (int)iter_call_info->call_type,
                        (int)call_info_entry->voice_scv_info.mode,
                        (int)iter_call_info->mode);
        }
        else
        {
          snprintf(log_addon, QCRIL_MAX_LOG_MSG_SIZE,
              "[uncached q-c-id: %d, c-s: %d, c-t: %d, c-m: %d]",
              (int)iter_call_info->call_id,
              (int)iter_call_info->call_state,
              (int)iter_call_info->call_type,
              (int)iter_call_info->mode);
        }
        strlcat(log_essence, log_addon, sizeof(log_essence));

        call_info_entry = NULL;

        switch (iter_call_info->call_state)
        {
          case CALL_STATE_INCOMING_V02:
            QCRIL_LOG_ESSENTIAL("call state INCOMING for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_incoming_hdlr(
                iter_call_info->call_id, call_status_ind_ptr,
                (QMI_RIL_RTE_SUB_LTE == current_voice_rte ||
                 RADIO_TECH_LTE == reported_voice_radio_tech));
            break; // end of case CALL_STATE_INCOMING_V02

          case CALL_STATE_ALERTING_V02:
            QCRIL_LOG_ESSENTIAL("call state ALERTING for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_alerting_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);
            if (call_info_entry &&
                (!((call_info_entry->elaboration &
                    QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID) &&
                   call_info_entry->is_srvcc.is_srvcc_call) &&
                 ((CALL_MODE_LTE_V02 != call_info_entry->voice_scv_info.mode) ||
                  (CALL_MODE_WLAN_V02 != call_info_entry->voice_scv_info.mode) ||
                  (CALL_MODE_NO_SRV_V02 != call_info_entry->voice_scv_info.mode) ||
                  (CALL_MODE_UNKNOWN_V02 != call_info_entry->voice_scv_info.mode))))
            {
              is_alerting_data_snapshot = TRUE;
            }
            break; // end of case CALL_STATE_ALERTING_V02

          case CALL_STATE_CONVERSATION_V02:
            QCRIL_LOG_ESSENTIAL("call state CONVERSATION for conn id %d", iter_call_info->call_id);

            call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
                iter_call_info->call_id);
            if (call_info_entry)
            {
              // set the domain flag before ELA is reset by call_type
              is_request_on_autodomain = (call_info_entry->elaboration &
                  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN) ? TRUE : FALSE;
            }

            call_info_entry = qcril_qmi_voice_all_call_status_ind_conversation_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);

            if (call_info_entry)
            {
              // set the calltype flag after ELA is reset by call_type
              is_call_on_cs_domain = (call_info_entry->elaboration &
                  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN) ? TRUE : FALSE;
            }
            is_silent_redialed = is_request_on_autodomain && is_call_on_cs_domain;
            QCRIL_LOG_INFO("is_request_on_autodomain:%d is_call_on_cs_domain:%d is_silent_redialed:%d",
                is_request_on_autodomain, is_call_on_cs_domain, is_silent_redialed);
            break; // end of case CALL_STATE_CONVERSATION_V02

          case CALL_STATE_END_V02:
            QCRIL_LOG_ESSENTIAL("call state END for conn id %d", iter_call_info->call_id);
            post_call_cleanup_may_be_necessary = TRUE;
            call_info_entry = qcril_qmi_voice_all_call_status_ind_end_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);
            break; // end of case CALL_STATE_END_V02

          case CALL_STATE_ORIGINATING_V02:
            QCRIL_LOG_ESSENTIAL("call state ORIGINATING for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_originating_hdlr(
                iter_call_info->call_id, call_status_ind_ptr,
                (QMI_RIL_RTE_SUB_LTE == current_voice_rte ||
                 RADIO_TECH_LTE == reported_voice_radio_tech));
            break; // end of case CALL_STATE_ORIGINATING_V02

          case CALL_STATE_DISCONNECTING_V02:
            QCRIL_LOG_ESSENTIAL("call state DISCONNECTING for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_disconnecting_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);
            break; // end of case CALL_STATE_DISCONNECTING_V02

          case CALL_STATE_WAITING_V02:
            QCRIL_LOG_ESSENTIAL("call state WAITING for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_waiting_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);
            break; // end of case CALL_STATE_WAITING_V02

          case CALL_STATE_HOLD_V02:
            QCRIL_LOG_ESSENTIAL("call state HOLD for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_hold_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);
            break; // end of case CALL_STATE_HOLD_V02

          case CALL_STATE_CC_IN_PROGRESS_V02:
            QCRIL_LOG_ESSENTIAL("call state CC IN PROGRESS for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_cc_in_progress_hdlr(
                iter_call_info->call_id, call_status_ind_ptr);

            if (call_info_entry &&
                (call_info_entry->elaboration &
                 QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_HANGUP_AFTER_VALID_QMI_ID))
            {
              call_info_entry->elaboration &=
                (~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_HANGUP_AFTER_VALID_QMI_ID);
              hangup_call = TRUE;
              QCRIL_LOG_INFO("Call needs to be hung up");
            }
            break; // end of case CALL_STATE_CC_IN_PROGRESS_V02

          case CALL_STATE_SETUP_V02:
            QCRIL_LOG_ESSENTIAL("call state SETUP for conn id %d", iter_call_info->call_id);
            call_info_entry = qcril_qmi_voice_all_call_status_ind_setup_hdlr(
                iter_call_info->call_id,
                call_status_ind_ptr);
            break; // end of case CALL_STATE_SETUP_V02

          default:
            QCRIL_LOG_ESSENTIAL("unexpected call state(%d)  for conn id %d",
                iter_call_info->call_state, iter_call_info->call_id);
            call_info_entry = NULL;
            break;
        } // switch ( iter_call_info->call_state )

        // eme oos - extended dialing
        if ( NULL != call_info_entry )
        {
          switch ( iter_call_info->call_state )
          {
            case CALL_STATE_CONVERSATION_V02: // fallthrough
            case CALL_STATE_DISCONNECTING_V02:
            case CALL_STATE_ALERTING_V02:
            case CALL_STATE_END_V02:
              if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING &&
                   !( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING_ENDING ) )
              {
                call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING_ENDING;
                call_info_entry->elaboration &= ~( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING_ENDING | QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING );
              }
              break;

            default:
              // nothing
              break;
          }
        }
        //Evaluating calls that need to be skipped for now
        if (iter_call_info->call_state == CALL_STATE_CC_IN_PROGRESS_V02 ||
                (iter_call_info->call_type == CALL_TYPE_VOICE_IP_V02 ||
                 iter_call_info->call_type == CALL_TYPE_VT_V02 ||
                 iter_call_info->call_type == CALL_TYPE_EMERGENCY_IP_V02 ||
                 iter_call_info->call_type == CALL_TYPE_EMERGENCY_VT_V02))
        {
           is_deviant_call = FALSE;
        }
        else
        {
           is_deviant_call = qcril_qmi_voice_nas_control_is_call_mode_reported_voice_radio_tech_different( iter_call_info->mode );
        }
        QCRIL_LOG_INFO(".. is deviant call pre %d ", (int) is_deviant_call );
        if ( is_deviant_call )
        {
          switch ( iter_call_info->call_state )
          {
            case CALL_STATE_ORIGINATING_V02:
            case CALL_STATE_INCOMING_V02:
            case CALL_STATE_CC_IN_PROGRESS_V02:
            case CALL_STATE_SETUP_V02:
              // keep is_deviant_call as is
              break;

            default: // do not allow hiding call for post connecetd call states
              is_deviant_call = FALSE;
              break;
          }
        }
        is_mode_resonable = qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg( iter_call_info->mode );
        QCRIL_LOG_INFO(".. is deviant call final %d, is mode reasonable %d", (int) is_deviant_call, (int)is_mode_resonable );


        if ( call_info_entry )
        {
          if ( call_info_entry->elaboration &
               (QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EME_FROM_OOS |
                QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMERGENCY_CALL |
                QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1x_CSFB_CALL |
                QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_DIAL_FROM_OOS) )
          {
            imperative_report = TRUE;
          }
          else
          {
            imperative_report = FALSE;
          }
        }
        else
        {
          imperative_report = FALSE;
        }
        QCRIL_LOG_INFO(".. imperative report %d ", (int) imperative_report );

        if ( !( CALL_STATE_SETUP_V02 == iter_call_info->call_state ||
                CALL_STATE_DISCONNECTING_V02 == iter_call_info->call_state ||
                ( is_deviant_call && !imperative_report && is_mode_resonable )
              )
           )
        {  // need to report the given call at this time
           if ( qcril_qmi_voice_call_to_ims(call_info_entry) )
           {
             nof_ims_calls++;
           }

           if ( qcril_qmi_voice_call_to_atel(call_info_entry) )
           {
             nof_atel_calls++;
           }
        }

        if ( call_info_entry )
        {
          if ( is_deviant_call && is_mode_resonable && !imperative_report )
          {
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE;
            QCRIL_LOG_INFO("skipping call with android call id %d / qmi call id %d as call mode does not match with the current voice radio tech",
                           call_info_entry->android_call_id,
                           call_info_entry->qmi_call_id );
          }
          else
          {
            if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE )
            { // "shadowing" no longer needed
              call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE;
            }
          }
        }

        // oversight update -- start
        memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
        oversight_event_params.new_call_state      = iter_call_info->call_state;
        oversight_event_params.locator.qmi_call_id = iter_call_info->call_id;
        (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_IND, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID, &oversight_event_params );

        if ( NULL != call_info_entry )
        {
          if ( VOICE_INVALID_CALL_ID != call_info_entry->android_call_id )
          {
            memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
            oversight_event_params.new_call_state             = iter_call_info->call_state;
            oversight_event_params.locator.android_call_id    = call_info_entry->android_call_id;
            (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_IND, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID, &oversight_event_params );
          }

          memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
          oversight_event_params.new_call_state               = iter_call_info->call_state;
          oversight_event_params.locator.elaboration_pattern  = call_info_entry->elaboration;
          (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_IND, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN, &oversight_event_params );
        }

        if ( CALL_STATE_END_V02 == iter_call_info->call_state )
        {
          memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
          oversight_event_params.locator.qmi_call_id = iter_call_info->call_id;
          (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_CALL_ENDED, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID, &oversight_event_params );

          if ( NULL != call_info_entry )
          {
            if ( VOICE_INVALID_CALL_ID != call_info_entry->android_call_id )
            {
              memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
              oversight_event_params.locator.android_call_id   = call_info_entry->android_call_id;
              (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_CALL_ENDED, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID, &oversight_event_params );
            }

            memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
            oversight_event_params.locator.elaboration_pattern  = call_info_entry->elaboration;
            (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_CALL_ENDED, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN, &oversight_event_params );
          }
        }
        // oversight update -- end
      } // for ( i = 0; i < call_status_ind_ptr->call_info_len; i++ )

      //Destroy the call info objects for the calls ended as part of srvcc
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_AFTER_SRVCC, TRUE );
      if ( NULL != call_info_entry )
      {
        qcril_qmi_voice_voip_destroy_call_info_entry( call_info_entry );
      }

      // dump call objs to log
      calls_nof_remaining = 0;
      calls_iter          = 0;
      QCRIL_LOG_INFO( "-- final call dump start --" );
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
      while ( NULL != call_info_entry )
      {
        calls_nof_remaining++;
        call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
      }
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
      while ( NULL != call_info_entry )
      {
        calls_iter++;
        QCRIL_LOG_INFO( "- dumping call %d out of %d", calls_iter, calls_nof_remaining );
        qcril_qmi_voice_voip_call_info_dump( call_info_entry );
        call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
      }
      QCRIL_LOG_INFO( "-- final call dump end --" );

      if( TRUE == qcril_qmi_voice_is_cdma_voice_emergency_calls_present(&cdma_voice_call_info_entry, NULL) )
      {
        if( NULL != cdma_voice_call_info_entry )
        {
          cdma_voice_call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_REPORT_CACHED_RP_NUMBER;
        }
        QCRIL_LOG_INFO( "flagged cached RP num %p", cdma_voice_call_info_entry );
      }

      qcril_qmi_voice_voip_generate_summary( &calls_summary_end );
      if (qmi_ril_voice_is_audio_inactive_vcl())
      {
         qcril_qmi_voice_hangup_all_non_emergency_calls_vcl();
      }

      if(has_wps_pending_dial && calls_summary_end.nof_voip_calls == QMI_RIL_ZERO)
      {
        qcril_qmi_voice_send_wps_dial_request();
        has_wps_pending_dial = FALSE;
      }

      qcril_qmi_voice_voip_unlock_overview();

      // post cleanup
      if (post_call_cleanup_may_be_necessary &&
          calls_summary_end.nof_calls_overall == QMI_RIL_ZERO)
      {
        qmi_ril_succeed_on_pending_hangup_req_on_no_calls_left();
        qmi_ril_voice_cleanup_reqs_after_call_completion();
      }

      if (nof_atel_calls)
      {
        // send SRVCC ind to RILD if IMS dial request if silent redialed
        if (is_silent_redialed)
        {
          QCRIL_LOG_ERROR("modem silent redialed, sending SRVCC IND");
          // send HANDOVER STARTED and COMPLETED
          qcril_qmi_voice_send_simulated_SRVCC_ind();
        }
        qcril_qmi_voice_send_unsol_call_state_changed( instance_id );
      }

      if (nof_ims_calls)
      {
        qcril_qmi_voice_send_ims_unsol_call_state_changed();
      }


      if ( calls_summary_end.nof_voice_calls != calls_summary_beginning.nof_voice_calls )
      {
#ifndef USING_NAS_PUBLIC_API
        qcril_qmi_nas_initiate_voice_rte_change_propagation();
#else
        auto msg = std::make_shared<InitiateVoiceRteChangePropagationMessage>();
        if (msg != nullptr)
          Dispatcher::getInstance().dispatch(msg);
        else
          QCRIL_LOG_ERROR("nullptr when create InitiateVoiceRteChangePropagationMessage");
#endif
      }

      if (hangup_call)
      {
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
                                            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP,
                                            TRUE );
        if (call_info_entry)
        {
            qcril_qmi_voice_send_hangup_on_call(call_info_entry->android_call_id);
        }
      }

#ifndef QMI_RIL_UTF
      qcril_am_handle_event(QCRIL_AM_EVENT_CALL_STATE_CHANGED, NULL);
#endif
  }


  // Register or deregister for the qmi voice indicatons.
  boolean enable_ind = qcril_qmi_voice_has_specific_call(qcril_qmi_voice_is_active_ims_call, NULL);
  if (enable_ind || qcril_qmi_ril_domestic_service_is_screen_off())
  {
      qcril_qmi_voice_enable_voice_indications(enable_ind);
  }

  if (qcril_qmi_voice_voip_call_info_entries_is_empty())
  {
      QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
      rc = qcril_stop_diag_log();
      if (rc == 0)
      {
          QCRIL_LOG_INFO("qxdm logging disabled successfully");
      }
  }

  if (calls_summary_end.nof_calls_overall == QMI_RIL_ZERO)
  {
      hangup_retry_attempted = FALSE;
  }

#ifndef USING_NAS_PUBLIC_API
  if(is_alerting_data_snapshot)
  {
    qcril_qmi_nas_invalidate_data_snapshot_in_case_of_csfb_in_alerting_state();
  }
  else
  {
    qcril_qmi_nas_wave_data_reg_in_case_of_csfb(TRUE);
  }
#else
  auto msg = std::make_shared<CsfbCallInProgressMessage>();
  if (msg != nullptr) {
    msg->setIsAlerting(is_alerting_data_snapshot);
    Dispatcher::getInstance().dispatch(msg);
  } else {
    QCRIL_LOG_ERROR("nullptr when create CsfbCallInProgressMessage");
  }
#endif

  QCRIL_LOG_ESSENTIAL ( "%s", log_essence );

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_all_call_status_ind_hdlr

//===========================================================================
// qcril_qmi_voice_is_cdma_voice_emergency_calls_present
//
//
// Passes back the pointer to the voice call info entry
// returns TRUE if a emergency call has been dialled on top of a cdma voice call
//===========================================================================
int qcril_qmi_voice_is_cdma_voice_emergency_calls_present(qcril_qmi_voice_voip_call_info_entry_type **cdma_voice_call_info_entry,
                                                                 qcril_qmi_voice_voip_call_info_entry_type **cdma_no_srv_emer_call_info_entry)
{
  int ret;
  int nof_calls;
  int nof_1x_voice_calls;
  int nof_1x_no_srv_emergency_calls;
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  ret = FALSE;
  nof_calls = QMI_RIL_ZERO;
  nof_1x_voice_calls = QMI_RIL_ZERO;
  nof_1x_no_srv_emergency_calls = QMI_RIL_ZERO;
  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();

  while ( NULL != call_info_entry )
  {
    if ( call_info_entry->android_call_id != VOICE_INVALID_CALL_ID &&
         call_info_entry->voice_scv_info.call_state != CALL_STATE_END_V02 )
    {
      nof_calls++;
      if ( ( CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type ||
             ( CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type &&
               (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_REPORT_CACHED_RP_NUMBER) ) ) &&
           CALL_MODE_CDMA_V02 == call_info_entry->voice_scv_info.mode )
      {
        nof_1x_voice_calls++;
        if( cdma_voice_call_info_entry )
        {
          *cdma_voice_call_info_entry = call_info_entry;
        }
      }
      else if ( CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type &&
                ( CALL_MODE_CDMA_V02 == call_info_entry->voice_scv_info.mode ||
                  CALL_MODE_NO_SRV_V02 == call_info_entry->voice_scv_info.mode ) )
      {
        nof_1x_no_srv_emergency_calls++;
        if( cdma_no_srv_emer_call_info_entry )
        {
          *cdma_no_srv_emer_call_info_entry = call_info_entry;
        }
      }
    }
    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  QCRIL_LOG_INFO( "nof calls %d, nof cdma voice calls %d, nof 1x/no_srv emergency calls %d", nof_calls, nof_1x_voice_calls, nof_1x_no_srv_emergency_calls );

  if ( 2 == nof_calls &&
       1 == nof_1x_voice_calls &&
       1 == nof_1x_no_srv_emergency_calls )
  {
    ret= TRUE;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_voice_is_cdma_voice_emergency_calls_present

//===========================================================================
// qmi_ril_voice_ended_call_obj_phaseout
//===========================================================================
void qmi_ril_voice_ended_call_obj_phase_out(void * param)
{
    qcril_qmi_voice_voip_call_info_entry_type* call_info = NULL;
    uint32                                     timer_id;

    QCRIL_LOG_FUNC_ENTRY();

    timer_id = ( uint32 )(uintptr_t)param;

    qcril_qmi_voice_voip_lock_overview();

    call_info = qcril_qmi_voice_voip_call_info_entries_enum_first();
    while ( NULL != call_info )
    {
      if (VOICE_INVALID_CALL_ID != call_info->android_call_id &&
          CALL_STATE_END_V02 == call_info->voice_scv_info.call_state &&
          timer_id == call_info->call_obj_phase_out_timer_id)
      {
        // timeout on keeping call obj, delete it now
        qcril_qmi_voice_voip_destroy_call_info_entry( call_info );
      }

      call_info = qcril_qmi_voice_voip_call_info_entries_enum_next();
    }

    qcril_qmi_voice_voip_unlock_overview();

    if (qcril_qmi_voice_voip_call_info_entries_is_empty())
    {
        QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
        if (!qcril_stop_diag_log())
        {
            QCRIL_LOG_INFO("qxdm logging disabled successfully");
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_ended_call_obj_phaseout

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_modified_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_MODIFIED_IND_V02.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_modified_ind_hdlr
(
 void   *data_ptr,
 uint32 data_len
)
{
  voice_modified_ind_msg_v02 *modify_ind_ptr = NULL;
  qcril_reqlist_public_type   req_info;
  IxErrnoType                 result = E_FAILURE;
  ims_CallModify              ims_unsol_modify_data;
  qcril_qmi_voice_voip_call_info_entry_type *call_info = NULL;
  voice_all_call_status_ind_msg_v02          call_status_ind;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(data_len);

  memset(&call_status_ind, 0, sizeof(call_status_ind));

  if (data_ptr != NULL)
  {
    modify_ind_ptr = (voice_modified_ind_msg_v02 *)data_ptr;

    call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(modify_ind_ptr->call_id);

    if (call_info != NULL)
    {
      /* udpate the call type */
      if (modify_ind_ptr->call_type_valid)
      {
        call_info->voice_scv_info.call_type = modify_ind_ptr->call_type;
      }

      if (modify_ind_ptr->audio_attrib_valid)
      {
        call_status_ind.audio_attrib_valid = TRUE;
        call_status_ind.audio_attrib_len = 1;
        call_status_ind.audio_attrib[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.audio_attrib[0].call_attributes = modify_ind_ptr->audio_attrib;
      }

      if (modify_ind_ptr->video_attrib_valid)
      {
        call_status_ind.video_attrib_valid = TRUE;
        call_status_ind.video_attrib_len = 1;
        call_status_ind.video_attrib[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.video_attrib[0].call_attributes = modify_ind_ptr->video_attrib;
      }

      if (modify_ind_ptr->call_attrib_status_valid)
      {
        call_status_ind.call_attrib_status_valid = TRUE;
        call_status_ind.call_attrib_status_len = 1;
        call_status_ind.call_attrib_status[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.call_attrib_status[0].call_attrib_status =
          modify_ind_ptr->call_attrib_status;
      }
      // Local Call Capabilities
      if (modify_ind_ptr->local_call_capabilities_valid)
      {
        call_status_ind.local_call_capabilities_info_valid = TRUE;
        call_status_ind.local_call_capabilities_info_len = 1;
        call_status_ind.local_call_capabilities_info[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.local_call_capabilities_info[0].audio_attrib =
          modify_ind_ptr->local_call_capabilities.audio_attrib;
        call_status_ind.local_call_capabilities_info[0].audio_cause  =
          modify_ind_ptr->local_call_capabilities.audio_cause;
        call_status_ind.local_call_capabilities_info[0].video_attrib =
          modify_ind_ptr->local_call_capabilities.video_attrib;
        call_status_ind.local_call_capabilities_info[0].video_cause  =
          modify_ind_ptr->local_call_capabilities.video_cause;
      }
      // Peer Call Capabilities
      if( modify_ind_ptr->peer_call_capabilities_valid)
      {
        call_status_ind.peer_call_capabilities_info_valid = TRUE;
        call_status_ind.peer_call_capabilities_info_len = 1;
        call_status_ind.peer_call_capabilities_info[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.peer_call_capabilities_info[0].audio_attrib =
          modify_ind_ptr->peer_call_capabilities.audio_attrib;
        call_status_ind.peer_call_capabilities_info[0].audio_cause  =
          modify_ind_ptr->peer_call_capabilities.audio_cause;
        call_status_ind.peer_call_capabilities_info[0].video_attrib =
          modify_ind_ptr->peer_call_capabilities.video_attrib;
        call_status_ind.peer_call_capabilities_info[0].video_cause  =
          modify_ind_ptr->peer_call_capabilities.video_cause;
      }
      //RTT mode check
      if (modify_ind_ptr->rtt_mode_valid  == TRUE)
      {
        call_status_ind.rtt_mode_valid = TRUE;
        call_status_ind.rtt_mode_len = 1;
        call_status_ind.rtt_mode[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.rtt_mode[0].rtt_mode = modify_ind_ptr->rtt_mode;
        QCRIL_LOG_DEBUG("modify ind rtt mode = %d", modify_ind_ptr->rtt_mode);
      }

      //RTT capabilities check
      if (modify_ind_ptr->rtt_capabilities_valid == TRUE )
      {
        call_status_ind.rtt_capabilities_info_valid = TRUE;
        call_status_ind.rtt_capabilities_info_len = 1;
        call_status_ind.rtt_capabilities_info[0].call_id = modify_ind_ptr->call_id;
        call_status_ind.rtt_capabilities_info[0].rtt_capabilities.local_rtt_cap =
          modify_ind_ptr->rtt_capabilities.local_rtt_cap;
        QCRIL_LOG_DEBUG("local rtt capability = %d", modify_ind_ptr->rtt_capabilities.local_rtt_cap);
        call_status_ind.rtt_capabilities_info[0].rtt_capabilities.peer_rtt_cap  =
          modify_ind_ptr->rtt_capabilities.peer_rtt_cap;
        QCRIL_LOG_DEBUG("peer rtt capability = %d", modify_ind_ptr->rtt_capabilities.peer_rtt_cap);
      }

      /* update the audio/video parameters */
      qcril_qmi_voice_voip_update_call_info_entry_mainstream (call_info, &call_status_ind,
          FALSE, call_info->ril_call_state);

      if(modify_ind_ptr->call_modified_cause_valid)
      {
        qcril_qmi_voice_call_info_entry_set_call_modified_cause(call_info,
            modify_ind_ptr->call_modified_cause);
      }

      // Reset the answered_call_type flag
      qcril_qmi_voice_voip_reset_answered_call_type(call_info, modify_ind_ptr);

      /* check for modify initiate pending request */
      result  = qcril_reqlist_query_by_event(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
          QCRIL_EVT_QMI_REQUEST_MODIFY_INITIATE, &req_info);

      /* now check for modify confirm pending request as both of them wait for same indication */
      if (result != E_SUCCESS)
      {
        result  = qcril_reqlist_query_by_event(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
            QCRIL_EVT_QMI_REQUEST_MODIFY_CONFIRM, &req_info);
      }

      if (result == E_SUCCESS)
      {
        /* modify was initiated/accepted(upgrade) by user, send the response now */
        qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID, req_info.t,
            req_info.request,
            modify_ind_ptr->failure_cause_valid ? RIL_E_GENERIC_FAILURE : RIL_E_SUCCESS);
      }
      else
      {
        if (modify_ind_ptr->failure_cause_valid && modify_ind_ptr->failure_cause)
        {
          memset(&ims_unsol_modify_data, 0, sizeof(ims_unsol_modify_data));

          ims_unsol_modify_data.has_callIndex = TRUE;
          ims_unsol_modify_data.callIndex = modify_ind_ptr->call_id;

          ims_CallDetails ims_call_details;
          memset(&ims_call_details, 0, sizeof(ims_call_details));

          if (call_info->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_MODIFY_CONFIRM_PENDING)
          {
            ims_unsol_modify_data.has_callDetails = TRUE;
            ims_unsol_modify_data.callDetails.has_callType = TRUE;
            ims_unsol_modify_data.callDetails.callType = call_info->to_modify_call_type;
            ims_unsol_modify_data.callDetails.has_callDomain = TRUE;
            ims_unsol_modify_data.callDetails.callDomain = call_info->to_modify_call_domain;
            ims_call_details.has_mediaId = TRUE;
            ims_call_details.mediaId = call_info->media_id;
            call_info->elaboration &=
              ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_MODIFY_CONFIRM_PENDING;
          }
          else
          {
            QCRIL_LOG_DEBUG("QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_MODIFY_CONFIRM_PENDING is not set");
          }

          ims_unsol_modify_data.has_error = TRUE;
          ims_unsol_modify_data.error = ims_Error_E_CANCELLED; // E_CANCELLED is the only valid value to IMS

          imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_MODIFY_CALL,
              ims_Error_E_SUCCESS, &ims_unsol_modify_data, sizeof(ims_unsol_modify_data));
        }
      }

      if (qcril_qmi_voice_call_to_atel(call_info))
      {
        /* send unsol indication to telephony for indicating change in call type*/
        qcril_qmi_voice_send_unsol_call_state_changed(QCRIL_DEFAULT_INSTANCE_ID);
      }
      if (qcril_qmi_voice_call_to_ims(call_info))
      {
        /* send unsol indication to IMS for indicating change in call type*/
        qcril_qmi_voice_send_ims_unsol_call_state_changed();
      }
    }
    else
    {
      QCRIL_LOG_DEBUG("could not find call-id = %d, ignoring modify ind", modify_ind_ptr->call_id);
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("received null data, ignoring modify ind");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_modified_ind_hdlr


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_modify_accept_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_MODIFY_ACCEPT_IND_V02.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_modify_accept_ind_hdlr
(
  void   *data_ptr,
  uint32 data_len
)
{
  voice_modify_accept_ind_msg_v02 *modify_ind_ptr = NULL;
  RIL_Call_Modify                  unsol_modify_data;
  boolean                          result;
  qcril_qmi_voice_voip_call_info_entry_type *call_info = NULL;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(data_len);

  if (data_ptr != NULL)
  {
    modify_ind_ptr = (voice_modify_accept_ind_msg_v02 *)data_ptr;

    call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(modify_ind_ptr->call_id);

    if (call_info != NULL)
    {
      /* fill the unsol modify data */
      unsol_modify_data.callIndex = call_info->android_call_id;
      unsol_modify_data.callDetails = (RIL_Call_Details *)qcril_malloc(
          sizeof(*unsol_modify_data.callDetails));

      if (unsol_modify_data.callDetails != NULL)
      {
        result = !qcril_qmi_voice_get_atel_call_type_info(modify_ind_ptr->call_type,
            modify_ind_ptr->video_attrib_valid,
            modify_ind_ptr->video_attrib,
            modify_ind_ptr->audio_attrib_valid,
            modify_ind_ptr->audio_attrib,
            FALSE,
            VOICE_CALL_ATTRIB_STATUS_OK_V02,
            FALSE,
            0,
            FALSE,
            ims_CallType_CALL_TYPE_VOICE,
            unsol_modify_data.callDetails);

        if (RIL_E_SUCCESS == result)
        {
          /* modify was initiated by network(other party), send indication to ims */
          ims_CallModify ims_unsol_modify_data;
          memset(&ims_unsol_modify_data, 0,sizeof(ims_unsol_modify_data));

          if (modify_ind_ptr->rtt_mode_valid)
          {
            ims_unsol_modify_data.has_callDetails = TRUE;
            ims_unsol_modify_data.callDetails.has_rttMode = qcril_qmi_ims_map_qcril_rtt_mode_to_ims(
                  modify_ind_ptr->rtt_mode, &ims_unsol_modify_data.callDetails.rttMode);
          }
          qcril_qmi_ims_translate_ril_callmodify_to_ims_callmodify(&unsol_modify_data,
              &ims_unsol_modify_data);
          imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_MODIFY_CALL,
              ims_Error_E_SUCCESS, &ims_unsol_modify_data, sizeof(ims_unsol_modify_data));
          call_info->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_MODIFY_CONFIRM_PENDING;
          call_info->to_modify_call_domain = ims_unsol_modify_data.callDetails.callDomain;
          call_info->to_modify_call_type = ims_unsol_modify_data.callDetails.callType;
        }
        else
        {
          QCRIL_LOG_DEBUG("could not convert modem call type to atel call type");
        }
        qcril_free(unsol_modify_data.callDetails);
      }
      else
      {
        QCRIL_LOG_ERROR("memory malloc failed");
      }
    }
    else
    {
      QCRIL_LOG_DEBUG("could not find call-id = %d, ignoring modify accept ind",
          modify_ind_ptr->call_id);
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("received null data, ignoring modify accept ind");
  }

  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_SPEECH_CODEC_INFO_IND_V02.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_speech_codec_info_ind_hdlr
(
  void   *data_ptr,
  uint32 data_len
)
{
  voice_speech_codec_info_ind_msg_v02* speech_codec_ptr;
  boolean call_to_atel = FALSE;
  boolean call_to_ims  = FALSE;
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(data_len);

  if( data_ptr )
  {
     speech_codec_ptr = (voice_speech_codec_info_ind_msg_v02*) data_ptr;

     // add codec info to the associated call
     if (speech_codec_ptr->call_id_valid && speech_codec_ptr->speech_codec_valid)
     {
        qcril_qmi_voice_voip_lock_overview();
        qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(speech_codec_ptr->call_id);
        if (NULL == call_info_entry)
        {
           QCRIL_LOG_ERROR("did not find the call with qmi id: %d", speech_codec_ptr->call_id);
        }
        else
        {
           call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CODEC_VALID;
           call_info_entry->codec = speech_codec_ptr->speech_codec;
           call_to_atel = qcril_qmi_voice_call_to_atel(call_info_entry);
           call_to_ims  = qcril_qmi_voice_call_to_ims (call_info_entry);
        }
        qcril_qmi_voice_voip_unlock_overview();
        if (call_to_atel)
        {
          qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
        }
        if (call_to_ims)
        {
          qcril_qmi_voice_send_ims_unsol_call_state_changed();
        }

        if (feature_report_speech_codec)
        {
          if (call_info_entry)
          {
            int payload[3] = {0};

            payload[0] = call_info_entry->android_call_id;
            payload[1] = speech_codec_ptr->speech_codec;
            if (speech_codec_ptr->network_mode_valid)
            {
              payload[2] = speech_codec_ptr->network_mode;
            }

            QCRIL_LOG_INFO("QCRIL_EVT_HOOK_UNSOL_SPEECH_CODEC_INFO: call_id: %d speech_codec: %d"
                " network_mode: %d", call_info_entry->android_call_id,
                speech_codec_ptr->speech_codec, speech_codec_ptr->network_mode);
            qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID,
                QCRIL_EVT_HOOK_UNSOL_SPEECH_CODEC_INFO, (char *)payload, sizeof(payload));
          }
        }
     }
  }

  QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_nas_control_is_call_mode_reported_voice_radio_tech_different

===========================================================================*/
/*!
    @brief
    Compares call_mode to reported voice radio tech and
    returns TRUE if they do not belong to the same radio_technology family

    @return
    None.
*/
/*=========================================================================*/
int qcril_qmi_voice_nas_control_is_call_mode_reported_voice_radio_tech_different(call_mode_enum_v02 call_mode)
{
  unsigned int res = FALSE;
  unsigned int call_radio_tech = RADIO_TECH_UNKNOWN;
  unsigned int old_call_radio_tech = RADIO_TECH_UNKNOWN;
  unsigned int old_call_radio_tech_family = RADIO_TECH_UNKNOWN;

  call_radio_tech = qcril_qmi_voice_convert_call_mode_to_radio_tech_family(call_mode);

#ifndef USING_NAS_PUBLIC_API
  old_call_radio_tech = qcril_qmi_voice_nas_control_get_reported_voice_radio_tech();
#else
  if (qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid)
    old_call_radio_tech = qcril_qmi_voice_nas_reported_info.voice_radio_tech;
#endif
  old_call_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(old_call_radio_tech);

  if (
      ( call_radio_tech != old_call_radio_tech_family ) &&
      ( RADIO_TECH_UNKNOWN != old_call_radio_tech )
     )
  {
    res = TRUE;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
}/* qcril_qmi_voice_nas_control_is_call_mode_reported_voice_radio_tech_different */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family

===========================================================================*/
/*!
    @brief
    Converts the reported voice radio tech to voice radio tech family in case
    of ICS


    @return
    Voice radio tech family.
*/
/*=========================================================================*/
unsigned int qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(unsigned int voice_radio_tech)
{
  unsigned int voice_radio_tech_family = RADIO_TECH_UNKNOWN;

  QCRIL_LOG_INFO("entered voice_radio_tech %d", (int) voice_radio_tech);

  /* convert to the radio tech family in terms of radio tech*/
  switch( voice_radio_tech )
  {
    case RADIO_TECH_GPRS:
    case RADIO_TECH_EDGE:
    case RADIO_TECH_UMTS:
    case RADIO_TECH_TD_SCDMA:
    case RADIO_TECH_HSDPA:
    case RADIO_TECH_HSUPA:
    case RADIO_TECH_HSPA:
    case RADIO_TECH_LTE:
    case RADIO_TECH_HSPAP:
    case RADIO_TECH_GSM:
        voice_radio_tech_family = RADIO_TECH_3GPP;
        break;

    case RADIO_TECH_IS95A:
    case RADIO_TECH_IS95B:
    case RADIO_TECH_1xRTT:
    case RADIO_TECH_EVDO_0:
    case RADIO_TECH_EVDO_A:
    case RADIO_TECH_EVDO_B:
    case RADIO_TECH_EHRPD:
        voice_radio_tech_family = RADIO_TECH_3GPP2;
        break;

    default:
     QCRIL_LOG_ERROR("invalid radio tech = %d", voice_radio_tech);
     break;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(voice_radio_tech_family);
  return voice_radio_tech_family;
}/* qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_convert_call_mode_to_radio_tech_family

===========================================================================*/
/*!
    @brief
    Converts the reported call mode to voice radio tech family


    @return
    Voice radio tech family.
*/
/*=========================================================================*/
unsigned int qcril_qmi_voice_convert_call_mode_to_radio_tech_family(call_mode_enum_v02 call_mode)
{
  unsigned int call_radio_tech = RADIO_TECH_UNKNOWN;

  QCRIL_LOG_INFO("entered call_mode %d", (int) call_mode);

  switch( call_mode )
  {
    case CALL_MODE_CDMA_V02:
      call_radio_tech = RADIO_TECH_3GPP2;
      break;

    case CALL_MODE_GSM_V02:
    case CALL_MODE_UMTS_V02:
    case CALL_MODE_TDS_V02:
    case CALL_MODE_LTE_V02:
      call_radio_tech = RADIO_TECH_3GPP;
      break;

    default:
      call_radio_tech = RADIO_TECH_UNKNOWN;
      break;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(call_radio_tech);
  return call_radio_tech;
}/* qcril_qmi_voice_convert_call_mode_to_radio_tech_family */

#ifndef USING_NAS_PUBLIC_API
//===========================================================================
//qcril_qmi_voice_nas_control_get_reported_voice_radio_tech
//===========================================================================
RIL_RadioTechnology qcril_qmi_voice_nas_control_get_reported_voice_radio_tech()
{
    RIL_RadioTechnology voice_radio_tech;

    QCRIL_LOG_FUNC_ENTRY();

    voice_radio_tech = qcril_qmi_nas_get_reported_voice_radio_tech();

    QCRIL_LOG_INFO("completed with voice_radio_tech %d", voice_radio_tech);
    return voice_radio_tech;
} //qcril_qmi_voice_nas_control_get_reported_voice_radio_tech
#endif

void qcril_qmi_voice_nas_control_process_calls_pending_for_specified_voice_rte
(
  unsigned int call_radio_tech_family
)
{
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  int res = FALSE;
  boolean call_to_atel = FALSE;
  boolean call_to_ims  = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_voip_lock_overview();
  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info_entry )
  {
    qcril_qmi_voice_voip_call_info_dump( call_info_entry );
    if( (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE) &&
        (call_radio_tech_family == qcril_qmi_voice_convert_call_mode_to_radio_tech_family(call_info_entry->voice_scv_info.mode)) )
    {
      call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE; //Resetting the WAITING_FOR_MATCHING_VOICE_RTE bit
      res = TRUE;
      call_to_atel = qcril_qmi_voice_call_to_atel(call_info_entry);
      call_to_ims  = qcril_qmi_voice_call_to_ims (call_info_entry);

      QCRIL_LOG_INFO("Resuming android call id %d as call mode matches with the current voice radio tech",call_info_entry->android_call_id);
    }
    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  qcril_qmi_voice_voip_unlock_overview();

  if( res )
  {
     if (call_to_atel)
     {
       qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
     }
     if (call_to_ims)
     {
       qcril_qmi_voice_send_ims_unsol_call_state_changed();
     }
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
//qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte
//===========================================================================
void qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte()
{
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  unsigned int call_radio_tech = RADIO_TECH_UNKNOWN;
  unsigned int call_radio_tech_family = RADIO_TECH_UNKNOWN;
  int res = FALSE;
  boolean call_to_atel = FALSE;
  boolean call_to_ims  = FALSE;

  QCRIL_LOG_FUNC_ENTRY();
#ifndef USING_NAS_PUBLIC_API
  call_radio_tech = qcril_qmi_voice_nas_control_get_reported_voice_radio_tech();
#else
  if (qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid)
    call_radio_tech = qcril_qmi_voice_nas_reported_info.voice_radio_tech;
#endif
  call_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(call_radio_tech);

  qcril_qmi_voice_voip_lock_overview();
  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info_entry )
  {
    qcril_qmi_voice_voip_call_info_dump( call_info_entry );
    if( (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE) &&
        (call_radio_tech_family == qcril_qmi_voice_convert_call_mode_to_radio_tech_family(call_info_entry->voice_scv_info.mode)) )
    {
      call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE; //Resetting the WAITING_FOR_MATCHING_VOICE_RTE bit
      res = TRUE;
      call_to_atel = qcril_qmi_voice_call_to_atel(call_info_entry);
      call_to_ims  = qcril_qmi_voice_call_to_ims (call_info_entry);

      QCRIL_LOG_INFO("Resuming android call id %d as call mode matches with the current voice radio tech",call_info_entry->android_call_id);
    }
    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
  }
  qcril_qmi_voice_voip_unlock_overview();

  if( res )
  {
     if (call_to_atel)
     {
       qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
     }
     if (call_to_ims)
     {
       qcril_qmi_voice_send_ims_unsol_call_state_changed();
     }
  }

  QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_sups_notification_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_SUPS_NOTIFICATION_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_sups_notification_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_sups_notification_ind_msg_v02* sups_notify_ind;
  qcril_instance_id_e_type instance_id= QCRIL_DEFAULT_INSTANCE_ID;;
  RIL_SuppSvcNotification response;
  boolean success = FALSE;
  qcril_unsol_resp_params_type unsol_resp;
  char number[ 2 * QCRIL_QMI_VOICE_CALLED_PARTY_BCD_NO_LENGTH ];
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  char ip_hist_info_utf8_str[QCRIL_QMI_VOICE_MAX_IP_HISTORY_INFO_LEN*2];
  int  utf8_len = 0;
  QCRIL_NOTUSED(ind_data_len);

  if( ind_data_ptr != NULL )
  {
    sups_notify_ind = (voice_sups_notification_ind_msg_v02*)ind_data_ptr;

    memset( ( void* )&response, 0, sizeof( response ) );
    memset( ( void* )&number, 0, sizeof( number ) );
    /* Add event processing here */
    switch(sups_notify_ind->notification_info.notification_type)
    {
      case NOTIFICATION_TYPE_UNCOND_CALL_FORWARD_ACTIVE_V02:
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_UNCOND_FWD_ACTIVE;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_COND_CALL_FORWARD_ACTIVE_V02:
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_COND_FWD_ACTIVE;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_OUTGOING_CALL_IS_FORWARDED_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_CALL_FORWARDED;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_OUTGOING_CALL_IS_WAITING_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_CALL_WAITING;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_OUTGOING_CALLS_BARRED_V02:
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_OUTGOING_CALLS_BARRED;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_CALLS_BARRED_V02:
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_INCOMING_CALLS_BARRED;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_CLIR_SUPPRSESION_REJECTED_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_CLIR_SUPPRESSION_REJ;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_FORWARDED_CALL_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_FORWARDED_CALL;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_OUTGOING_CUG_CALL_V02:
        if(sups_notify_ind->index_valid)
        {
          response.index = sups_notify_ind->index;
        }
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_CUG_CALL;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_CUG_CALL_V02:
        if(sups_notify_ind->index_valid)
        {
          response.index = sups_notify_ind->index;
        }
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_CUG_CALL;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_CALL_IS_ON_HOLD_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_CALL_HOLD;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_CALL_IS_RETRIEVED_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_CALL_RETRIEVED;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_CALL_IS_FORWARDED_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_ADDITIONAL_INCOM_CALL_FWD;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_CALL_IS_ECT_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        if(sups_notify_ind->ect_number_valid == TRUE)
        {
          if(sups_notify_ind->ect_number.ect_call_state == ECT_CALL_STATE_ALERTING_V02)
          {
            response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_ECT_CALL_REMOTE_PTY_ALERT;
          }
          else if(sups_notify_ind->ect_number.ect_call_state == ECT_CALL_STATE_ACTIVE_V02)
          {
            response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_ECT_CALL_REMOTE_PTY_CONNECTED;
            if(sups_notify_ind->ect_number.number_len != 0 )
            {
              memset(number,0,sizeof(number));
              if( sups_notify_ind->ect_number.number_len < sizeof(number) )
              {
                memcpy(number,sups_notify_ind->ect_number.number,sups_notify_ind->ect_number.number_len);
              }
              else
              {
                memcpy(number,sups_notify_ind->ect_number.number,(sizeof(number)-1));
              }

              /* Set Type based on '+' prefix */
              response.type = ( QCRIL_QMI_VOICE_SS_TA_INTER_PREFIX == number[ 0 ] ) ? QCRIL_QMI_VOICE_SS_TA_INTERNATIONAL : QCRIL_QMI_VOICE_SS_TA_UNKNOWN;
              /* number[0] contains type and the rest contains the number in ASCII */
              if ( response.type == QCRIL_QMI_VOICE_SS_TA_INTERNATIONAL )
              {
                response.number = (char * )&number[ 1 ];
              }
              else
              {
                response.number = (char * )&number[ 0 ];
              }
              QCRIL_LOG_DEBUG( "ECT notification has number = %s",response.number);
            }
          }
          else
          {
            QCRIL_LOG_DEBUG( "Invalid ECT notification call state  = %d",sups_notify_ind->ect_number.ect_call_state);
          }

        }
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_OUTGOING_CALL_IS_DEFLECTED_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MO_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSI_CALL_DEFLECTED;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_INCOMING_DEFLECTED_CALL_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_DEFLECTED_CALL;
        success = TRUE;
        break;
      case NOTIFICATION_TYPE_CALL_IS_IN_MPTY_V02:
        response.number = NULL;
        response.notificationType = (int) QCRIL_QMI_VOICE_SS_MT_NOTIFICATION;
        response.code = (int) QCRIL_QMI_VOICE_SS_CSSU_MPTY_CALL;
        success = TRUE;
        break;
      default :
        QCRIL_LOG_ERROR( "Invalid sups notification type recieved = %d",sups_notify_ind->notification_info.notification_type);
        break;
    }

    if ( success )
    {
      QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_ORIG_FWD_STATUS notification type %d, response code %d",
                       response.notificationType, response.code);

      /* Call related notifications to RIL */
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( sups_notify_ind->notification_info.call_id );
      if (!qcril_qmi_voice_call_to_ims(call_info_entry))
      {
        qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
        unsol_resp.resp_pkt = ( void * ) &response;
        unsol_resp.resp_len = sizeof( response );
        qcril_send_unsol_response( &unsol_resp );
      }
      else
      {
        ims_SuppSvcNotification ims_unsol_supp_svc_notification;
        memset(&ims_unsol_supp_svc_notification, 0,sizeof(ims_unsol_supp_svc_notification));
        qcril_qmi_ims_translate_ril_suppsvcnotification_to_ims_suppsvcnotification(&response, &ims_unsol_supp_svc_notification);

        if (call_info_entry)
        {
            ims_unsol_supp_svc_notification.has_connId = TRUE;
            ims_unsol_supp_svc_notification.connId = call_info_entry->android_call_id;
        }

        if(sups_notify_ind->ip_forward_hist_info_valid)
        {
            //Convert UTF16 to UTF8 string
            utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                                 (char *) sups_notify_ind->ip_forward_hist_info,
                                 sups_notify_ind->ip_forward_hist_info_len * 2,
                                 ip_hist_info_utf8_str,
                                 sizeof(ip_hist_info_utf8_str) );

            QCRIL_LOG_DEBUG ("ip_hist_info (utf8 data) : %s", ip_hist_info_utf8_str);
            if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_IP_HISTORY_INFO_LEN * 2 ) )
            {
              QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_IP_HISTORY_INFO_LEN");
              utf8_len = (int) (QCRIL_QMI_VOICE_MAX_IP_HISTORY_INFO_LEN*2);
              ip_hist_info_utf8_str[ utf8_len - 1] = '\0';
            }
            ims_unsol_supp_svc_notification.history_info.arg = qmi_ril_util_str_clone(ip_hist_info_utf8_str);
        }

        if (ims_unsol_supp_svc_notification.code ==  QCRIL_QMI_VOICE_SS_CSSU_CALL_HOLD)
        {
            QCRIL_LOG_DEBUG ("media_direction_hold_valid = %d, media_direction_hold = 0x%x",
                    sups_notify_ind->media_direction_hold_valid,
                    sups_notify_ind->media_direction_hold);

            if(sups_notify_ind->media_direction_hold_valid)
            {
                ims_unsol_supp_svc_notification.has_hold_tone = TRUE;
                if (sups_notify_ind->media_direction_hold == 0)  // media direction NONE
                {
                    ims_unsol_supp_svc_notification.hold_tone = TRUE;
                }
                else
                {
                    ims_unsol_supp_svc_notification.hold_tone = FALSE;
                }
            }
        }

        imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_SUPP_SVC_NOTIFICATION, ims_Error_E_SUCCESS, &ims_unsol_supp_svc_notification, sizeof(ims_unsol_supp_svc_notification));

        if (ims_unsol_supp_svc_notification.number.arg)
        {
          qcril_free( ims_unsol_supp_svc_notification.number.arg );
        }
        if (ims_unsol_supp_svc_notification.history_info.arg)
        {
          qcril_free( ims_unsol_supp_svc_notification.history_info.arg );
        }
      }
    }
  }

}/* qcril_qmi_voice_sups_notification_ind_hdlr */

//===========================================================================
// qcril_qmi_voice_call_num_copy_with_toa_check
//===========================================================================
uint32_t qcril_qmi_voice_call_num_copy_with_toa_check(char *src, uint32_t src_size, char* dest,
                                                      uint32_t dest_buffer_size, voice_num_type_enum_v02 num_type)
{
  uint32_t ret_size = 0;
  int offset = 0;

  if ( NULL == src || NULL == dest || src_size + 1 >= dest_buffer_size )
  {
    QCRIL_LOG_ERROR("function paramenter incorrect");
  }
  else
  {
    if ( QMI_VOICE_NUM_TYPE_INTERNATIONAL_V02 != num_type )
    {
      ret_size = src_size;
      memcpy(dest, src, src_size);
    }
    else
    {
      if ( QCRIl_QMI_VOICE_SS_TA_INTER_PREFIX == src[0] )
      {
        ret_size = src_size;
        memcpy(dest, src, src_size);
      }
      else
      {
        if (src_size > 1 && src[0] == '0' && src[1] == '0')
        {
          QCRIL_LOG_INFO("Removing 00 prefix");
          offset = 2;
          src_size-=2; //src_size can not turn negative since we have already checked "if (src_size > 1" above
        }
        ret_size = src_size + 1;
        dest[0] = QCRIl_QMI_VOICE_SS_TA_INTER_PREFIX;
        memcpy(dest+1, src + offset, src_size);
      }
    }
    dest [ret_size] = 0;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET( ret_size );

  return ret_size;
} // qcril_qmi_voice_call_num_copy_with_toa_check

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_info_rec_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_INFO_REC_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_info_rec_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  RIL_CDMA_CallWaiting            call_waiting;
  RIL_CDMA_InformationRecords     info_recs;
  RIL_CDMA_SignalInfoRecord       signal_info_rec;
  voice_info_rec_ind_msg_v02 *    info_rec_ind;
  qcril_unsol_resp_params_type    unsol_resp;
  unsigned int                    idx = 0;
  uint8                           display_tag;
  uint8                           display_len;
  boolean                         call_is_in_call_waiting_state = FALSE;
  boolean                         ignore_caller_name = FALSE;
  unsigned int                    buf_len = 0;
  struct
  {
    char buf[QMI_VOICE_CALLER_ID_MAX_V02+1];
    char pi;
    int  number_type;
    int  number_plan;
  } number;
  char                            name[QMI_VOICE_CALLER_NAME_MAX_V02+1];
  boolean                         name_changed = FALSE,
                                  number_changed = FALSE;
  unsigned int                    iter_idx;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  RIL_CDMA_SignalInfoRecord*      info_rec_pass_over;

  int                             need_reset_1x_num_wait_tmr;
  static const unsigned int max_ril_cdma_info_recs = sizeof(RIL_CDMA_InformationRecords::infoRec) / sizeof(RIL_CDMA_InformationRecords::infoRec[0]);

  QCRIL_NOTUSED(ind_data_len);

  QCRIL_LOG_FUNC_ENTRY();

  need_reset_1x_num_wait_tmr = FALSE;

  if( ind_data_ptr != NULL )
  {
    info_rec_ind = (voice_info_rec_ind_msg_v02*)ind_data_ptr;
    memset( &info_recs, 0, sizeof( info_recs ) );
    memset( &number, 0, sizeof(number) );
    memset( &name, 0, sizeof(name) );
    memset( &signal_info_rec, 0, sizeof(signal_info_rec) );


    QCRIL_LOG_INFO(".. call_waiting_valid, state %d, %d", (int)info_rec_ind->call_waiting_valid, (int)info_rec_ind->call_waiting );
    if (info_rec_ind->call_waiting_valid)
    {
      call_is_in_call_waiting_state = (info_rec_ind->call_waiting == CALL_WAITING_NEW_CALL_V02) ?
                                       TRUE: FALSE;
    }
    QCRIL_LOG_INFO(".. call in waiting state org %d", (int)call_is_in_call_waiting_state );

    QCRIL_LOG_INFO(".. caller_id_info_valid %d", (int)info_rec_ind->caller_id_info_valid );
    QCRIL_LOG_INFO(".. calling_party_info_valid %d", (int)info_rec_ind->calling_party_info_valid );
    if( info_rec_ind->caller_id_info_valid && info_rec_ind->calling_party_info_valid )
    {
      QCRIL_LOG_INFO("caller_id caller_id_len: %d, pi: %d", info_rec_ind->caller_id_info.caller_id_len, info_rec_ind->caller_id_info.pi);
      QCRIL_LOG_INFO("calling_party_info num_type: %d, num_plan: %d, si: %d",
                     info_rec_ind->calling_party_info.num_type, info_rec_ind->calling_party_info.num_plan,
                     info_rec_ind->calling_party_info.si);
      if (idx < max_ril_cdma_info_recs)
      {
        info_recs.infoRec[idx].name = RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC;

        info_recs.infoRec[idx].rec.number.len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->caller_id_info.caller_id,
                                                                                             info_rec_ind->caller_id_info.caller_id_len,
                                                                                             info_recs.infoRec[idx].rec.number.buf,
                                                                                             sizeof(info_recs.infoRec[idx].rec.number.buf),
                                                                                             info_rec_ind->calling_party_info.num_type);

        info_recs.infoRec[idx].rec.number.pi = (char)info_rec_ind->caller_id_info.pi;
        info_recs.infoRec[idx].rec.number.number_type = info_rec_ind->calling_party_info.num_type;
        info_recs.infoRec[idx].rec.number.number_plan = info_rec_ind->calling_party_info.num_plan;
        info_recs.infoRec[idx].rec.number.si = info_rec_ind->calling_party_info.si;
        idx++;
      }

      qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->caller_id_info.caller_id,
                                                   info_rec_ind->caller_id_info.caller_id_len,
                                                   number.buf,
                                                   sizeof(number.buf),
                                                   info_rec_ind->calling_party_info.num_type);
      number.pi = (char)info_rec_ind->caller_id_info.pi;
      number.number_type = info_rec_ind->calling_party_info.num_type;
      number.number_plan = info_rec_ind->calling_party_info.num_plan;
      number_changed = TRUE;
    }
    else if ( info_rec_ind->caller_id_info_valid && !info_rec_ind->calling_party_info_valid )
    {
      QCRIL_LOG_INFO("caller_id caller_id_len: %d, pi: %d", info_rec_ind->caller_id_info.caller_id_len, info_rec_ind->caller_id_info.pi);
      if (idx < max_ril_cdma_info_recs)
      {
        info_recs.infoRec[idx].name = RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC;
        info_recs.infoRec[idx].rec.number.len = std::min(sizeof(info_recs.infoRec[idx].rec.number.buf),
                                                         (size_t)info_rec_ind->caller_id_info.caller_id_len);
        memcpy(info_recs.infoRec[idx].rec.number.buf,
               info_rec_ind->caller_id_info.caller_id,
               info_recs.infoRec[idx].rec.number.len);
        info_recs.infoRec[idx].rec.number.pi = (char)info_rec_ind->caller_id_info.pi;
        info_recs.infoRec[idx].rec.number.number_type = QMI_VOICE_NUM_TYPE_UNKNOWN_V02;
        info_recs.infoRec[idx].rec.number.number_plan = QMI_VOICE_NUM_PLAN_UNKNOWN_V02;
        info_recs.infoRec[idx].rec.number.si = QMI_VOICE_SI_USER_PROVIDED_NOT_SCREENED_V02;
        idx++;
      }

      buf_len = std::min(sizeof(number.buf) - 1, (size_t)info_rec_ind->caller_id_info.caller_id_len);
      memcpy(number.buf, info_rec_ind->caller_id_info.caller_id, buf_len);
      number.buf[buf_len] = '\0';

      number.pi = (char)info_rec_ind->caller_id_info.pi;
      number.number_type = QMI_VOICE_NUM_TYPE_UNKNOWN_V02;
      number.number_plan = QMI_VOICE_NUM_PLAN_UNKNOWN_V02;
      number_changed = TRUE;
    }
    else if ( info_rec_ind->calling_party_info_valid )
    {
      QCRIL_LOG_INFO("calling_party_info num_len: %d, pi: %d, num_type: %d, num_plan: %d, si: %d",
                     info_rec_ind->calling_party_info.num_len, info_rec_ind->calling_party_info.pi,
                     info_rec_ind->calling_party_info.num_type, info_rec_ind->calling_party_info.num_plan,
                     info_rec_ind->calling_party_info.si);

      if (idx < max_ril_cdma_info_recs)
      {
        info_recs.infoRec[idx].name = RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC;
        info_recs.infoRec[idx].rec.number.len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->calling_party_info.num,
                                                                                             info_rec_ind->calling_party_info.num_len,
                                                                                             info_recs.infoRec[idx].rec.number.buf,
                                                                                             sizeof(info_recs.infoRec[idx].rec.number.buf),
                                                                                             info_rec_ind->calling_party_info.num_type);
        info_recs.infoRec[idx].rec.number.pi = (char)info_rec_ind->calling_party_info.pi;
        info_recs.infoRec[idx].rec.number.number_type = info_rec_ind->calling_party_info.num_type;
        info_recs.infoRec[idx].rec.number.number_plan = info_rec_ind->calling_party_info.num_plan;
        info_recs.infoRec[idx].rec.number.si = info_rec_ind->calling_party_info.si;
        idx++;
      }

      qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->calling_party_info.num,
                                                   info_rec_ind->calling_party_info.num_len,
                                                   number.buf,
                                                   sizeof(number.buf),
                                                   info_rec_ind->calling_party_info.num_type);
      number.pi = (char)info_rec_ind->calling_party_info.pi;
      number.number_type = info_rec_ind->calling_party_info.num_type;
      number.number_plan = info_rec_ind->calling_party_info.num_plan;
      number_changed = TRUE;
    }

    QCRIL_LOG_INFO(".. display_buffer_valid %d", (int)info_rec_ind->display_buffer_valid );
    if ( info_rec_ind->display_buffer_valid && idx < max_ril_cdma_info_recs )
    {
      info_recs.infoRec[idx].name = RIL_CDMA_DISPLAY_INFO_REC;
      info_recs.infoRec[idx].rec.display.alpha_len = std::min(sizeof(info_recs.infoRec[idx].rec.display.alpha_buf),
                                                              (size_t)strlen(info_rec_ind->display_buffer));
      QCRIL_LOG_INFO("display_buffer length: %d", info_recs.infoRec[idx].rec.display.alpha_len);
      memcpy(info_recs.infoRec[idx].rec.display.alpha_buf,
             info_rec_ind->display_buffer,
             info_recs.infoRec[idx].rec.display.alpha_len);
      idx++;
    }

    QCRIL_LOG_INFO(".. ext_display_record_valid %d", (int)info_rec_ind->ext_display_record_valid );
    QCRIL_LOG_INFO(".. ext_display_buffer_valid %d", (int)info_rec_ind->ext_display_buffer_valid );
    if ( info_rec_ind->ext_display_record_valid )
    {
      display_tag = info_rec_ind->ext_display_record.ext_display_info[0];
      display_len = info_rec_ind->ext_display_record.ext_display_info[1];
      QCRIL_LOG_INFO("ext_display_record display_type: %d, ext_display_info_len: %d, is_0x9e_not_treat_as_name: %d",
                     display_tag, display_len, qcril_qmi_voice_info.is_0x9e_not_treat_as_name);
      if ( display_tag == 0x8D || display_tag == 0x8F || (display_tag == 0x9E && !qcril_qmi_voice_info.is_0x9e_not_treat_as_name))
      {
        memcpy(name, info_rec_ind->ext_display_record.ext_display_info+2, display_len);
        name_changed = TRUE;
      }
      else
      {
        if (idx < max_ril_cdma_info_recs)
        {
          info_recs.infoRec[idx].name = RIL_CDMA_EXTENDED_DISPLAY_INFO_REC;
          info_recs.infoRec[idx].rec.display.alpha_len = std::min(sizeof(info_recs.infoRec[idx].rec.display.alpha_buf),
              (size_t)info_rec_ind->ext_display_record.ext_display_info_len);
          memcpy(info_recs.infoRec[idx].rec.display.alpha_buf,
                 info_rec_ind->ext_display_record.ext_display_info,
                 info_recs.infoRec[idx].rec.display.alpha_len);
          idx++;
        }
        if ( display_tag == 0x9E && qcril_qmi_voice_info.is_0x9e_not_treat_as_name )
        {
          ignore_caller_name = TRUE;
        }
      }
    }
    else if(info_rec_ind->ext_display_buffer_valid && idx < max_ril_cdma_info_recs)
    {
      info_recs.infoRec[idx].name = RIL_CDMA_EXTENDED_DISPLAY_INFO_REC;
      info_recs.infoRec[idx].rec.display.alpha_len = std::min(sizeof(info_recs.infoRec[idx].rec.display.alpha_buf),
          (size_t)strlen(info_rec_ind->ext_display_buffer));
      QCRIL_LOG_INFO("ext_display_buffer length: %d", info_recs.infoRec[idx].rec.display.alpha_len);
      memcpy(info_recs.infoRec[idx].rec.display.alpha_buf,
             info_rec_ind->ext_display_buffer,
             info_recs.infoRec[idx].rec.display.alpha_len);
      idx++;
    }

    QCRIL_LOG_INFO(".. caller_name_valid %d", (int)info_rec_ind->caller_name_valid );
    QCRIL_LOG_INFO(".. name_changed %d", (int)name_changed);
    if(info_rec_ind->caller_name_valid && !name_changed && !ignore_caller_name)
    {
      buf_len = strlen(info_rec_ind->ext_display_buffer);
      QCRIL_LOG_INFO("caller_name length: %d", buf_len);
      memcpy(name, info_rec_ind->caller_name, buf_len);
      name_changed = TRUE;
    }

    QCRIL_LOG_INFO(".. audio_control_valid %d", (int)info_rec_ind->audio_control_valid );
    if(info_rec_ind->audio_control_valid && idx < max_ril_cdma_info_recs)
    {
      QCRIL_LOG_INFO("audio control downlink: %d, uplink: %d",
                     info_rec_ind->audio_control.down_link, info_rec_ind->audio_control.up_link);
      info_recs.infoRec[idx].name = RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC;
      info_recs.infoRec[idx].rec.audioCtrl.downLink = info_rec_ind->audio_control.down_link;
      info_recs.infoRec[idx].rec.audioCtrl.upLink = info_rec_ind->audio_control.up_link;
      idx++;
    }

    QCRIL_LOG_INFO(".. clir_cause_valid %d", (int)info_rec_ind->clir_cause_valid );
    if (info_rec_ind->clir_cause_valid)
    {
      if (idx < max_ril_cdma_info_recs)
      {
        QCRIL_LOG_INFO("clir_cause: %d", info_rec_ind->clir_cause);
        info_recs.infoRec[idx].name = RIL_CDMA_T53_CLIR_INFO_REC;
        info_recs.infoRec[idx].rec.clir.cause = (char)info_rec_ind->clir_cause;
        idx++;
      }
      number_changed = TRUE;
    }

    QCRIL_LOG_INFO(".. nss_release_valid %d", (int)info_rec_ind->nss_release_valid);
    if (info_rec_ind->nss_release_valid)
    {
      QCRIL_LOG_INFO("nss_release: %d", info_rec_ind->nss_release);
      uint32 nss_release_size = sizeof(info_rec_ind->nss_release);
      uint32 call_id_size = sizeof(info_rec_ind->call_id);
      char info[(nss_release_size + call_id_size)];
      memcpy(info, &info_rec_ind->nss_release, nss_release_size);
      memcpy((info + nss_release_size), &info_rec_ind->call_id, call_id_size);
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_NSS_RELEASE,
                                info, (nss_release_size + call_id_size) );

      if (idx < max_ril_cdma_info_recs)
      {
        info_recs.infoRec[idx].name = RIL_CDMA_T53_RELEASE_INFO_REC;
        idx++;
      }
    }

    QCRIL_LOG_INFO(".. redirecting_num_info_valid %d", (int)info_rec_ind->redirecting_num_info_valid);
    if (info_rec_ind->redirecting_num_info_valid && idx < max_ril_cdma_info_recs)
    {
      QCRIL_LOG_INFO("redirecting reason: %d, pi: %d, si: %d, num_plan: %d, num_type: %d, len: %d",
                     info_rec_ind->redirecting_num_info.reason, info_rec_ind->redirecting_num_info.pi,
                     info_rec_ind->redirecting_num_info.si, info_rec_ind->redirecting_num_info.num_plan,
                     info_rec_ind->redirecting_num_info.num_type, info_rec_ind->redirecting_num_info.num_len);

      info_recs.infoRec[idx].name = RIL_CDMA_REDIRECTING_NUMBER_INFO_REC;
      info_recs.infoRec[idx].rec.redir.redirectingReason = (RIL_CDMA_RedirectingReason)info_rec_ind->redirecting_num_info.reason;
      info_recs.infoRec[idx].rec.redir.redirectingNumber.pi = info_rec_ind->redirecting_num_info.pi;
      info_recs.infoRec[idx].rec.redir.redirectingNumber.si = info_rec_ind->redirecting_num_info.si;
      info_recs.infoRec[idx].rec.redir.redirectingNumber.number_plan = info_rec_ind->redirecting_num_info.num_plan;
      info_recs.infoRec[idx].rec.redir.redirectingNumber.number_type = info_rec_ind->redirecting_num_info.num_type;
      info_recs.infoRec[idx].rec.redir.redirectingNumber.len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->redirecting_num_info.num,
                                                                                                            info_rec_ind->redirecting_num_info.num_len,
                                                                                                            info_recs.infoRec[idx].rec.redir.redirectingNumber.buf,
                                                                                                            sizeof(info_recs.infoRec[idx].rec.redir.redirectingNumber.buf),
                                                                                                            info_rec_ind->redirecting_num_info.num_type);
      idx++;
    }

    QCRIL_LOG_INFO(".. line_control_valid %d", (int)info_rec_ind->line_control_valid);
    if ( info_rec_ind->line_control_valid && idx < max_ril_cdma_info_recs)
    {
      info_recs.infoRec[idx].name = RIL_CDMA_LINE_CONTROL_INFO_REC;
      info_recs.infoRec[idx].rec.lineCtrl.lineCtrlPolarityIncluded = (char) info_rec_ind->line_control.polarity_included;
      info_recs.infoRec[idx].rec.lineCtrl.lineCtrlToggle = info_rec_ind->line_control.toggle_mode;
      info_recs.infoRec[idx].rec.lineCtrl.lineCtrlReverse = info_rec_ind->line_control.reverse_polarity;
      info_recs.infoRec[idx].rec.lineCtrl.lineCtrlPowerDenial = info_rec_ind->line_control.power_denial_time;
      idx++;
    }

    QCRIL_LOG_INFO(".. conn_num_info_valid %d", (int)info_rec_ind->conn_num_info_valid);
    if (info_rec_ind->conn_num_info_valid && idx < max_ril_cdma_info_recs)
    {
      info_recs.infoRec[idx].name = RIL_CDMA_CONNECTED_NUMBER_INFO_REC;
      info_recs.infoRec[idx].rec.number.number_plan = info_rec_ind->conn_num_info.num_plan;
      info_recs.infoRec[idx].rec.number.number_type = info_rec_ind->conn_num_info.num_type;
      info_recs.infoRec[idx].rec.number.pi = info_rec_ind->conn_num_info.pi;
      info_recs.infoRec[idx].rec.number.si = info_rec_ind->conn_num_info.si;
      info_recs.infoRec[idx].rec.number.len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->conn_num_info.num,
                                                                                           info_rec_ind->conn_num_info.num_len,
                                                                                           info_recs.infoRec[idx].rec.number.buf,
                                                                                           sizeof(info_recs.infoRec[idx].rec.number.buf),
                                                                                           info_rec_ind->conn_num_info.num_type);
      idx++;
    }

    QCRIL_LOG_INFO(".. called_party_info_valid %d", (int)info_rec_ind->called_party_info_valid);
    if (info_rec_ind->called_party_info_valid && idx < max_ril_cdma_info_recs)
    {
      info_recs.infoRec[idx].name = RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC;
      info_recs.infoRec[idx].rec.number.number_plan = info_rec_ind->called_party_info.num_plan;
      info_recs.infoRec[idx].rec.number.number_type = info_rec_ind->called_party_info.num_type;
      info_recs.infoRec[idx].rec.number.pi = info_rec_ind->called_party_info.pi;
      info_recs.infoRec[idx].rec.number.si = info_rec_ind->called_party_info.si;
      info_recs.infoRec[idx].rec.number.len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->called_party_info.num,
                                                                                           info_rec_ind->called_party_info.num_len,
                                                                                           info_recs.infoRec[idx].rec.number.buf,
                                                                                           sizeof(info_recs.infoRec[idx].rec.number.buf),
                                                                                           info_rec_ind->called_party_info.num_type);
      idx++;
    }

    QCRIL_LOG_INFO(".. signal_info_valid %d", (int)info_rec_ind->signal_info_valid );
    if( info_rec_ind->signal_info_valid )
    {
      signal_info_rec.isPresent = TRUE;
      signal_info_rec.signalType = (char)info_rec_ind->signal_info.signal_type;
      signal_info_rec.alertPitch = (char)info_rec_ind->signal_info.alert_pitch;
      signal_info_rec.signal = (char)info_rec_ind->signal_info.signal;
    }

    QCRIL_LOG_INFO(".. is waiting state %d, name changed %d, number changed %d  ",
        (int)call_is_in_call_waiting_state, (int)name_changed, (int)number_changed );

    if( call_is_in_call_waiting_state )
    {
      /* Fill in the Call Waiting information */
      call_waiting.number = number.buf;
      call_waiting.numberPresentation = number.pi;
      call_waiting.name = name;
      call_waiting.signalInfoRecord = signal_info_rec;
      call_waiting.number_type = number.number_type;
      call_waiting.number_plan = number.number_plan;

      QCRIL_LOG_INFO( "call is in waiting state. Number : %s; Number Presentation: %d; "
                      "Name : %s; Signal Info Rec.isPresent : %d; "
                      "Number type : %d; Number plan : %d;",
                      call_waiting.number,
                      call_waiting.numberPresentation,
                      call_waiting.name,
                      call_waiting.signalInfoRecord.isPresent,
                      call_waiting.number_type,
                      call_waiting.number_plan
                    );

      qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
          (int) RIL_UNSOL_CDMA_CALL_WAITING, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &call_waiting;
      unsol_resp.resp_len = sizeof( RIL_CDMA_CallWaiting );
      qcril_send_unsol_response( &unsol_resp );

      qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_DATA_ON_STACK,
                         QCRIL_EVT_QMI_VOICE_GET_WAITING_CALL,
                         &(info_rec_ind->call_id),
                         sizeof(info_rec_ind->call_id),
                         (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
    else
    {
      qcril_qmi_voice_voip_lock_overview();

      if ( info_rec_ind->caller_id_info_valid || info_rec_ind->caller_name_valid || info_rec_ind->calling_party_info_valid || info_rec_ind->clir_cause_valid)
      {
        //  workaround for unknown incoming call number in 3gpp2
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( info_rec_ind->call_id );
        if ( NULL == call_info_entry && info_rec_ind->call_id != 254 )
        { // fresh, this should be an incoming call and the info_rec_ind comes before all_call_status_ind
          // Create a call entry only if call_id is not 254 which is used by modem to indicate a unknown call type.
          call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
                  info_rec_ind->call_id,
                  INVALID_MEDIA_ID,
                  TRUE,
                  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING,
                  NULL );
          if(call_info_entry)
          {
            call_info_entry->ril_call_state = RIL_CALL_INCOMING;
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_RIL_CALL_STATE_VALID;
          }
        }
        else
        { // what we got?
          qcril_qmi_voice_voip_call_info_dump( call_info_entry );
        }

        if ( call_info_entry )
        {
          if ( info_rec_ind->caller_id_info_valid )
          {
            call_info_entry->voice_svc_remote_party_number.call_id = info_rec_ind->call_id;
            call_info_entry->voice_svc_remote_party_number.number_pi = info_rec_ind->caller_id_info.pi;

            QCRIL_LOG_INFO(".. store caller id in call obj" );

            uint32_t number_len = qcril_qmi_voice_call_num_copy_with_toa_check(info_rec_ind->caller_id_info.caller_id,
                                                                               info_rec_ind->caller_id_info.caller_id_len,
                                                                               call_info_entry->voice_svc_remote_party_number.number,
                                                                               QMI_VOICE_NUMBER_MAX_V02,
                                                                               (info_rec_ind->calling_party_info_valid) ? info_rec_ind->calling_party_info.num_type : QMI_VOICE_NUM_TYPE_UNKNOWN_V02);
            call_info_entry->voice_svc_remote_party_number.number_len = number_len;

            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;

            qcril_qmi_voice_consider_shadow_remote_number_cpy_creation( call_info_entry );

            if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING )
            {
              call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;
              need_reset_1x_num_wait_tmr = TRUE;
            }

          }
          else if ( info_rec_ind->calling_party_info_valid )
          {
            call_info_entry->voice_svc_remote_party_number.call_id = info_rec_ind->call_id;
            call_info_entry->voice_svc_remote_party_number.number_pi = info_rec_ind->calling_party_info.pi;

            QCRIL_LOG_INFO(".. store calling_party_info in call obj" );

            uint32_t number_len = qcril_qmi_voice_call_num_copy_with_toa_check(
                                  info_rec_ind->calling_party_info.num,
                                  info_rec_ind->calling_party_info.num_len,
                                  call_info_entry->voice_svc_remote_party_number.number,
                                  QMI_VOICE_NUMBER_MAX_V02,
                                  info_rec_ind->calling_party_info.num_type);
            call_info_entry->voice_svc_remote_party_number.number_len = number_len;

            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;

            qcril_qmi_voice_consider_shadow_remote_number_cpy_creation (call_info_entry );

            if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING )
            {
              call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;
              need_reset_1x_num_wait_tmr = TRUE;
            }

          }

          if ( info_rec_ind->caller_name_valid && !ignore_caller_name)
          {
            QCRIL_LOG_INFO(".. store caller name in call obj" );

            call_info_entry->voice_svc_remote_party_name.call_id = info_rec_ind->call_id;
            call_info_entry->voice_svc_remote_party_name.name_pi = PRESENTATION_NAME_PRESENTATION_ALLOWED_V02; // set to Allowed Presentation
            // convert ascii to utf8
            call_info_entry->voice_svc_remote_party_name.name_len = qcril_cm_ss_ascii_to_utf8((unsigned char*) info_rec_ind->caller_name,
                                                                                              strlen(info_rec_ind->caller_name),
                                                                                              call_info_entry->voice_svc_remote_party_name.name,
                                                                                              sizeof(call_info_entry->voice_svc_remote_party_name.name));
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NAME_VALID;
          }

          if ( info_rec_ind->clir_cause_valid )
          {
            if((!info_rec_ind->calling_party_info_valid) && (info_rec_ind->clir_cause == 0))
            {
              call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_NUM_UNAVAILABLE_V02; // default value
            }
            else
            {
              switch((uint8)info_rec_ind->clir_cause)
              {
                case QMI_VOICE_CLIR_CAUSE_NO_CAUSE_V02:
                  call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_ALLOWED_V02;
                  break;
                case QMI_VOICE_CLIR_CAUSE_REJECTED_BY_USER_V02:
                  call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_RESTRICTED_V02;
                  break;
                case QMI_VOICE_CLIR_CAUSE_COIN_LINE_V02:
                  call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_PAYPHONE_V02;
                  break;
                default:
                  call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_NUM_UNAVAILABLE_V02;
                  break;
               }
              QCRIL_LOG_INFO("Mapped Clir=%d, PI=%d",info_rec_ind->clir_cause,call_info_entry->voice_svc_remote_party_number.number_pi );
            }
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;

            qcril_qmi_voice_consider_shadow_remote_number_cpy_creation( call_info_entry );

            if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING )
            {
              call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING;
              need_reset_1x_num_wait_tmr = TRUE;
            }

            QCRIL_LOG_INFO( "clir_cause_valid voice_svc_remote_party_number.number_pi = %d",
                            call_info_entry->voice_svc_remote_party_number.number_pi);
          }

          qcril_qmi_voice_voip_call_info_dump( call_info_entry );
        }
        else
        {
          QCRIL_LOG_ERROR("call_info_entry is NULL");
        }
      }
      else
      {
        QCRIL_LOG_INFO("both caller_id_info and caller_name are not valid");
      }

      qcril_qmi_voice_voip_unlock_overview();
    }

    QCRIL_LOG_INFO(".. signal_info_valid %d", (int)info_rec_ind->signal_info_valid );
    if( info_rec_ind->signal_info_valid )
    {
      QCRIL_LOG_INFO("signal_info signal_type: %d, alert_pitch: %d, signal: %d", info_rec_ind->signal_info.signal_type,
                     info_rec_ind->signal_info.alert_pitch, info_rec_ind->signal_info.signal);

      qcril_qmi_voice_voip_lock_overview();

      if ( call_is_in_call_waiting_state )
      { // there must be call waiting obj already
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state( RIL_CALL_WAITING );
      }
      else
      { // expecting call obj in coming state
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state( RIL_CALL_INCOMING );
      }
      QCRIL_LOG_INFO(".. call obj %p", call_info_entry );
      if ( call_info_entry )
      {
        qcril_qmi_voice_voip_call_info_dump( call_info_entry );
        call_info_entry->elaboration |= ( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING | QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_RING_DONE );

        QCRIL_LOG_INFO(".. launch ringer" );
        info_rec_pass_over = (RIL_CDMA_SignalInfoRecord*)qcril_malloc( sizeof( *info_rec_pass_over ) );
        if ( info_rec_pass_over )
        {
          *info_rec_pass_over = signal_info_rec;

          qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_voice_make_incoming_call_ring,
                                                info_rec_pass_over,
                                                TRUE,
                                                NULL,   // immediate
                                                NULL );
        }
        else
        { // rollback
          call_info_entry->elaboration &= ~( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NEED_FOR_RING_PENDING | QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_RING_DONE );
        }
      }
      else if (idx < max_ril_cdma_info_recs)
      { // neither a waiting call nor an incoming call
        info_recs.infoRec[idx].name = RIL_CDMA_SIGNAL_INFO_REC;
        info_recs.infoRec[idx].rec.signal.isPresent = TRUE;
        info_recs.infoRec[idx].rec.signal.signalType = (char)info_rec_ind->signal_info.signal_type;
        info_recs.infoRec[idx].rec.signal.alertPitch = (char)info_rec_ind->signal_info.alert_pitch;
        info_recs.infoRec[idx].rec.signal.signal = (char)info_rec_ind->signal_info.signal;
        idx++;
      }
      qcril_qmi_voice_voip_unlock_overview();
    }

    info_recs.numberOfInfoRecs = idx;
    QCRIL_LOG_INFO( ".. number of info recs to be sent in event is %d", info_recs.numberOfInfoRecs);
    for (iter_idx = 0; iter_idx < info_recs.numberOfInfoRecs; iter_idx++)
    {
      QCRIL_LOG_INFO( ".. .. rec# %d, name %d ", iter_idx, (int)info_recs.infoRec[ iter_idx ].name );
    }

    if (number_changed || name_changed)
    {
      qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
    }

    if ( idx > 0 )
    {
      /* If there are any info recs remaining after extracting the name, number
         and signal info, send them to the UI. */
      qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_CDMA_INFO_REC, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &info_recs;
      unsol_resp.resp_len = sizeof( RIL_CDMA_InformationRecords );
      qcril_send_unsol_response( &unsol_resp );
    }

    if ( need_reset_1x_num_wait_tmr )
    {
      qcril_qmi_voice_voip_lock_overview();
      qcril_qmi_voice_cancel_num_1x_wait_timer();
      qcril_qmi_voice_voip_unlock_overview();
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_info_rec_ind_hdlr

//===========================================================================
// qcril_qmi_voice_map_ril_error_to_stk_cc_modification_type
//===========================================================================
qcril_qmi_voice_stk_cc_modification_e_type
qcril_qmi_voice_map_ril_error_to_stk_cc_modification_type(int ril_err)
{
  qcril_qmi_voice_stk_cc_modification_e_type ret = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE;

  switch (ril_err)
  {
    case RIL_E_DIAL_MODIFIED_TO_DIAL:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_TO_DIAL;
      break;
    case RIL_E_DIAL_MODIFIED_TO_DIAL_VIDEO:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_TO_DIAL_VIDEO;
      break;
    case RIL_E_DIAL_MODIFIED_TO_USSD:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_TO_USSD;
      break;
    case RIL_E_DIAL_MODIFIED_TO_SS:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_TO_SS;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_VIDEO_TO_DIAL;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_VIDEO_TO_DIAL_VIDEO;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_USSD:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_VIDEO_TO_USSD;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_SS:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_DIAL_VIDEO_TO_SS;
      break;
    case RIL_E_SS_MODIFIED_TO_DIAL:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_SS_TO_DIAL;
      break;
    case RIL_E_SS_MODIFIED_TO_DIAL_VIDEO:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_SS_TO_DIAL_VIDEO;
      break;
    case RIL_E_SS_MODIFIED_TO_USSD:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_SS_TO_USSD;
      break;
    case RIL_E_SS_MODIFIED_TO_SS:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_SS_TO_SS;
      break;
    case RIL_E_USSD_MODIFIED_TO_DIAL:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_USSD_TO_DIAL;
      break;
    case RIL_E_USSD_MODIFIED_TO_DIAL_VIDEO:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_USSD_TO_DIAL_VIDEO;
      break;
    case RIL_E_USSD_MODIFIED_TO_USSD:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_USSD_TO_USSD;
      break;
    case RIL_E_USSD_MODIFIED_TO_SS:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_USSD_TO_SS;
      break;
    default:
      ret  = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE;
      break;
  }
  return ret;
}

//===========================================================================
// qcril_qmi_voice_map_ril_error_to_stk_cc_call_fail_cause
//===========================================================================
int qcril_qmi_voice_map_ril_error_to_stk_cc_call_fail_cause(int ril_err)
{
  int ret = (int)CALL_FAIL_ERROR_UNSPECIFIED;

  switch (ril_err)
  {
    case RIL_E_DIAL_MODIFIED_TO_DIAL:
      ret  = (int)CALL_FAIL_DIAL_MODIFIED_TO_DIAL;
      break;
    case RIL_E_DIAL_MODIFIED_TO_DIAL_VIDEO:
      ret  = (int)QCRIL_CALL_FAIL_DIAL_MODIFIED_TO_DIAL_VIDEO;
      break;
    case RIL_E_DIAL_MODIFIED_TO_USSD:
      ret  = (int)CALL_FAIL_DIAL_MODIFIED_TO_USSD;
      break;
    case RIL_E_DIAL_MODIFIED_TO_SS:
      ret  = (int)CALL_FAIL_DIAL_MODIFIED_TO_SS;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL:
      ret  = (int)QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_DIAL;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
      ret  = (int)QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_USSD:
      ret  = (int)QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_USSD;
      break;
    case RIL_E_DIAL_VIDEO_MODIFIED_TO_SS:
      ret  = (int)QCRIL_CALL_FAIL_DIAL_VIDEO_MODIFIED_TO_SS;
      break;
    default:
      ret  = (int)CALL_FAIL_ERROR_UNSPECIFIED;
      break;
  }
  return ret;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_dial_call_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle DIAL_CALL_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_dial_call_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_dial_call_resp_msg_v02    *dial_call_resp = NULL;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  boolean destroy_call_info_entry = FALSE;

  int                            enforcing_stk_cc_emulation = FALSE;
  int                            ims_stk_cc_supported = TRUE;
  voice_alpha_ident_type_v02     emulation_transcoding_step1;
  char                           emulation_transcoding_final_buf[QMI_VOICE_ALPHA_TEXT_MAX_V02 + 2];
  int                            emulation_name_len;
  uint8                          original_android_call_id = VOICE_INVALID_CALL_ID;

  RIL_LastCallFailCause last_call_fail_cause = CALL_FAIL_ERROR_UNSPECIFIED;
  qcril_qmi_voice_stk_cc_modification_e_type stk_cc_modification;

  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type oversight_exec_event;

  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry_final;


  qcril_qmi_voice_voip_lock_overview();

  call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP, TRUE );

  QCRIL_LOG_INFO( "call_info_entry %p", call_info_entry );

  if( NULL != params_ptr->data && NULL != call_info_entry )
  {
    dial_call_resp = (voice_dial_call_resp_msg_v02    *)params_ptr->data;
    qmi_result = dial_call_resp->resp.result;
    qmi_error = dial_call_resp->resp.error;

    qmi_ril_err_context_e_type err_ctx_type = QCRIL_QMI_ERR_CTX_DIAL_TXN;
    if (call_info_entry->voice_scv_info.call_type == CALL_TYPE_VT_V02 ||
        call_info_entry->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_VT_V02)
    {
      err_ctx_type = QCRIL_QMI_ERR_CTX_DIAL_VIDEO_TXN;
    }

    original_android_call_id = call_info_entry->android_call_id;

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(QMI_NO_ERR,
                                                                        &dial_call_resp->resp,
                                                                        err_ctx_type,
                                                                        dial_call_resp);
    if(qmi_error == QMI_ERR_INVALID_ID_V01 && ril_err == RIL_E_MODEM_ERR)
    {
      //handle specific QMI error
      ril_err = RIL_E_INVALID_CALL_ID;
    }


    QCRIL_LOG_INFO("DIAL CALL RESP : ril_err=%d, dial_call_resp_result=%d, dial_call_resp_error=%d, cc_sups_result_valid=%d, cc_result_type_valid=%d, cc_result_type=%d ",
                   (int)ril_err,
                   (int)dial_call_resp->resp.result,
                   (int)dial_call_resp->resp.error,
                   (int)dial_call_resp->cc_sups_result_valid,
                   (int)dial_call_resp->cc_result_type_valid,
                   (int)dial_call_resp->cc_result_type
                   );

    switch ( (int)ril_err )
    {
      case RIL_E_SUCCESS:
      case RIL_E_DIAL_MODIFIED_TO_DIAL:
      case RIL_E_DIAL_MODIFIED_TO_DIAL_VIDEO:
      case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL:
      case RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
        call_info_entry->qmi_call_id = dial_call_resp->call_id;

        if(dial_call_resp->media_id_valid)
        {
          call_info_entry->media_id = dial_call_resp->media_id;
        }
        else
        {
          call_info_entry->media_id = INVALID_MEDIA_ID;
        }
        QCRIL_LOG_INFO( "call qmi id recorded %d", (int)call_info_entry->qmi_call_id );
        break;

      default:
        qcril_qmi_voice_respond_pending_hangup_ril_response(call_info_entry->qmi_call_id);
        destroy_call_info_entry = TRUE;
        break;
    }

    // compatibility checks: what is platform does not support STK CC
    enforcing_stk_cc_emulation = FALSE;
    if (qcril_qmi_voice_call_to_ims (call_info_entry) && !ims_stk_cc_supported)
    { // IMS case
      // IMS currently does not support STK CC, need so see if need to setup overlays for STK CC'ed IMS call
       if ( RIL_E_DIAL_MODIFIED_TO_DIAL == ril_err )
       {
          enforcing_stk_cc_emulation = TRUE;
          qcril_qmi_voice_voip_call_info_set_single_elaboration( call_info_entry, QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_STK_CC_EMULATED_OVERLAY, TRUE  );
          QCRIL_LOG_INFO( ".. establishing STK CC overlay for IMS MO call, android call id %d", call_info_entry->android_call_id );

          ril_err                    = RIL_E_SUCCESS; // we pretend the life is good
       }
    } // end IMS case

    if( RIL_E_SUCCESS != ril_err && dial_call_resp->cc_sups_result_valid )
    {
      QCRIL_LOG_INFO("Error Details : cc_sups_result_reason=%d, cc_sups_result_service=%d",
                      dial_call_resp->cc_sups_result.reason,
                      dial_call_resp->cc_sups_result.service_type);

    }
    stk_cc_modification = qcril_qmi_voice_map_ril_error_to_stk_cc_modification_type((int)ril_err);
    last_call_fail_cause = (RIL_LastCallFailCause)
              qcril_qmi_voice_map_ril_error_to_stk_cc_call_fail_cause((int)ril_err);

    if ( !enforcing_stk_cc_emulation )
    { // default case: STK CC is support by Android framework
       if ( CALL_FAIL_ERROR_UNSPECIFIED != last_call_fail_cause )
       {  // STK CC session started
            qcril_qmi_voice_reset_stk_cc();

            stk_cc_info.modification                      = stk_cc_modification;
            stk_cc_info.is_alpha_relayed                  = FALSE;

            if (params_ptr->event_id == QCRIL_EVT_IMS_SOCKET_REQ_DIAL)
            {
              stk_cc_info.is_ims_request = TRUE;
            }

            if ( dial_call_resp->call_id_valid )
            {
              stk_cc_info.call_id_info      = dial_call_resp->call_id;
            }

            if ( dial_call_resp->cc_sups_result_valid )
            {
              stk_cc_info.ss_ussd_info = dial_call_resp->cc_sups_result;
            }

            if ( dial_call_resp->alpha_ident_valid )
            {
              if ( ALPHA_DCS_UCS2_V02 == dial_call_resp->alpha_ident.alpha_dcs )
              {
                qcril_qmi_voice_transfer_sim_ucs2_alpha_to_std_ucs2_alpha(&dial_call_resp->alpha_ident, &stk_cc_info.alpha_ident);
              }
              else
              {
                stk_cc_info.alpha_ident = dial_call_resp->alpha_ident;
              }
            }
            else
            {
              memset( &stk_cc_info.alpha_ident, 0, sizeof( stk_cc_info.alpha_ident ) );
            }
       } // if ( CALL_FAIL_ERROR_UNSPECIFIED != last_call_fail_cause )
    } // if (!enforcing_stk_cc_emulation)
    else
    { // enforcing STK CC emulation as STK CC is not supported by Android framework: need to store alpha as overlay name

       memset( emulation_transcoding_final_buf, 0 , sizeof(emulation_transcoding_final_buf) );

       if ( dial_call_resp->alpha_ident_valid )
       {
         // make use after converting to utf8
         // step 1 out of 2: to ucs2
         if ( ALPHA_DCS_UCS2_V02 == dial_call_resp->alpha_ident.alpha_dcs )
         {
            qcril_qmi_voice_transfer_sim_ucs2_alpha_to_std_ucs2_alpha( &dial_call_resp->alpha_ident, &emulation_transcoding_step1 );
         }
         else
         {
            emulation_transcoding_step1 = dial_call_resp->alpha_ident;
         }
         // step 2 out of 2: to utf8
         switch ( emulation_transcoding_step1.alpha_dcs )
         {
            case ALPHA_DCS_GSM_V02:
              if  (stk_cc_info.alpha_ident.alpha_text_len < QMI_VOICE_ALPHA_TEXT_MAX_V02)
              {
                  qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (char*) emulation_transcoding_step1.alpha_text,
                                                                    emulation_transcoding_step1.alpha_text_len,
                                                                    emulation_transcoding_final_buf,
                                                                    sizeof(emulation_transcoding_final_buf));
              }
             break;

            case ALPHA_DCS_UCS2_V02:
               qcril_cm_ss_convert_ucs2_to_utf8( (char *) emulation_transcoding_step1.alpha_text,
                                                          emulation_transcoding_step1.alpha_text_len * 2,
                                                          emulation_transcoding_final_buf,
                                                          sizeof(emulation_transcoding_final_buf));
             break;

            default:
               // nothing
               break;
         } // switch ( emulation_transcoding_step1.alpha_dcs )

         if ( *emulation_transcoding_final_buf )
         {
            if ( NULL != call_info_entry->overlayed_name_storage_for_emulated_stk_cc )
            {
               qcril_free( call_info_entry->overlayed_name_storage_for_emulated_stk_cc );
            }
            emulation_name_len = strlen( emulation_transcoding_final_buf );
            call_info_entry->overlayed_name_storage_for_emulated_stk_cc = (char*)qcril_malloc( emulation_name_len + 1 );
            if ( NULL != call_info_entry->overlayed_name_storage_for_emulated_stk_cc )
            {
               strlcpy( call_info_entry->overlayed_name_storage_for_emulated_stk_cc, emulation_transcoding_final_buf, emulation_name_len + 1 );

               QCRIL_LOG_INFO( ".. established STK CC emulated overlay name %s, android call id %d",
                                    call_info_entry->overlayed_name_storage_for_emulated_stk_cc,
                                    call_info_entry->android_call_id );
            } // if ( NULL != call_info_entry->overlayed_name_storage_for_emulated_stk_cc )
         } // if ( *emulation_transcoding_final_buf )
       } // if ( dial_call_resp->alpha_ident_valid )
    } // else-if: enforcing STK CC emulation as STK CC is not supported by Android framework: need to store alpha as overlay name

    QCRIL_LOG_INFO( "DIAL CALL RESP COMPLETE received with result %d for call id %d", (int)ril_err, (int)dial_call_resp->call_id );

    qcril_qmi_voice_stk_cc_dump();
  } // if( NULL != params_ptr->data && NULL != call_info_entry )
  else
  {  // fault
    if ( NULL != call_info_entry )
    {
      ril_err = RIL_E_SYSTEM_ERR; //params->data is NULL
      qcril_qmi_voice_voip_destroy_call_info_entry( call_info_entry );
      call_info_entry = NULL;
    }
    else if(call_info_entry == NULL)
    {
      ril_err = RIL_E_INVALID_STATE;
    }
  }

  if ( RIL_E_FDN_CHECK_FAILURE == ril_err )
  {
    qcril_qmi_voice_handle_new_last_call_failure_cause(CALL_FAIL_FDN_BLOCKED,
        FALSE, FALSE, 0, FALSE, 0, FALSE, NULL, call_info_entry);
  }
  else
  {
    if (last_call_fail_cause == CALL_FAIL_ERROR_UNSPECIFIED && dial_call_resp && dial_call_resp->end_reason_valid)
    {
      qcril_qmi_voice_handle_new_last_call_failure_cause(dial_call_resp->end_reason,
            TRUE, FALSE, 0, FALSE, 0, FALSE, NULL, call_info_entry);
    }
    else
    {
      qcril_qmi_voice_handle_new_last_call_failure_cause(last_call_fail_cause,
            FALSE, FALSE, 0, FALSE, 0, FALSE, NULL, call_info_entry);
    }
  }

  memset( &oversight_exec_event, 0, sizeof( oversight_exec_event ) );
  oversight_exec_event.locator.elaboration_pattern = QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP;

  if ( NULL != call_info_entry )
  { // dial failed or dial modified by STK CC to SS or USSD
    if (RIL_E_SUCCESS != ril_err &&
        (RIL_E_DIAL_MODIFIED_TO_DIAL != ril_err &&
         RIL_E_DIAL_MODIFIED_TO_DIAL_VIDEO != ril_err &&
         RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL != ril_err &&
         RIL_E_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO != ril_err))
     {
       // Failure: reset alternative emergency call info
       if (qcril_qmi_voice_voip_call_info_is_single_elaboration_set(call_info_entry,
             QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_ALTERNATE_EMERGENCY_CALL))
       {
           qmi_ril_reset_alternate_emergency_call_info();
       }
       qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_ABANDON,
                                                         QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN,
                                                         &oversight_exec_event );
       if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING)
       {
           call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
       }
       qcril_send_empty_payload_request_response(instance_id, params_ptr->t, params_ptr->event_id, ril_err);
       if (call_info_entry && qcril_qmi_voice_call_to_ims(call_info_entry))
       {
           call_info_entry->voice_scv_info.call_state = CALL_STATE_END_V02;
           qcril_qmi_voice_send_ims_unsol_call_state_changed();
           // send_ims_unsol_call_state_changed will ensure destroying the
           // call info entry after reporting call state END to telephony.
           destroy_call_info_entry = FALSE;
       }
     }
     else
     {
       oversight_exec_event.successful_response_payload = ril_err;
       oversight_exec_event.successful_response_payload_len = sizeof(ril_err);
       qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_SUCCESS,
                                                         QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN,
                                                         &oversight_exec_event );
     }
  } // NULL != call_info_entry

  if ( !enforcing_stk_cc_emulation && NULL != dial_call_resp && VOICE_INVALID_CALL_ID != original_android_call_id )
  { // if no STK CC emulation, do cleanup of whatever overlay preserved till now
     call_info_entry_final = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id ( original_android_call_id );
     if ( NULL != call_info_entry_final )
     {
        if ( NULL != call_info_entry_final->overlayed_number_storage_for_emulated_stk_cc )
        {
           qcril_free( call_info_entry_final->overlayed_number_storage_for_emulated_stk_cc );
           call_info_entry_final->overlayed_number_storage_for_emulated_stk_cc = NULL;
        }
        if ( NULL != call_info_entry_final->overlayed_name_storage_for_emulated_stk_cc )
        {
           qcril_free( call_info_entry_final->overlayed_name_storage_for_emulated_stk_cc );
           call_info_entry_final->overlayed_name_storage_for_emulated_stk_cc = NULL;
        }
     }
  } // if ( !enforcing_stk_cc_emulation && NULL != dial_call_resp && VOICE_INVALID_CALL_ID != original_android_call_id )

  if ( destroy_call_info_entry && NULL != dial_call_resp && VOICE_INVALID_CALL_ID != original_android_call_id )
  {

      call_info_entry_final = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id ( original_android_call_id );
      qcril_qmi_voice_voip_destroy_call_info_entry( call_info_entry_final );
  } // if ( destroy_call_info_entry && NULL != dial_call_resp && VOICE_INVALID_CALL_ID != original_android_call_id )

  qcril_qmi_voice_voip_unlock_overview();

  if (qcril_qmi_voice_voip_call_info_entries_is_empty())
  {
      QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
      if (!qcril_stop_diag_log())
      {
          QCRIL_LOG_INFO("qxdm logging disabled successfully");
      }
  }

  QCRIL_LOG_FUNC_RETURN();

} /* qcril_qmi_voice_dial_call_resp_hdlr */

//===========================================================================
// qcril_qmi_voice_answer_call_resp_hdlr
//===========================================================================
void qcril_qmi_voice_answer_call_resp_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qmi_client_error_type                  transp_err
)
{
  voice_answer_call_resp_msg_v02  *ans_call_resp;
  RIL_Errno ril_err;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;

  qcril_qmi_voice_voip_call_info_entry_type*  call_info_entry = NULL;
  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type oversight_event_params;
  qmi_ril_voice_ims_command_exec_oversight_type *command_oversight;
  int covered_by_oversight_handling;

  QCRIL_LOG_FUNC_ENTRY();

  ans_call_resp = (voice_answer_call_resp_msg_v02*) params_ptr->data;
  if ( NULL != ans_call_resp )
  {
    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &ans_call_resp->resp );
    QCRIL_LOG_INFO( ".. transp err %d, resp err %d, ril err %d", (int)transp_err, (int)ans_call_resp->resp.error, (int)ril_err );
    QCRIL_LOG_INFO( ".. call id valid %d, call id %d", (int)ans_call_resp->call_id_valid, (int)ans_call_resp->call_id );

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, TRUE );
    QCRIL_LOG_INFO( ".. call info entry %p", call_info_entry );

    qmi_result = ans_call_resp->resp.result;
    qmi_error = ans_call_resp->resp.error;
    covered_by_oversight_handling = FALSE;
    if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
    {
      //handle specific error case
      ril_err = RIL_E_INVALID_CALL_ID;
    }
    qcril_qmi_voice_voip_lock_overview();
    command_oversight = qmi_ril_voice_ims_find_command_oversight_by_token (params_ptr->t);
    if (NULL != command_oversight)
    {
        memset (&oversight_event_params, 0, sizeof (oversight_event_params));
        oversight_event_params.locator.command_oversight = command_oversight;
        covered_by_oversight_handling = qmi_ril_voice_ims_command_oversight_handle_event
                                        (
                                           (QMI_RESULT_SUCCESS_V01 == qmi_result && QMI_ERR_NONE_V01 == qmi_error)?
                                           QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_SUCCESS :
                                           QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_FAILURE,
                                           QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                           &oversight_event_params
                                        );
    } // if (NULL != command_oversight)
    qcril_qmi_voice_voip_unlock_overview();

    if (( NULL == command_oversight) || (!covered_by_oversight_handling))
    {
        if ( NULL != call_info_entry )
        {
            call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL;
            if (RIL_E_SUCCESS == ril_err)
            {
               call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING;
            }
        }

        if (RIL_E_SUCCESS != ril_err)
        {
            if (QCRIL_EVT_IMS_SOCKET_REQ_ANSWER == params_ptr->event_id)
            {
#ifndef QMI_RIL_UTF
                qcril_am_handle_event(QCRIL_AM_EVENT_IMS_ANSWER_FAIL, NULL);
#endif
            }
            else
            {
#ifndef QMI_RIL_UTF
                qcril_am_handle_event(QCRIL_AM_EVENT_VOICE_ANSWER_FAIL, NULL);
#endif
            }
        }

        qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_err);
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_answer_call_resp_hdlr

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_end_call_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle END_CALL_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_end_call_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_end_call_resp_msg_v02  *end_call_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();

  if( params_ptr->data != NULL )
  {
    end_call_resp = (voice_end_call_resp_msg_v02 *)params_ptr->data;
    qmi_result = end_call_resp->resp.result;
    qmi_error = end_call_resp->resp.error;

    if(qmi_result == QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_INFO("END CALL RESP SUCCESS received with call id %d",end_call_resp->call_id);
      qcril_qmi_voice_voip_lock_overview();
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( end_call_resp->call_id );
      if ( NULL != call_info_entry && CALL_STATE_END_V02 != call_info_entry->voice_scv_info.call_state)
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_HANGUP_RESP;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER;
        call_info_entry->pending_end_call_req_tid = params_ptr->t;
      }
      else
      {
        QCRIL_LOG_DEBUG("Didn't have call id %d in the call entry list", end_call_resp->call_id);
        qcril_qmi_send_hangup_response(params_ptr->event_id, params_ptr->t, RIL_E_SUCCESS);
      }
      qcril_qmi_voice_voip_unlock_overview();
    }
    else
    {
      QCRIL_LOG_INFO("END CALL RESP FAILURE received with error %d",qmi_error);

      if(qmi_error == QMI_ERR_MALFORMED_MSG_V01 && !hangup_retry_attempted)
      {
        //resend the hangup request without the optional tlv
        ril_err = qcril_qmi_voice_retry_call_end(params_ptr->t,
                                                 params_ptr->event_id);

        hangup_retry_attempted = TRUE;

        if(ril_err != RIL_E_SUCCESS)
        {
          qcril_qmi_send_hangup_response(params_ptr->event_id, params_ptr->t, ril_err);
        }
      }
      else
      {
        ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
        if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
        {
          //handle specific error case
          ril_err = RIL_E_INVALID_CALL_ID;
        }
        qcril_qmi_send_hangup_response(params_ptr->event_id, params_ptr->t, ril_err);
      }
    }
  }
  else
  {
    ril_err = RIL_E_SYSTEM_ERR;
    qcril_qmi_send_hangup_response(params_ptr->event_id, params_ptr->t, ril_err);
  }


} /* qcril_qmi_voice_end_call_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_burst_dtmf_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle BURST_DTMF_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_burst_dtmf_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_burst_dtmf_resp_msg_v02  *burst_dtmf_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {
  burst_dtmf_resp = (voice_burst_dtmf_resp_msg_v02 *)params_ptr->data;
  qmi_result = burst_dtmf_resp->resp.result;
  qmi_error = burst_dtmf_resp->resp.error;

  if(qmi_result == QMI_RESULT_SUCCESS_V01)
  {
    QCRIL_LOG_INFO("BURST DTMF RESP SUCCESS received with call id %d", burst_dtmf_resp->call_id);
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_INFO("BURST DTMF RESP FAILURE received with error %d",qmi_error);
    ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
    if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
    {
      //handle specific error
      ril_err = RIL_E_INVALID_CALL_ID;
    }

    /* Send FAILURE response */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
    qcril_send_request_response( &resp );
  }
} /* qcril_qmi_voice_burst_dtmf_resp_hdlr */

static void qcril_qmi_voice_ims_req_dtmf_stop_tmr_handler (qcril_timed_callback_handler_params_type *handler_params)
{
  qcril_instance_id_e_type instance_id;
  RIL_Token t;

  QCRIL_LOG_FUNC_ENTRY();

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  t = (RIL_Token)handler_params->custom_param;

  qcril_event_queue( instance_id, QCRIL_DEFAULT_MODEM_ID,
                     QCRIL_DATA_ON_STACK, QCRIL_EVT_IMS_SOCKET_REQ_STOP_CONT_DTMF, NULL,
                     VOICE_NIL, t );

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_ims_req_dtmf_stop_tmr_handler

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_start_cont_dtmf_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle START_CONT_DTMF_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_start_cont_dtmf_resp_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_evt_e_type pending_event
)
{
  voice_start_cont_dtmf_resp_msg_v02  *start_cont_dtmf_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  struct timeval  tmr_delay_ims_req_dtmf_stop;

  tmr_delay_ims_req_dtmf_stop.tv_sec = QMI_RIL_ZERO;
  tmr_delay_ims_req_dtmf_stop.tv_usec = dtmf_rtp_event_interval * 1000; /* default: 85ms * 1000 */


  qcril_qmi_voice_info_lock();
  qcril_qmi_voice_info.pending_dtmf_req_id = QMI_RIL_ZERO;
  qcril_qmi_voice_info_unlock();

  if( params_ptr->data != NULL )
  {
    start_cont_dtmf_resp = (voice_start_cont_dtmf_resp_msg_v02 *)params_ptr->data;
    qmi_result = start_cont_dtmf_resp->resp.result;
    qmi_error = start_cont_dtmf_resp->resp.error;

    if(qmi_result == QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_INFO("START CONT DTMF RESP SUCCESS received with call id %d", start_cont_dtmf_resp->call_id);
      if(pending_event == QCRIL_EVT_QMI_VOICE_BURST_START_CONT_DTMF)
      {
        qcril_reqlist_free( params_ptr->instance_id, params_ptr->t );
        QCRIL_LOG_INFO("Queueing up STOP_CONT_DTMF request for completing simulation of BURST DTMF");
        if( QCRIL_EVT_RIL_REQUEST_DTMF == params_ptr->event_id )
        {
          qcril_event_queue( instance_id, QCRIL_DEFAULT_MODEM_ID,
                             QCRIL_DATA_ON_STACK, QCRIL_EVT_QMI_VOICE_BURST_STOP_CONT_DTMF, NULL,
                             VOICE_NIL, params_ptr->t );
        }
        else
        {
          qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_voice_ims_req_dtmf_stop_tmr_handler,
                                                params_ptr->t,
                                                &tmr_delay_ims_req_dtmf_stop,
                                                NULL );
        }
      }
      else
      {
        qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS );
      }
    }
    else
    {
      QCRIL_LOG_INFO("START CONT DTMF RESP FAILURE received with error %d",qmi_error);
      ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
      if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
      {
        //handle specific error
        ril_err = RIL_E_INVALID_CALL_ID;
      }
      /* Send FAILURE response */
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
    }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
} /* qcril_qmi_voice_start_cont_dtmf_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_stop_cont_dtmf_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle STOP_CONT_DTMF_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_stop_cont_dtmf_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_stop_cont_dtmf_resp_msg_v02  *stop_cont_dtmf_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  qcril_qmi_voice_info_lock();
  qcril_qmi_voice_info.pending_dtmf_req_id = QMI_RIL_ZERO;
  qcril_qmi_voice_info_unlock();

  if( params_ptr->data != NULL )
  {
    stop_cont_dtmf_resp = (voice_stop_cont_dtmf_resp_msg_v02 *)params_ptr->data;
    qmi_result = stop_cont_dtmf_resp->resp.result;
    qmi_error = stop_cont_dtmf_resp->resp.error;

    if(qmi_result == QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_INFO("STOP CONT DTMF RESP SUCCESS received with call id %d", stop_cont_dtmf_resp->call_id);
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS );
    }
    else
    {
      QCRIL_LOG_INFO("STOP CONT DTMF RESP FAILURE received with error %d",qmi_error);
      ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
      if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
      {
        //handle specific error
        ril_err = RIL_E_INVALID_CALL_ID;
      }
      /* Send FAILURE response */
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
    }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
} /* qcril_qmi_voice_stop_cont_dtmf_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_send_flash_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle SEND_FLASH_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_send_flash_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_send_flash_resp_msg_v02      *send_flash_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {
  send_flash_resp = (voice_send_flash_resp_msg_v02 *)params_ptr->data;
  qmi_result = send_flash_resp->resp.result;
  qmi_error = send_flash_resp->resp.error;

  if(qmi_result == QMI_RESULT_SUCCESS_V01)
  {
    QCRIL_LOG_INFO("SEND FLASH RESP SUCCESS received with call id %d", send_flash_resp->call_id);
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_INFO("SEND FLASH RESP FAILURE received with error %d",qmi_error);
    ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
    if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
    {
      //handle specific error
      ril_err = RIL_E_INVALID_CALL_ID;
    }

    /* Send FAILURE response */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
    qcril_send_request_response( &resp );
  }
} /* qcril_qmi_voice_send_flash_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_ims_call_cancel_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle CANCEL_MODIFY_CALL_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_ims_call_cancel_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_ims_call_cancel_resp_msg_v02 *cancel_modify_call_resp;
  RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
  qmi_result_type_v01 qmi_result = QMI_RESULT_FAILURE_V01;
  qmi_error_type_v01  qmi_error = QMI_ERR_NONE_V01;

  if( params_ptr->data != NULL )
  {
    cancel_modify_call_resp = (voice_ims_call_cancel_resp_msg_v02 *)params_ptr->data;
    qmi_result = cancel_modify_call_resp->resp.result;
    qmi_error = cancel_modify_call_resp->resp.error;

    if(qmi_result == QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_INFO("CANCEL MODIFY CALL SUCCESS received with call id %d",
                                cancel_modify_call_resp->call_id);
      imsRadioSendMessage(params_ptr->t,
                                ims_MsgType_RESPONSE,
                                ims_MsgId_REQUEST_CANCEL_MODIFY_CALL,
                                ims_Error_E_SUCCESS,
                                NULL,
                                0);
    }
    else
    {
      QCRIL_LOG_INFO("CANCEL MODIFY CALL RESP FAILURE received with error %d",qmi_error);
      ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
      imsRadioSendMessage(params_ptr->t,
                                ims_MsgType_RESPONSE,
                                ims_MsgId_REQUEST_CANCEL_MODIFY_CALL,
                                qcril_qmi_ims_map_ril_error_to_ims_error(ril_err),
                                NULL,
                                0);
    }
  }
  else
  {
    imsRadioSendMessage(params_ptr->t,
                              ims_MsgType_RESPONSE,
                              ims_MsgId_REQUEST_CANCEL_MODIFY_CALL,
                              qcril_qmi_ims_map_ril_error_to_ims_error(RIL_E_SYSTEM_ERR),
                              NULL,
                              0);
  }
} /* qcril_qmi_voice_ims_call_cancel_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_set_supp_svc_notification_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Set Supps Notification Request.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_set_supp_svc_notification_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_indication_register_resp_msg_v02      *set_supp_svc_notification_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  if( params_ptr->data != NULL )
  {
    set_supp_svc_notification_resp = (voice_indication_register_resp_msg_v02 *)params_ptr->data;
    qmi_result = set_supp_svc_notification_resp->resp.result;
    qmi_error = set_supp_svc_notification_resp->resp.error;

    if(qmi_result == QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_INFO("Set Supps SVC notification RESP: SUCCESS");
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS );
    }
    else
    {
      QCRIL_LOG_INFO("Set Supps SVC notification RESP:FAILURE received with error %d",qmi_error);
      ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
      /* Send FAILURE response */
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
    }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
} /* qcril_qmi_voice_set_supp_svc_notification_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_ussd_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handle USSD Indications.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_ussd_ind_hdlr
(
void *ind_data_ptr,
uint32 ind_data_len
)
{
  qcril_instance_id_e_type instance_id=QCRIL_DEFAULT_INSTANCE_ID;
  char ussd_utf8_str[QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2];
  char *response[ 2 ];
  char type_code[ 2 ];
  int utf8_len = 0;
  uint8 uss_dcs=QCRIL_QMI_VOICE_USSD_DCS_UNSPECIFIED;
  qcril_unsol_resp_params_type unsol_resp;
  voice_ussd_ind_msg_v02  *ussd_ind;
  further_user_action_enum_v02 notification_type;
  boolean success=TRUE;
  int i=0;
  QCRIL_NOTUSED(ind_data_len);

  QCRIL_LOG_FUNC_ENTRY();

  if( ind_data_ptr != NULL )
  {
    ussd_ind = (voice_ussd_ind_msg_v02*)ind_data_ptr;
    notification_type = ussd_ind->notification_type;
    memset( ussd_utf8_str, '\0', sizeof( ussd_utf8_str ) );

    QCRIL_LOG_INFO ("ind_data_ptr is not NULL");

    switch(notification_type)
    {
      case FURTHER_USER_ACTION_REQUIRED_V02:
        qcril_qmi_voice_info.ussd_user_action_required = TRUE;
        break;
      case FURTHER_USER_ACTION_NOT_REQUIRED_V02 :
        qcril_qmi_voice_info.ussd_user_action_required = FALSE;
        break;
      default :
        break;
    }

    if( TRUE == ussd_ind->uss_info_valid || TRUE == ussd_ind->uss_info_utf16_valid )
    {
      if ( TRUE == ussd_ind->uss_info_utf16_valid ) // using uss_info_utf16 instead of uss_info if it is available
      {
        utf8_len = qcril_cm_ss_convert_ucs2_to_utf8( (char *) ussd_ind->uss_info_utf16, ussd_ind->uss_info_utf16_len * 2, ussd_utf8_str, sizeof(ussd_utf8_str) );

        for(i=0 ; i< utf8_len ; i++ )
        {
          QCRIL_LOG_DEBUG ("utf8 data bytes : %x ", ussd_utf8_str[ i ]);
        }
        if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
        {
          QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
          utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
          ussd_utf8_str[ utf8_len - 1] = '\0';
        }
      }
      else
      {
        switch(ussd_ind->uss_info.uss_dcs)
        {
          case USS_DCS_ASCII_V02 :
            if( ussd_ind->uss_info.uss_data_len < QMI_VOICE_USS_DATA_MAX_V02 )
            {
              qcril_cm_ss_ascii_to_utf8((unsigned char *)ussd_ind->uss_info.uss_data, ussd_ind->uss_info.uss_data_len,
                                      ussd_utf8_str, sizeof(ussd_utf8_str));
            }
            break;
          case USS_DCS_8BIT_V02 :
            uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_8_BIT;
            utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( uss_dcs,
                                                                ussd_ind->uss_info.uss_data,
                                                                ussd_ind->uss_info.uss_data_len,
                                                                ussd_utf8_str,
                                                                sizeof(ussd_utf8_str));
            if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
            {
              QCRIL_LOG_ERROR ( "ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR" );
              utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
              ussd_utf8_str[ utf8_len - 1] = '\0';
            }
            break;
          case USS_DCS_UCS2_V02 :
            uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_UCS2;
            utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( uss_dcs,
                                                                ussd_ind->uss_info.uss_data,
                                                                ussd_ind->uss_info.uss_data_len,
                                                                ussd_utf8_str,
                                                                sizeof(ussd_utf8_str));
            if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
            {
              QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
              utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
              ussd_utf8_str[ utf8_len - 1] = '\0';
            }
            break;
          default :
            QCRIL_LOG_ERROR ("Invalid USSD dcs : %d", ussd_ind->uss_info.uss_dcs );
            success = FALSE;
            break;
        }
      }

      if(success == TRUE)
      {
        if(notification_type == FURTHER_USER_ACTION_REQUIRED_V02)
        {
          type_code[ 0 ] = '1';   /* QCRIL_CM_SS_CUSD_RESULT_MORE */
          type_code[ 1 ] = '\0';
        }
        else
        {
          type_code[ 0 ] = '0'; /* QCRIL_CM_SS_CUSD_RESULT_MORE */
          type_code[ 1 ] = '\0';
        }
        response[ 0 ] = type_code;
        response[ 1 ] = ussd_utf8_str;

        /* sending the response received from the network for the USSD request */
        qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
        unsol_resp.resp_pkt = ( void * ) &response;
        unsol_resp.resp_len = sizeof( response );
        unsol_resp.logstr = NULL;
        qcril_send_unsol_response( &unsol_resp );
      }

    }
    else
    {
      QCRIL_LOG_ERROR("Received USSD Indication with no USSD string");
    }
  }

  QCRIL_LOG_FUNC_RETURN();

}/*qcril_qmi_voice_ussd_ind_hdlr*/

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_ussd_release_ind_hdlr

===========================================================================*/
/*!
    @brief
    Handles USSD Release indications

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_ussd_release_ind_hdlr
(
void *ind_data_ptr,
uint32 ind_data_len
)
{
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  char type_code[2];
  char *response_buff[2];
  qcril_unsol_resp_params_type unsol_resp;
  QCRIL_NOTUSED(ind_data_ptr);
  QCRIL_NOTUSED(ind_data_len);

  QCRIL_LOG_FUNC_ENTRY();
  if ( qcril_reqlist_query_by_request( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_SEND_USSD, &req_info ) == E_SUCCESS )
  {
    QCRIL_LOG_INFO("cleaning the uss_cnf after receiving release_uss_ind");
    /* send RIL_E_GENERIC_FAILURE response */
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

  qcril_qmi_voice_info.ussd_user_action_required = FALSE;

  memset( type_code, '\0', sizeof( type_code ) );
  memset( response_buff, 0, sizeof( response_buff ) );
  memset( &unsol_resp, 0 , sizeof(unsol_resp) );

  QCRIL_LOG_DEBUG ("USSD Release triggered, Sending ABORT in case if any pending transaction exists");
  type_code[ 0 ] = '0';  /* QCRIL_CM_SS_CUSD_RESULT_DONE */
  type_code[ 1 ] = '\0';
  response_buff[ 0 ] = type_code;
  response_buff[ 1 ] = NULL;
  qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
  unsol_resp.resp_pkt = (void *) response_buff;
  unsol_resp.resp_len = sizeof( response_buff );
  unsol_resp.logstr = NULL;
  qcril_send_unsol_response( &unsol_resp );

}/*qcril_qmi_voice_ussd_release_ind_hdlr*/

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_command_cb

===========================================================================*/
/*!
    @brief
    Common Callback for all the QMI voice commands.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_command_cb
(
  unsigned int                 msg_id,
  std::shared_ptr<void>        resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  uint16 req_id;
  uint16 dtmf_req_id;
  qcril_reqlist_public_type req_info;
  qcril_request_params_type req_data;

  QCRIL_LOG_FUNC_ENTRY();

    /*-----------------------------------------------------------------------*/
    QCRIL_ASSERT( resp_c_struct != nullptr );
    user_data = ( uint32 )(uintptr_t)resp_cb_data;
    instance_id = (qcril_instance_id_e_type)QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
    req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );
    req_data.modem_id = QCRIL_DEFAULT_MODEM_ID;
    req_data.instance_id = instance_id;
    req_data.datalen = resp_c_struct_len;
    req_data.data = resp_c_struct.get();
    /*-----------------------------------------------------------------------*/

    QCRIL_LOG_INFO("msg_id %.2x (%s)", msg_id, qcril_qmi_voice_lookup_command_name(msg_id));

    // DTMF add-on
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) != E_SUCCESS )
    {
      switch ( msg_id )
      {
        case QMI_VOICE_START_CONT_DTMF_RESP_V02:  // fall through
        case QMI_VOICE_STOP_CONT_DTMF_RESP_V02:
          qcril_qmi_voice_info_lock();
          dtmf_req_id = qcril_qmi_voice_info.pending_dtmf_req_id;
          qcril_qmi_voice_info_unlock();
          if ( qcril_reqlist_query_by_req_id( dtmf_req_id, &instance_id, &req_info ) == E_SUCCESS )
          {
            req_id = dtmf_req_id;
            QCRIL_LOG_INFO("dtmf req id overruled %d", req_id );
          }
          break;

        default: // no action
          break;
      }
    }

    /* Lookup the Token ID */
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
      if( transp_err != QMI_NO_ERR )
      {
        // QCRIL_LOG_INFO("Transp error (%d) recieved from QMI for RIL request %d", transp_err, req_info.request);
        QCRIL_LOG_INFO("Transp error recieved from QMI for RIL request %d", req_info.request);
        /* Send GENERIC_FAILURE response */
        qcril_send_empty_payload_request_response( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE );
      }
      else
      {
        req_data.t = req_info.t;
        req_data.event_id = req_info.request;
        switch(msg_id)
        {
        case QMI_VOICE_DIAL_CALL_RESP_V02:
          qcril_qmi_voice_dial_call_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_ANSWER_CALL_RESP_V02:
          qcril_qmi_voice_answer_call_resp_hdlr( &req_data , transp_err );
          break;

        case QMI_VOICE_END_CALL_RESP_V02:
          qcril_qmi_voice_end_call_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_BURST_DTMF_RESP_V02:
          qcril_qmi_voice_burst_dtmf_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_START_CONT_DTMF_RESP_V02:
          qcril_qmi_voice_start_cont_dtmf_resp_hdlr( &req_data,
                (qcril_evt_e_type)req_info.pending_event_id[ QCRIL_DEFAULT_MODEM_ID ]);
          break;

        case QMI_VOICE_STOP_CONT_DTMF_RESP_V02:
          qcril_qmi_voice_stop_cont_dtmf_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_SEND_FLASH_RESP_V02:
          qcril_qmi_voice_send_flash_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_INDICATION_REGISTER_RESP_V02:
          qcril_qmi_voice_set_supp_svc_notification_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_MANAGE_CALLS_RESP_V02:
          qcril_qmi_voice_sups_cmd_mng_calls_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_SET_SUPS_SERVICE_RSEP_V02:
          qcril_qmi_voice_set_sups_service_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_GET_CLIR_RESP_V02:
          qcril_qmi_voice_get_clir_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_GET_CLIP_RESP_V02:
          qcril_qmi_voice_get_clip_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_GET_COLP_RESP_V02:
          qcril_qmi_voice_get_colp_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_SET_CALL_BARRING_PASSWORD_RESP_V02:
          qcril_qmi_voice_change_call_barring_password_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_GET_CALL_WAITING_RESP_V02:
          qcril_qmi_voice_query_call_waiting_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_GET_CALL_BARRING_RESP_V02:
          qcril_qmi_voice_query_facility_lock_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_GET_CALL_FORWARDING_RESP_V02:
          qcril_qmi_voice_query_call_forward_status_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_ORIG_USSD_RESP_V02:
          qcril_qmi_voice_orig_ussd_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_ANSWER_USSD_RESP_V02:
          qcril_qmi_voice_answer_ussd_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_CANCEL_USSD_RESP_V02:
          qcril_qmi_voice_cancel_ussd_resp_hdlr(&req_data);
          break;

        case QMI_VOICE_MANAGE_IP_CALLS_RESP_V02:
          qcril_qmi_voice_voip_manage_ip_calls_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_SETUP_ANSWER_RESP_V02:
          qcril_qmi_voice_setup_answer_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_GET_COLR_RESP_V02:
          qcril_qmi_voice_get_colr_resp_hdlr( &req_data );
          break;

        case QMI_VOICE_IMS_CALL_CANCEL_RESP_V02:
          qcril_qmi_voice_ims_call_cancel_resp_hdlr( &req_data );
          break;

        default:
            QCRIL_LOG_INFO("Unsupported QMI VOICE message %d", msg_id);
            break;
        }
      }
    }
    else
    {
      QCRIL_LOG_ERROR( "Req ID: %d not found for qcril_qmi_client_voice_svc_cb", req_id );
    }

  QCRIL_LOG_FUNC_RETURN();
}/* qcril_qmi_voice_command_cb */

/*=========================================================================
  HELPER FUNCTION: on_length_enum_to_str
===========================================================================*/
void on_length_enum_to_str(dtmf_onlength_enum_v02 on_enum, char* str, int len) {
        if(len >= 4)
        {
        switch(on_enum)
        {
                case DTMF_ONLENGTH_95MS_V02:
                        strlcpy(str, "95", len);
                        break;
                case DTMF_ONLENGTH_150MS_V02:
                        strlcpy(str, "150", len);
                        break;
                case DTMF_ONLENGTH_200MS_V02:
                        strlcpy(str, "200", len);
                        break;
                case DTMF_ONLENGTH_250MS_V02:
                        strlcpy(str, "250", len);
                        break;
                case DTMF_ONLENGTH_300MS_V02:
                        strlcpy(str, "300", len);
                        break;
                case DTMF_ONLENGTH_350MS_V02:
                        strlcpy(str, "350", len);
                        break;
                case DTMF_ONLENGTH_SMS_V02:
                        strlcpy(str, "SMS", len);
                        break;
                default:
                        break;
        }
        }
}

/*=========================================================================
  HELPER FUNCTION: off_length_enum_to_str
===========================================================================*/
void off_length_enum_to_str(dtmf_offlength_enum_v02 off_enum, char* str, int len) {
        if(len >= 4)
        {
        switch(off_enum)
        {
                case DTMF_OFFLENGTH_60MS_V02:
                        strlcpy(str, "60", len);
                        break;
                case DTMF_OFFLENGTH_100MS_V02:
                        strlcpy(str, "100", len);
                        break;
                case DTMF_OFFLENGTH_150MS_V02:
                        strlcpy(str, "150", len);
                        break;
                case DTMF_OFFLENGTH_200MS_V02:
                        strlcpy(str, "200", len);
                        break;
                default:
                        break;
        }
        }

}
/*=========================================================================
  FUNCTION: qcril_qmi_voice_dtmf_ind_hdlr

    @brief
    Handle QMI_VOICE_DTMF_IND_V02.

    @return
    None.
=========================================================================*/
void qcril_qmi_voice_dtmf_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{

  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  voice_dtmf_ind_msg_v02* dtmf_ind;
  voice_dtmf_info_type_v02* dtmf_info;

  char payload[QCRIL_QMI_VOICE_DTMF_FWD_BURST_PAYLOAD_LENGTH];
  char on_length[4];
  char off_length[4];
  int digit_buf_len = 0;
  QCRIL_NOTUSED(ind_data_len);

  //initalize all our arrays to zero incase we don't set all bytes
  memset(on_length, 0, sizeof(on_length));
  memset(off_length, 0, sizeof(off_length));
  memset(payload, 0, sizeof(payload));

  if( ind_data_ptr != NULL )
  {
  dtmf_ind = (voice_dtmf_ind_msg_v02*) ind_data_ptr;

  dtmf_info = &dtmf_ind->dtmf_info;

  QCRIL_LOG_FUNC_ENTRY();

  switch(dtmf_info->dtmf_event)
  {
        case DTMF_EVENT_FWD_BURST_V02:

                if(dtmf_ind->on_length_valid) {
                        on_length_enum_to_str(dtmf_ind->on_length, on_length, sizeof(on_length));
                }
                if(dtmf_ind->off_length_valid) {
                        off_length_enum_to_str(dtmf_ind->off_length, off_length, sizeof(off_length));
                }

                digit_buf_len = (dtmf_info->digit_buffer_len < (QCRIL_QMI_VOICE_DTMF_FWD_BURST_PAYLOAD_LENGTH - 8)) ?
                        dtmf_info->digit_buffer_len :
                        QCRIL_QMI_VOICE_DTMF_FWD_BURST_PAYLOAD_LENGTH - 8;

                memcpy(payload, on_length, sizeof(on_length));
                memcpy(payload + sizeof(on_length), off_length, sizeof(off_length));
                memcpy(payload + sizeof(on_length) + sizeof(off_length), (void*) dtmf_info->digit_buffer, digit_buf_len);
                qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_BURST_DTMF, payload, sizeof(payload));
                break;

        case DTMF_EVENT_FWD_START_CONT_V02:
                  if(dtmf_info->digit_buffer_len != 0) {
                        qcril_hook_unsol_response(instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_CONT_DTMF_START, &dtmf_info->digit_buffer[0], sizeof(dtmf_info->digit_buffer[0]));
                  }
                  break;

        case DTMF_EVENT_FWD_STOP_CONT_V02:
                  if(dtmf_info->digit_buffer_len != 0) {
                        qcril_hook_unsol_response(instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_CONT_DTMF_STOP, NULL, 0);
                  }
                  break;
        default:
                QCRIL_LOG_INFO ("Got unknown DTMF_EVENT in DTMF indication handler");
  }
}
}

/*=========================================================================
  FUNCTION: qcril_qmi_voice_ext_brst_intl_ind_hdlr

    @brief
    Handle QMI_VOICE_EXT_BRST_INTL_IND_V02.

    @return
    None.
=========================================================================*/
void qcril_qmi_voice_ext_brst_intl_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{

  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  voice_ext_brst_intl_ind_msg_v02* ext_brst_intl_ind;
  int payload[QCRIL_QMI_VOICE_EXT_BRST_INTL_PAYLOAD_LENGTH];
  QCRIL_NOTUSED(ind_data_len);

  QCRIL_LOG_FUNC_ENTRY();

  if( ind_data_ptr != NULL )
  {
    memset(payload, 0, sizeof(payload));
    ext_brst_intl_ind = (voice_ext_brst_intl_ind_msg_v02*) ind_data_ptr;

    payload[ 0 ] = ext_brst_intl_ind->ext_burst_data.mcc;
    payload[ 1 ] = ext_brst_intl_ind->ext_burst_data.db_subtype;
    payload[ 2 ] = ext_brst_intl_ind->ext_burst_data.chg_ind;
    payload[ 3 ] = ext_brst_intl_ind->ext_burst_data.sub_unit;
    payload[ 4 ] = ext_brst_intl_ind->ext_burst_data.unit;

    qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_EXTENDED_DBM_INTL, (char *) payload, sizeof(payload) );
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_voice_ext_brst_intl_ind_hdlr

//===========================================================================
// qcril_qmi_voice_mark_calls_srvcc_in_progress
//===========================================================================
void qcril_qmi_voice_mark_calls_srvcc_in_progress()
{
    qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

    qcril_qmi_voice_voip_lock_overview();
    iter = qmi_voice_voip_overview.call_info_root;
    while ( iter != NULL  )
    {
        if ( !(iter->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN) )
        {
            iter->srvcc_in_progress = TRUE;
        }
        iter = iter->next;
    }
    qcril_qmi_voice_voip_unlock_overview();
} // qcril_qmi_voice_mark_calls_srvcc_in_progress

//===========================================================================
// qcril_qmi_voice_unmark_calls_srvcc_in_progress
//===========================================================================
void qcril_qmi_voice_unmark_calls_srvcc_in_progress()
{
    qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

    qcril_qmi_voice_voip_lock_overview();
    iter = qmi_voice_voip_overview.call_info_root;
    while ( iter != NULL  )
    {
        iter->srvcc_in_progress = FALSE;
        iter = iter->next;
    }
    qcril_qmi_voice_voip_unlock_overview();
} // qcril_qmi_voice_unmark_calls_srvcc_in_progress

//===========================================================================
// qcril_qmi_voice_reset_all_calls_from_auto_to_cs_domain_elab
//===========================================================================
void qcril_qmi_voice_reset_all_calls_from_auto_to_cs_domain_elab()
{
    qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_voice_voip_lock_overview();
    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
    while ( call_info_entry != NULL  )
    {
        call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
        call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
    }
    qcril_qmi_voice_voip_unlock_overview();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_reset_all_calls_from_auto_to_cs_domain_elab

//===========================================================================
// qcril_qmi_voice_handover_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_handover_info_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_handover_ind_msg_v02   *qmi_handover_ind_msg_ptr;
  RIL_Errno                     ret_val = RIL_E_GENERIC_FAILURE;
  qcril_unsol_resp_params_type  unsol_resp_params;
  RIL_SrvccState                ril_srvccstate = HANDOVER_STARTED;

  QCRIL_LOG_FUNC_ENTRY();

  if (ind_data_ptr != NULL && ind_data_len != 0)
  {
    qmi_handover_ind_msg_ptr = (voice_handover_ind_msg_v02*) ind_data_ptr;

    QCRIL_LOG_INFO("qmi handover ind ho_type_valid: %d, ho_type: %d",
        qmi_handover_ind_msg_ptr->ho_type_valid, qmi_handover_ind_msg_ptr->ho_type);

    // Need to send the UNSOL_SRVCC_STATE_NOTIFY only
    // in case of handover type is SRVCC L_2_G/L_2_W
    // and DRVCC cases for WIFI_2_C/WIFI_2_GW
    if (qmi_handover_ind_msg_ptr->ho_type_valid)
    {
      switch (qmi_handover_ind_msg_ptr->ho_type)
      {
        case VOICE_HO_SRVCC_L_2_G_V02:
        case VOICE_HO_SRVCC_L_2_W_V02:
        case VOICE_HO_DRVCC_WIFI_2_C_V02:
        case VOICE_HO_DRVCC_WIFI_2_GW_V02:
          ret_val = RIL_E_SUCCESS;
          break;

        default:
          break;
      }
    }

    if (ret_val == RIL_E_SUCCESS)
    {
      QCRIL_LOG_INFO("qmi handover ind ho_state: %d", qmi_handover_ind_msg_ptr->ho_state);
      switch (qmi_handover_ind_msg_ptr->ho_state)
      {
        case VOICE_HANDOVER_START_V02:
          ril_srvccstate = HANDOVER_STARTED;
          qcril_qmi_voice_mark_calls_srvcc_in_progress();
#ifndef QMI_RIL_UTF
          if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_G_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_W_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_SRVCC_START, NULL);
          }
          else if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_C_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_GW_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_DRVCC_START, NULL);
          }
#endif
          break;
        case VOICE_HANDOVER_FAIL_V02:
          ril_srvccstate = HANDOVER_FAILED;
          qcril_qmi_voice_unmark_calls_srvcc_in_progress();
#ifndef QMI_RIL_UTF
          if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_G_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_W_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_SRVCC_FAIL, NULL);
          }
          else if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_C_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_GW_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_DRVCC_FAIL, NULL);
          }
#endif
          break;
        case VOICE_HANDOVER_COMPLETE_V02:
          ril_srvccstate = HANDOVER_COMPLETED;
          qcril_qmi_voice_reset_all_calls_from_auto_to_cs_domain_elab();
#ifndef QMI_RIL_UTF
          if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_G_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_W_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_SRVCC_COMPLETE, NULL);
          }
          else if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_C_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_GW_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_DRVCC_COMPLETE, NULL);
          }
#endif
          if (qcril_qmi_ril_domestic_service_is_screen_off())
          {
            qcril_qmi_voice_enable_voice_indications(FALSE);
          }
          break;
        case VOICE_HANDOVER_CANCEL_V02:
          ril_srvccstate = HANDOVER_CANCELED;
          qcril_qmi_voice_unmark_calls_srvcc_in_progress();
#ifndef QMI_RIL_UTF
          if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_G_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_SRVCC_L_2_W_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_SRVCC_CANCEL, NULL);
          }
          else if(qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_C_V02 ||
              qmi_handover_ind_msg_ptr->ho_type == VOICE_HO_DRVCC_WIFI_2_GW_V02)
          {
            qcril_am_handle_event(QCRIL_AM_EVENT_DRVCC_CANCEL, NULL);
          }
#endif
          break;
        default:
          ret_val = RIL_E_GENERIC_FAILURE;
          break;
      }/* switch */

      if (RIL_E_SUCCESS == ret_val)
      {
        // Send SRVCC handover indication on RILD socket
        qcril_default_unsol_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
            RIL_UNSOL_SRVCC_STATE_NOTIFY, &unsol_resp_params);
        unsol_resp_params.resp_pkt = &ril_srvccstate;
        unsol_resp_params.resp_len = sizeof(RIL_SrvccState);
        qcril_send_unsol_response(&unsol_resp_params);

        // Send SRVCC handover indication on IMS socket
        qcril_qmi_voice_send_ims_unsol_resp_handover(ril_srvccstate);
      }
    }
  }
  else
  {
    QCRIL_LOG_ERROR("ind_data_ptr is NULL");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_handover_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_reset_info_xml
//===========================================================================
void qcril_qmi_voice_reset_info_xml(qcril_qmi_voice_info_ind_xml_type_e_type xml_type)
{
   QCRIL_LOG_FUNC_ENTRY();
   qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].last_sequence_number = -1;
   qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].total_size = 0;
   qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].filled_size = 0;

   if (qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].buffer)
   {
      qcril_free(qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].buffer);
      qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].buffer = NULL;
   }

   qcril_qmi_voice_info.qmi_info_ind_xml[xml_type].call_id_valid = FALSE;
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_reset_info_xml

//===========================================================================
// qcril_qmi_voice_conference_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_conference_info_ind_hdlr
(
   void *ind_data_ptr,
   uint32 ind_data_len
)
{
   voice_conference_info_ind_msg_v02* qmi_ind_msg_ptr;

   QCRIL_LOG_FUNC_ENTRY();

   do
   {
      if (NULL == ind_data_ptr || 0 == ind_data_len)
      {
         QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
         break;
      }
      qmi_ind_msg_ptr = (voice_conference_info_ind_msg_v02*) ind_data_ptr;
      QCRIL_LOG_INFO("sequence: %d, total_size_valid: %d, total_size: %d, conference_xml_len: %d",
                     qmi_ind_msg_ptr->sequence,
                     qmi_ind_msg_ptr->total_size_valid,
                     qmi_ind_msg_ptr->total_size,
                     qmi_ind_msg_ptr->conference_xml_len);

      qcril_qmi_voice_process_qmi_info_ind(qmi_ind_msg_ptr->sequence,
                                           qmi_ind_msg_ptr->total_size_valid,
                                           qmi_ind_msg_ptr->total_size,
                                           qmi_ind_msg_ptr->conference_xml_len,
                                           qmi_ind_msg_ptr->conference_xml,
                                           qmi_ind_msg_ptr->call_id_valid,
                                           qmi_ind_msg_ptr->call_id,
                                           QCRIL_QMI_VOICE_CONFERENCE_INFO_IND_XML);

   } while (FALSE);

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_conference_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_dialog_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_dialog_info_ind_hdlr
(
   void *ind_data_ptr,
   uint32 ind_data_len
)
{
   vice_dialog_info_ind_msg_v02* qmi_ind_msg_ptr;

   QCRIL_LOG_FUNC_ENTRY();

   do
   {
      if (NULL == ind_data_ptr || 0 == ind_data_len)
      {
         QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
         break;
      }
      qmi_ind_msg_ptr = (vice_dialog_info_ind_msg_v02*) ind_data_ptr;
      QCRIL_LOG_INFO("sequence: %d, total_size_valid: %d, total_size: %d, dialog_xml_len: %d",
                     qmi_ind_msg_ptr->sequence,
                     qmi_ind_msg_ptr->total_size_valid,
                     qmi_ind_msg_ptr->total_size,
                     qmi_ind_msg_ptr->vice_dialog_xml_len);

      qcril_qmi_voice_process_qmi_info_ind(qmi_ind_msg_ptr->sequence,
                                           qmi_ind_msg_ptr->total_size_valid,
                                           qmi_ind_msg_ptr->total_size,
                                           qmi_ind_msg_ptr->vice_dialog_xml_len,
                                           qmi_ind_msg_ptr->vice_dialog_xml,
                                           FALSE,
                                           INVALID_NEGATIVE_ONE,
                                           QCRIL_QMI_VOICE_DIALOG_INFO_IND_XML);

   } while (FALSE);

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_dialog_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_process_qmi_info_ind
//===========================================================================
void qcril_qmi_voice_process_qmi_info_ind(uint32_t sequence,
                                          uint8_t total_size_valid,
                                          uint32_t total_size,
                                          uint32_t xml_len,
                                          uint8_t* xml,
                                          uint8_t call_id_valid,
                                          uint8_t call_id,
                                          qcril_qmi_voice_info_ind_xml_type_e_type xml_type)
{
   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_voice_info_lock();

   qcril_qmi_voice_info_ind_xml_type* current_xml;
   current_xml = &qcril_qmi_voice_info.qmi_info_ind_xml[xml_type];

   do
   {
      if (0 == sequence)
      {
         if (total_size_valid)
         {
            qcril_qmi_voice_reset_info_xml(xml_type);
            current_xml->total_size = total_size;
            current_xml->buffer = (uint8 *)qcril_malloc(current_xml->total_size);
            if (NULL == current_xml->buffer)
            {
               QCRIL_LOG_ERROR("malloc failed");
               qcril_qmi_voice_reset_info_xml(xml_type);
               break;
            }
         }
         else
         {
            QCRIL_LOG_ERROR("no total size in the first sequence indication");
            break;
         }
      }

      if (current_xml->filled_size + xml_len > current_xml->total_size)
      {
         QCRIL_LOG_ERROR("filled_size (%d) + new conference_xml_len (%d) > total_size (%d)",
                         current_xml->filled_size, xml_len, current_xml->total_size);
         qcril_qmi_voice_reset_info_xml(xml_type);
         break;
      }

      if (sequence != current_xml->last_sequence_number + (unsigned int)1)
      {
         QCRIL_LOG_ERROR("sequence out of order! new msg seq#: %d, last_seq#: %d",
                         sequence, current_xml->last_sequence_number);
         qcril_qmi_voice_reset_info_xml(xml_type);
         break;
      }

      if (NULL == current_xml->buffer)
      {
         QCRIL_LOG_ERROR("qcril_qmi_voice_info.conf_xml.buffer is NULL");
         break;
      }

      memcpy( &(current_xml->buffer[current_xml->filled_size]), xml, xml_len );
      current_xml->filled_size += xml_len;
      current_xml->last_sequence_number = sequence;

      if (call_id_valid)
      {
        current_xml->call_id_valid = TRUE;
        current_xml->call_id = call_id;
      }

      if (current_xml->filled_size == current_xml->total_size)
      {
         qcril_binary_data_type bin_data;
         bin_data.len = current_xml->total_size;
         bin_data.data = current_xml->buffer;

         if(xml_type == QCRIL_QMI_VOICE_CONFERENCE_INFO_IND_XML)
         {
           ims_ConfInfo conf_info;
           memset(&conf_info, 0,sizeof(conf_info));
           conf_info.conf_info_uri.arg = &bin_data;

           if (current_xml->call_id_valid)
           {
             qcril_qmi_voice_voip_call_info_entry_type *call_info_entry =
               qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(current_xml->call_id);

             if (call_info_entry)
             {
               ims_ConfCallState ims_state;
               if (qcril_qmi_ims_map_qmi_call_state_to_ims_conf_call_state(
                       call_info_entry->voice_scv_info.call_state,
                       &ims_state))
               {
                 conf_info.has_confCallState = TRUE;
                 conf_info.confCallState = ims_state;
               }
             }
           }

           imsRadioSendMessage(0,
                                     ims_MsgType_UNSOL_RESPONSE,
                                     ims_MsgId_UNSOL_REFRESH_CONF_INFO,
                                     ims_Error_E_SUCCESS,
                                     &conf_info,
                                     sizeof(conf_info));
           qcril_qmi_voice_send_ims_unsol_call_state_changed();
           qcril_qmi_voice_reset_info_xml(xml_type);
         }

         if(xml_type == QCRIL_QMI_VOICE_DIALOG_INFO_IND_XML)
         {
           qcril_qmi_voice_send_vice_dialog_info_unsol(&bin_data);
           qcril_qmi_voice_info.send_vice_unsol_on_socket_connect = TRUE;
         }
      }
      else if(xml_type == QCRIL_QMI_VOICE_DIALOG_INFO_IND_XML)
      {
        qcril_qmi_voice_info.send_vice_unsol_on_socket_connect = FALSE;
      }

   } while (FALSE);

   qcril_qmi_voice_info_unlock();

   QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_send_vice_dialog_info_unsol
//===========================================================================
void qcril_qmi_voice_send_vice_dialog_info_unsol(qcril_binary_data_type* bin_data)
{
   ims_ViceInfo dialog_info;
   memset(&dialog_info, 0,sizeof(dialog_info));
   dialog_info.vice_info_uri.arg = bin_data;

   imsRadioSendMessage(0,
                             ims_MsgType_UNSOL_RESPONSE,
                             ims_MsgId_UNSOL_REFRESH_VICE_INFO,
                             ims_Error_E_SUCCESS,
                             &dialog_info,
                             sizeof(dialog_info));
}

//===========================================================================
// qcril_qmi_voice_send_unsol_vice_dialog_refresh_info_helper
//===========================================================================
void qcril_qmi_voice_ims_send_unsol_vice_dialog_refresh_info_helper(void)
{
   qcril_binary_data_type bin_data;
   qcril_qmi_voice_info_ind_xml_type* vice_dialog_xml;

   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_voice_info_lock();

   if(TRUE == qcril_qmi_voice_info.send_vice_unsol_on_socket_connect)
   {
      vice_dialog_xml =
              &qcril_qmi_voice_info.qmi_info_ind_xml[QCRIL_QMI_VOICE_DIALOG_INFO_IND_XML];

      bin_data.data = vice_dialog_xml->buffer;
      bin_data.len = vice_dialog_xml->total_size;
      qcril_qmi_voice_send_vice_dialog_info_unsol(&bin_data);
   }

   qcril_qmi_voice_info_unlock();

   QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_tty_ind_hdlr
//===========================================================================
void qcril_qmi_voice_tty_ind_hdlr
(
   void *ind_data_ptr,
   uint32 ind_data_len
)
{
   voice_tty_ind_msg_v02* qmi_ind_msg_ptr;

   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_voice_info_lock();

   do
   {
      if (NULL == ind_data_ptr || 0 == ind_data_len)
      {
         QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
         break;
      }

      qmi_ind_msg_ptr = (voice_tty_ind_msg_v02*) ind_data_ptr;
      QCRIL_LOG_INFO("tty_mode: %d", qmi_ind_msg_ptr->tty_mode);

      ims_TtyNotify ims_tty_info;
      memset(&ims_tty_info, 0, sizeof(ims_tty_info));
      ims_tty_info.has_mode = TRUE;
      switch(qmi_ind_msg_ptr->tty_mode)
      {
         case TTY_MODE_FULL_V02:
            ims_tty_info.mode = ims_Tty_Mode_Type_TTY_MODE_FULL;
            break;

         case TTY_MODE_VCO_V02:
            ims_tty_info.mode = ims_Tty_Mode_Type_TTY_MODE_VCO;
            break;

         case TTY_MODE_HCO_V02:
            ims_tty_info.mode = ims_Tty_Mode_Type_TTY_MODE_HCO;
            break;

         case TTY_MODE_OFF_V02:
            ims_tty_info.mode = ims_Tty_Mode_Type_TTY_MODE_OFF;
            break;

         default:
            ims_tty_info.mode = ims_Tty_Mode_Type_TTY_MODE_OFF;
            break;
      }

      imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_TTY_NOTIFICATION,
          ims_Error_E_SUCCESS, &ims_tty_info, sizeof(ims_tty_info));

   } while (FALSE);

   qcril_qmi_voice_info_unlock();

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_tty_ind_hdlr

/*=========================================================================
  FUNCTION: qcril_qmi_voice_call_control_result_info_ind_hdlr

    @brief
    Handle QMI_VOICE_CALL_CONTROL_RESULT_INFO_IND_V02.

    @return
    None.
=========================================================================*/
void qcril_qmi_voice_call_control_result_info_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
   voice_call_control_result_info_ind_msg_v02* qmi_ind_msg_ptr;
   qcril_unsol_resp_params_type unsol_resp;
   qcril_instance_id_e_type instance_id;
   char buf_str[QMI_VOICE_CC_ALPHA_TEXT_MAX_V02 + 2];

   qcril_qmi_voice_voip_call_info_entry_type * call_entry;
   int                                         name_len;
   int                                         call_entry_is_already_emulating;

   QCRIL_LOG_FUNC_ENTRY();
   instance_id = qmi_ril_get_process_instance_id();
   memset(buf_str, 0 , QMI_VOICE_CC_ALPHA_TEXT_MAX_V02 + 2);

   if( ind_data_ptr != NULL && ind_data_len != 0 )
   {
       qmi_ind_msg_ptr = (voice_call_control_result_info_ind_msg_v02*) ind_data_ptr;

        if( ( VOICE_CC_ALPHA_NOT_PRESENT_V02 == qmi_ind_msg_ptr->alpha_presence ) ||
            ( VOICE_CC_ALPHA_NULL_V02 == qmi_ind_msg_ptr->alpha_presence )
          )
        {
            QCRIL_LOG_INFO("Either Alhpa is absent in cc result or Alpha is present but length is zero");
        }
        else
        {
            if( TRUE == qmi_ind_msg_ptr->alpha_text_gsm8_valid )
            {
                QCRIL_LOG_INFO("Alpha text message is present in gsm8 bit format");
                if(qmi_ind_msg_ptr->alpha_text_gsm8_len < QMI_VOICE_CC_ALPHA_TEXT_MAX_V02 )
                    qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (char*) qmi_ind_msg_ptr->alpha_text_gsm8,
                                                                qmi_ind_msg_ptr->alpha_text_gsm8_len,
                                                                buf_str, sizeof(buf_str) );
            }
            else
            {
                QCRIL_LOG_INFO("Alpha text message is present in UTF16 format");
                qcril_cm_ss_convert_ucs2_to_utf8( (char *) qmi_ind_msg_ptr->alpha_text_utf16,
                                                             qmi_ind_msg_ptr->alpha_text_utf16_len * 2,
                                                           buf_str,
                                                           sizeof(buf_str) );
            }
        }
   }
   else
   {
       QCRIL_LOG_ERROR("ind_data_ptr is NULL");
   }

   if ( *buf_str )
   { // something to relay
      call_entry_is_already_emulating = FALSE;

      call_entry = qcril_qmi_voice_voip_find_call_info_entry_by_single_elaboration_extended( QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_STK_CC_EMULATED_OVERLAY, TRUE );
      if ( NULL != call_entry )
      {
         call_entry_is_already_emulating = TRUE;
      }
      QCRIL_LOG_INFO( ".. stk cc emulate check, obj %x, already emulating %d", (intptr_t)call_entry, call_entry_is_already_emulating );

      if ( NULL != call_entry )
      {  // STK CC emulation: keep alpha as overlay "name"

         if ( NULL != call_entry->overlayed_name_storage_for_emulated_stk_cc )
         {
            qcril_free( call_entry->overlayed_name_storage_for_emulated_stk_cc );
         }
         name_len = strlen( buf_str );
         call_entry->overlayed_name_storage_for_emulated_stk_cc = (char*)qcril_malloc( name_len + 1 );
         if ( NULL != call_entry->overlayed_name_storage_for_emulated_stk_cc )
         {
            strlcpy( call_entry->overlayed_name_storage_for_emulated_stk_cc, buf_str, name_len + 1 );
         }
         QCRIL_LOG_INFO( ".. setting overlay name %s for android call id %d under ongoing == %d emulation",
                           call_entry->overlayed_name_storage_for_emulated_stk_cc,
                           call_entry->android_call_id,
                           call_entry_is_already_emulating );

         if ( call_entry_is_already_emulating )
         { // if QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_STK_CC_EMULATED_OVERLAY is set, that means DIAL RESP already received and we should update call list
            if ( qcril_qmi_voice_call_to_ims(call_entry) )
            {
               qcril_qmi_voice_send_ims_unsol_call_state_changed();
            }
            else
            {
               qcril_qmi_voice_send_unsol_call_state_changed( QCRIL_DEFAULT_INSTANCE_ID );
            }
         }
      } // if ( NULL != call_entry ) i.e. no overlay, no STK CC emulation
      else
      {
         // no STK CC emulation
         qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_STK_CC_ALPHA_NOTIFY, &unsol_resp );
         unsol_resp.resp_pkt    = (void*)buf_str;
         unsol_resp.resp_len    = sizeof( buf_str );

         qcril_send_unsol_response( &unsol_resp );
      }
   }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_voice_call_control_result_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_reset_additional_call_info
//===========================================================================
void qcril_qmi_voice_reset_additional_call_info
(
    qcril_qmi_voice_voip_call_info_entry_type *entry
)
{
   QCRIL_LOG_FUNC_ENTRY();

   if (entry)
   {
      entry->additional_call_info.last_sequence_number = -1;
      entry->additional_call_info.total_size = 0;
      entry->additional_call_info.filled_size = 0;

      if (entry->additional_call_info.buffer)
      {
         qcril_free(entry->additional_call_info.buffer);
         entry->additional_call_info.buffer = NULL;
      }
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_reset_additional_call_info

//===========================================================================
// qcril_qmi_voice_is_additional_call_info_available
//===========================================================================
boolean qcril_qmi_voice_is_additional_call_info_available
(
    const qcril_qmi_voice_voip_call_info_entry_type *entry
)
{
   boolean add_info_present = FALSE;

   QCRIL_LOG_FUNC_ENTRY();

   if (entry)
   {
      if (entry->additional_call_info.is_add_info_present &&
          (entry->additional_call_info.total_size > 0)&&
          (entry->additional_call_info.filled_size ==
           entry->additional_call_info.total_size))
      {
         add_info_present = TRUE;
      }
   }

   QCRIL_LOG_FUNC_RETURN_WITH_RET(add_info_present);

   return add_info_present;
} // qcril_qmi_voice_is_additional_call_info_available


//===========================================================================
// qcril_qmi_voice_additional_call_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_additional_call_info_ind_hdlr
(
   void *ind_data_ptr,
   uint32 ind_data_len
)
{
   voice_additional_call_info_ind_msg_v02    *qmi_ind_msg_ptr = NULL;
   voice_additional_call_info_type_v02       *add_call_info   = NULL;
   qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;

   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_voice_info_lock();

   do
   {
      if (NULL == ind_data_ptr || 0 == ind_data_len)
      {
         QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
         break;
      }
      qmi_ind_msg_ptr = (voice_additional_call_info_ind_msg_v02*) ind_data_ptr;
      if (qmi_ind_msg_ptr->extension_header_info_valid)
      {
         add_call_info   = &(qmi_ind_msg_ptr->extension_header_info);
      }
      else
      {
         QCRIL_LOG_ERROR("extension_header_info is not valid");
         break;
      }
      QCRIL_LOG_INFO("call_id: %d, sequence: %d, total_size: %d, additional_call_info_len: %d",
              qmi_ind_msg_ptr->call_id, add_call_info->sequence,
              add_call_info->total_size, add_call_info->additional_call_info_len);

      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
              qmi_ind_msg_ptr->call_id);
      if (NULL == call_info_entry)
      {
         QCRIL_LOG_ERROR("Unable to find call info entry for call_id: %d",
                 qmi_ind_msg_ptr->call_id);
         break;
      }

      if (0 == add_call_info->sequence)
      {
         qcril_qmi_voice_reset_additional_call_info(call_info_entry);
         call_info_entry->additional_call_info.total_size = add_call_info->total_size;
         call_info_entry->additional_call_info.buffer     =
               (uint8*)qcril_malloc(call_info_entry->additional_call_info.total_size);
         if (NULL == call_info_entry->additional_call_info.buffer)
         {
            QCRIL_LOG_ERROR("malloc failed");
            qcril_qmi_voice_reset_additional_call_info(call_info_entry);
            break;
         }
      }

      if ((call_info_entry->additional_call_info.filled_size +
            add_call_info->additional_call_info_len) >
          call_info_entry->additional_call_info.total_size)
      {
         QCRIL_LOG_ERROR("filled_size (%d) + new additional_call_info_len (%d) > total_size (%d)",
                         call_info_entry->additional_call_info.filled_size,
                         add_call_info->additional_call_info_len,
                         call_info_entry->additional_call_info.total_size);
         qcril_qmi_voice_reset_additional_call_info(call_info_entry);
         break;
      }

      if (add_call_info->sequence !=
          call_info_entry->additional_call_info.last_sequence_number+1)
      {
         QCRIL_LOG_ERROR("sequence out of order! new msg seq#: %d, last_seq#: %d",
                         add_call_info->sequence,
                         call_info_entry->additional_call_info.last_sequence_number);
         qcril_qmi_voice_reset_additional_call_info(call_info_entry);
         break;
      }

      if (NULL == call_info_entry->additional_call_info.buffer)
      {
         QCRIL_LOG_ERROR("call_info_entry->additional_call_info.buffer is NULL");
         break;
      }

      memcpy(&(call_info_entry->additional_call_info.buffer[
                    call_info_entry->additional_call_info.filled_size]),
              add_call_info->additional_call_info, add_call_info->additional_call_info_len);
      call_info_entry->additional_call_info.filled_size += add_call_info->additional_call_info_len;
      call_info_entry->additional_call_info.last_sequence_number = add_call_info->sequence;
      if (call_info_entry->additional_call_info.filled_size ==
          call_info_entry->additional_call_info.total_size)
      {
        qcril_qmi_voice_send_ims_unsol_call_state_changed();
      }
   } while (FALSE);

   qcril_qmi_voice_info_unlock();

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_additional_call_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_audio_rat_change_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_audio_rat_change_info_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_audio_rat_change_info_ind_msg_v02 *qmi_ind_msg_ptr = NULL;
  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if ( NULL == ind_data_ptr || 0 == ind_data_len )
    {
      QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
      break;
    }
    qmi_ind_msg_ptr = (voice_audio_rat_change_info_ind_msg_v02*)ind_data_ptr;

#ifndef QMI_RIL_UTF
    qcril_am_handle_event(QCRIL_AM_EVENT_AUDIO_RAT_CHANGED, qmi_ind_msg_ptr);
#endif
  } while (0);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_audio_rat_change_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_conf_participant_status_info_ind_hdlr
//===========================================================================
void qcril_qmi_voice_conf_participant_status_info_ind_hdlr
(
  void *ind_data_ptr,
  uint32 ind_data_len
)
{
  voice_conf_participant_status_info_ind_msg_v02 *qmi_ind_msg_ptr = NULL;
  qcril_qmi_voice_voip_call_info_entry_type      *call_info_entry = NULL;
  ims_ParticipantStatusInfo ims_partcpnt_stat_info;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if( ind_data_ptr == NULL || ind_data_len == 0 )
    {
      QCRIL_LOG_ERROR("ind_data_ptr is NULL or ind_data_len is 0");
      break;
    }

    qmi_ind_msg_ptr = (voice_conf_participant_status_info_ind_msg_v02 *) ind_data_ptr;

    QCRIL_LOG_DEBUG("call_id = %d, participant_uri = %s",
        qmi_ind_msg_ptr->call_id, qmi_ind_msg_ptr->participant_uri);

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
        qmi_ind_msg_ptr->call_id);

    if (call_info_entry == NULL)
    {
      QCRIL_LOG_ERROR("Unable to find call info entry for call_id: %d", qmi_ind_msg_ptr->call_id);
      break;
    }

    memset(&ims_partcpnt_stat_info, 0, sizeof(ims_partcpnt_stat_info));

    ims_partcpnt_stat_info.has_callId = TRUE;
    ims_partcpnt_stat_info.callId     = call_info_entry->android_call_id;
    ims_partcpnt_stat_info.participantUri.arg  = qmi_ind_msg_ptr->participant_uri;

    if (qmi_ind_msg_ptr->op_status_valid)
    {
      ims_partcpnt_stat_info.has_operation =
        qcril_qmi_ims_map_qmi_conf_parti_op_to_ims_conf_parti_op(
            qmi_ind_msg_ptr->op_status.operation, &ims_partcpnt_stat_info.operation);
      ims_partcpnt_stat_info.has_sipStatus = TRUE;
      ims_partcpnt_stat_info.sipStatus     = qmi_ind_msg_ptr->op_status.sip_status;
    }

    if (qmi_ind_msg_ptr->is_qmi_voice_transfer_valid)
    {
      ims_partcpnt_stat_info.has_isEct = TRUE;
      ims_partcpnt_stat_info.isEct     = qmi_ind_msg_ptr->is_qmi_voice_transfer;
    }

    QCRIL_LOG_DEBUG("callId = %d, participantUri = %s, operation = %d, sipStatus = %d, isEct = %d",
        ims_partcpnt_stat_info.has_callId ? ims_partcpnt_stat_info.callId : -1,
        ims_partcpnt_stat_info.participantUri.arg,
        ims_partcpnt_stat_info.has_operation ? ims_partcpnt_stat_info.operation : -1,
        ims_partcpnt_stat_info.has_sipStatus ? ims_partcpnt_stat_info.sipStatus : -1,
        ims_partcpnt_stat_info.has_isEct ? ims_partcpnt_stat_info.isEct : -1);

    imsRadioSendMessage(0,
        ims_MsgType_UNSOL_RESPONSE,
        ims_MsgId_UNSOL_PARTICIPANT_STATUS_INFO,
        ims_Error_E_SUCCESS,
        &ims_partcpnt_stat_info,
        sizeof(ims_partcpnt_stat_info));
  } while (FALSE);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_conf_participant_status_info_ind_hdlr

//===========================================================================
// qcril_qmi_voice_auto_call_rejection_ind_hdlr
//===========================================================================
void qcril_qmi_voice_auto_call_rejection_ind_hdlr
(
    void * auto_reject_data_ptr
)
{
  QCRIL_LOG_FUNC_ENTRY();
  do {
    auto qmi_auto_reject_info = static_cast<
        auto_rejected_incoming_call_end_ind_msg_v02*>(auto_reject_data_ptr);
    if (!qmi_auto_reject_info) {
      QCRIL_LOG_ERROR("qmi_auto_reject_info is NULL. returning");
      break;
    }
    ims_AutoCallRejectionInfo ims_auto_reject_info;
    memset(&ims_auto_reject_info, 0, sizeof(ims_auto_reject_info));
    ims_auto_reject_info.callType =
        qcril_qmi_ims_map_ril_call_type_to_ims_call_type(
            map_qmi_call_type_to_ril_type(qmi_auto_reject_info->call_type));
    ims_auto_reject_info.autoRejectionCause =
        qcril_qmi_ims_map_ril_failcause_to_ims_failcause(
                 CALL_FAIL_ERROR_UNSPECIFIED,
                 qmi_auto_reject_info->call_end_reason,
                 TRUE,
                 qmi_auto_reject_info->sip_error_code);

    ims_auto_reject_info.sipErrorCode = qmi_auto_reject_info->sip_error_code;
    ims_auto_reject_info.hasNumber = qmi_auto_reject_info->num_valid;
    int num_len = qmi_auto_reject_info->num_len;
    if ((qmi_auto_reject_info->num_valid) && (num_len > 0)) {
      //Since we are allocating memory for void*, we won't use qcril_malloc2
      ims_auto_reject_info.number.arg = qcril_malloc(num_len + 1);
      if (ims_auto_reject_info.number.arg) {
        strlcpy((char*)ims_auto_reject_info.number.arg,
            qmi_auto_reject_info->num, num_len + 1);
      }
      else {
        QCRIL_LOG_ERROR("memory allocation failed for ims_auto_reject_info.number");
        break;
      }
    }
    imsRadioSendMessage(0,
      ims_MsgType_UNSOL_RESPONSE,
      ims_MsgId_UNSOL_AUTO_CALL_REJECTION_IND,
      ims_Error_E_SUCCESS,
      &ims_auto_reject_info,
      sizeof(ims_auto_reject_info));

    //free up the memory
    qcril_free(ims_auto_reject_info.number.arg);
  } while (FALSE);
  QCRIL_LOG_FUNC_RETURN();
}//qcril_qmi_voice_auto_call_rejection_ind_hdlr

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_unsol_ind_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QMI indication

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_unsol_ind_cb_helper
(
  unsigned int   msg_id,
  unsigned char *decoded_payload,
  uint32_t       decoded_payload_len
)
{
  qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  // In DSDS QCRIL state will be UNRESTRICTED only when subscriptions are
  // ACTIVE. But without SIM subscriptions cannot be ACTIVE. To allow
  // emergency calls in this state we need to check if there is any
  // pending emergency call in non UNRESTRICTED state.
  call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration_any_subset
                    ( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EME_FROM_OOS|
                      QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMERGENCY_CALL);
  if ( ( qmi_ril_get_operational_status() == QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED
               || call_info_entry != NULL ))
  {
    switch(msg_id)
    {
    case QMI_VOICE_ALL_CALL_STATUS_IND_V02:
      qcril_qmi_voice_all_call_status_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_OTASP_STATUS_IND_V02:
      qcril_qmi_voice_otasp_status_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_PRIVACY_IND_V02:
      qcril_qmi_voice_privacy_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_SUPS_NOTIFICATION_IND_V02:
      qcril_qmi_voice_sups_notification_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_INFO_REC_IND_V02:
      qcril_qmi_voice_info_rec_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_USSD_IND_V02:
      qcril_qmi_nas_notify_ussd_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_USSD_RELEASE_IND_V02:
      qcril_qmi_voice_ussd_release_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_SUPS_IND_V02:
      qcril_qmi_voice_stk_cc_handle_voice_sups_ind( (voice_sups_ind_msg_v02*) decoded_payload );
      break;

    case QMI_VOICE_DTMF_IND_V02:
      qcril_qmi_voice_dtmf_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_EXT_BRST_INTL_IND_V02:
      qcril_qmi_voice_ext_brst_intl_ind_hdlr(decoded_payload, decoded_payload_len);
      break;

    case QMI_VOICE_UUS_IND_V02:
      qcril_qmi_voice_uus_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_MODIFIED_IND_V02:
      qcril_qmi_voice_modified_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_MODIFY_ACCEPT_IND_V02:
      qcril_qmi_voice_modify_accept_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_SPEECH_CODEC_INFO_IND_V02:
      qcril_qmi_voice_speech_codec_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_HANDOVER_IND_V02:
      qcril_qmi_voice_handover_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_CONFERENCE_INFO_IND_V02:
      qcril_qmi_voice_conference_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_VICE_DIALOG_INFO_IND_V02:
      qcril_qmi_voice_dialog_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_TTY_IND_V02:
      qcril_qmi_voice_tty_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_CALL_CONTROL_RESULT_INFO_IND_V02:
      qcril_qmi_voice_call_control_result_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_ADDITIONAL_CALL_INFO_IND_V02:
      qcril_qmi_voice_additional_call_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_AUDIO_RAT_CHANGE_INFO_IND_V02:
      qcril_qmi_voice_audio_rat_change_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_VOICE_CONF_PARTICIPANT_STATUS_INFO_IND_V02:
      qcril_qmi_voice_conf_participant_status_info_ind_hdlr( decoded_payload, decoded_payload_len );
      break;

    case QMI_AUTO_REJECTED_INCOMING_CALL_END_IND_V02:
      qcril_qmi_voice_auto_call_rejection_ind_hdlr(decoded_payload);
      break;

    default:
      QCRIL_LOG_INFO("Unknown QMI VOICE indication %d", msg_id);
      break;
    }
  }

  QCRIL_LOG_FUNC_RETURN();

}/* qcril_qmi_voice_unsol_ind_cb_helper */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_sups_cmd_mng_calls_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle MNG_CALLS_RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_sups_cmd_mng_calls_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_manage_calls_resp_msg_v02    *mng_calls_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;

  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type oversight_event_params;
  qmi_ril_voice_ims_command_exec_oversight_type *                   command_oversight;
  int                                                               covered_by_oversight_handling;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {
    //memset(mng_calls_resp,0,sizeof(voice_manage_calls_resp_msg_v02));
    /* Entry found in the ReqList */

    QCRIL_LOG_INFO("params_ptr->data is not NULL");

    mng_calls_resp = (voice_manage_calls_resp_msg_v02 *)params_ptr->data;
    qmi_result = mng_calls_resp->resp.result;
    qmi_error = mng_calls_resp->resp.error;

    if (qmi_result != QMI_RESULT_SUCCESS_V01)
    {
      ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
      if(ril_err == RIL_E_MODEM_ERR && qmi_error == QMI_ERR_INVALID_ID_V01)
      {
        //handle specific error
        ril_err = RIL_E_INVALID_CALL_ID;
      }
    }
    QCRIL_LOG_INFO("QCRIL QMI VOICE MNG CALLS RESP: %s, ril_err = %d",
        (ril_err == RIL_E_SUCCESS) ? "SUCCESS" : "FAILURE", ril_err);

    covered_by_oversight_handling = FALSE;
    qcril_qmi_voice_voip_lock_overview();
    command_oversight = qmi_ril_voice_ims_find_command_oversight_by_token( params_ptr->t );
    if ( NULL != command_oversight )
    {
      memset( &oversight_event_params, 0, sizeof( oversight_event_params ) );
      oversight_event_params.locator.command_oversight = command_oversight;
      covered_by_oversight_handling = qmi_ril_voice_ims_command_oversight_handle_event
                                      (
                                          ( QMI_RESULT_SUCCESS_V01 == qmi_result && QMI_ERR_NONE_V01 == qmi_error ) ?
                                              QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_SUCCESS : QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_FAILURE ,
                                          QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                          &oversight_event_params
                                      );
    } // if ( NULL != command_oversight )
    qcril_qmi_voice_voip_unlock_overview();

    if ( !covered_by_oversight_handling )
    {
      qcril_reqlist_public_type req_info;

      QCRIL_LOG_INFO("event_id = %s", qcril_log_lookup_event_name(params_ptr->event_id));

      if ((params_ptr->event_id == QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD ||
                  params_ptr->event_id == QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD_v01) &&
              (qcril_reqlist_query(QCRIL_DEFAULT_INSTANCE_ID,
                                   params_ptr->t, &req_info) == E_SUCCESS) &&
              req_info.req_data)
      {
        QCRIL_LOG_INFO("LCH response..");
        qcril_qmi_voice_update_set_local_call_hold_response_state(&req_info,
                QCRIL_REQ_AWAITING_CALLBACK, qmi_result, qmi_error);
      }
      else
      {
        if(mng_calls_resp->failure_cause_valid == TRUE)
        {
          QCRIL_LOG_ERROR("QCRIL QMI VOICE MNG CALLS RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
              mng_calls_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
          /* Send UNSOL msg with SS error code first */
          qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( mng_calls_resp->failure_cause,
              VOICE_INVALID_CALL_ID );
        }
        /* Send response */
        qcril_send_empty_payload_request_response(instance_id,
            params_ptr->t,params_ptr->event_id, ril_err);
      }
    } // if ( !covered_by_oversight_handling )

    if ( QCRIL_EVT_IMS_SOCKET_REQ_HANGUP_FOREGROUND_RESUME_BACKGROUND == params_ptr->event_id ||
         QCRIL_EVT_IMS_SOCKET_REQ_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE == params_ptr->event_id ||
         QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND == params_ptr->event_id ||
         QCRIL_EVT_RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE == params_ptr->event_id ||
         QCRIL_EVT_IMS_SOCKET_REQ_RESUME == params_ptr->event_id )
    {
      qcril_qmi_voice_voip_unmark_all_with(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE);
      if (RIL_E_SUCCESS != ril_err)
      {
#ifndef QMI_RIL_UTF
        qcril_am_handle_event(QCRIL_AM_EVENT_SWITCH_CALL_FAIL, NULL);
#endif
      }
    }

    if (ril_err != RIL_E_SUCCESS)
    {
      if (params_ptr->event_id == QCRIL_EVT_RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE)
      {
        qcril_qmi_voice_voip_mark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
      }
      else if (params_ptr->event_id == QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND)
      {
        qcril_qmi_voice_voip_unmark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_CONVERSATION_V02);
        qcril_qmi_voice_voip_mark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
      }
      else if (params_ptr->event_id == QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND)
      {
        qcril_qmi_voice_voip_unmark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_WAITING_V02);
        qcril_qmi_voice_voip_mark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
        qcril_qmi_voice_voip_unmark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_INCOMING_V02);
        qcril_qmi_voice_voip_mark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_INCOMING_V02);
        qcril_qmi_voice_voip_unmark_with_specified_call_state(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_HOLD_V02);
      }
    }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
}/* qcril_qmi_voice_sups_cmd_mng_calls_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_set_sups_service_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle SET SUPS Service RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_set_sups_service_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_set_sups_service_resp_msg_v02 *set_sups_service_resp = NULL;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  char sups_service_resp_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
  int utf8_len = 0;

  QCRIL_LOG_FUNC_ENTRY();

  if (params_ptr->data != NULL)
  {
    set_sups_service_resp = (voice_set_sups_service_resp_msg_v02 *)params_ptr->data;
    qmi_result = set_sups_service_resp->resp.result;
    qmi_error = set_sups_service_resp->resp.error;

    if (!qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
          instance_id,
          &set_sups_service_resp->resp,
          NULL,
          set_sups_service_resp->alpha_ident_valid,
          &set_sups_service_resp->alpha_ident,
          set_sups_service_resp->call_id_valid,
          set_sups_service_resp->call_id,
          set_sups_service_resp->cc_sups_result_valid,
          &set_sups_service_resp->cc_sups_result,
          set_sups_service_resp->cc_result_type_valid,
          &set_sups_service_resp->cc_result_type))
    {
      if ((qmi_result == QMI_RESULT_SUCCESS_V01) && (qmi_error == QMI_ERR_NONE_V01))
      {
        QCRIL_LOG_INFO("QCRIL QMI VOICE SET SUPS RESP: SUCCESS");
        qcril_send_empty_payload_request_response(instance_id, params_ptr->t,
            params_ptr->event_id, RIL_E_SUCCESS);
      }
      else
      {
        ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
        QCRIL_LOG_ERROR("QCRIL QMI VOICE SET SUPS RESP: FAILURE ril_err = %d", ril_err);

        if (set_sups_service_resp->failure_cause_valid)
        {
          QCRIL_LOG_ERROR("QCRIL QMI VOICE SET SUPS RESP sups_failure_cause=%d,"
              " for Token ID= %" PRId32 "", set_sups_service_resp->failure_cause,
              qcril_log_get_token_id(params_ptr->t));

          /* Send oem_hook_unsol_resp if not an IMS request */
          if (!qcril_is_event_in_group(params_ptr->event_id, &QCRIL_GRP_IMS))
          {
            /* Send UNSOL msg with SS error code first */
            qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp (
                set_sups_service_resp->failure_cause,
                (set_sups_service_resp->call_id_valid ?
                 set_sups_service_resp->call_id : VOICE_INVALID_CALL_ID));
          }
        }

        if ((QCRIL_EVT_IMS_SOCKET_REQ_SET_CALL_FORWARD_STATUS == params_ptr->event_id) ||
            (QCRIL_EVT_IMS_SOCKET_REQ_SET_CALL_WAITING == params_ptr->event_id) ||
            (QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS == params_ptr->event_id) ||
            (QCRIL_EVT_IMS_SOCKET_REQ_SET_COLR == params_ptr->event_id))
        {
          ims_SuppSvcResponse supp_svc_resp;
          memset(&supp_svc_resp, 0, sizeof(supp_svc_resp));

          if (set_sups_service_resp->failure_cause_description_valid)
          {
            memset(sups_service_resp_utf8_str, 0x0, sizeof(sups_service_resp_utf8_str));
            utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                (char *) set_sups_service_resp->failure_cause_description,
                set_sups_service_resp->failure_cause_description_len * 2,
                sups_service_resp_utf8_str,
                sizeof(sups_service_resp_utf8_str));
            utf8_len = utf8_len + 1;
            if (utf8_len > (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN))
            {
              QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
              utf8_len = (int) (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
              sups_service_resp_utf8_str[utf8_len-1] = '\0';
            }

            supp_svc_resp.has_errorDetails = TRUE;
            supp_svc_resp.errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
            if (supp_svc_resp.errorDetails.sipErrorString.arg)
            {
              strlcpy((char *)supp_svc_resp.errorDetails.sipErrorString.arg,
                  sups_service_resp_utf8_str, utf8_len);
            }
            supp_svc_resp.failureCause.arg = qcril_malloc(utf8_len);
            if (supp_svc_resp.failureCause.arg)
            {
              strlcpy((char*)supp_svc_resp.failureCause.arg, sups_service_resp_utf8_str, utf8_len);
            }
          }

          if (set_sups_service_resp->sip_error_code_valid)
          {
            supp_svc_resp.has_errorDetails = TRUE;
            supp_svc_resp.errorDetails.has_sipErrorCode = TRUE;
            supp_svc_resp.errorDetails.sipErrorCode = set_sups_service_resp->sip_error_code;
          }

          if (supp_svc_resp.has_errorDetails)
          {
            QCRIL_LOG_INFO("sip_error_code (%s): %d, sip_error_string: %s",
                supp_svc_resp.errorDetails.has_sipErrorCode ? "valid" : "not valid",
                supp_svc_resp.errorDetails.sipErrorCode,
                supp_svc_resp.errorDetails.sipErrorString.arg);
          }

          imsRadioSendMessage(params_ptr->t,
              ims_MsgType_RESPONSE,
              qcril_qmi_ims_map_event_to_request(params_ptr->event_id),
              qcril_qmi_ims_map_ril_error_to_ims_error(ril_err),
              (void *)&supp_svc_resp,
              sizeof(supp_svc_resp));

          qcril_free(supp_svc_resp.failureCause.arg);
          qcril_free(supp_svc_resp.errorDetails.sipErrorString.arg);
        }
        else
        {
          /* Send FAILURE response */
          qcril_send_empty_payload_request_response(instance_id, params_ptr->t,
              params_ptr->event_id, ril_err);
        }
      }
    }
  }
  else
  {
    qcril_send_empty_payload_request_response(instance_id, params_ptr->t,
        params_ptr->event_id, RIL_E_SYSTEM_ERR);
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_set_sups_service_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_get_clip_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle GET CLIP RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_get_clip_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_clip_resp_msg_v02 *get_clip_resp;
  RIL_Errno ril_err;
  RIL_Errno ril_result;
  qcril_request_resp_params_type resp;
  qmi_error_type_v01  qmi_error;
  int response[ 1 ];
  char get_clip_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
  int  utf8_len = 0;

  memset( response, 0, sizeof ( response ) );
  memset( &resp, 0, sizeof ( resp ) );

  if( params_ptr->data != NULL )
  {
    // memset(get_clip_resp,0,sizeof(voice_get_clip_resp_msg_v02));
    /* Entry found in the ReqList */

    QCRIL_LOG_INFO("params_ptr->data is not NULL");
    get_clip_resp = (voice_get_clip_resp_msg_v02 *)params_ptr->data;
    qmi_error = get_clip_resp->resp.error;
    ril_result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                   QMI_NO_ERR,
                   &get_clip_resp->resp);

    if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                             QCRIL_DEFAULT_INSTANCE_ID,
                                             &get_clip_resp->resp,
                                             NULL,
                                             get_clip_resp->alpha_id_valid,
                                             &get_clip_resp->alpha_id,
                                             get_clip_resp->call_id_valid,
                                             get_clip_resp->call_id,
                                             get_clip_resp->cc_sups_result_valid,
                                             &get_clip_resp->cc_sups_result,
                                             get_clip_resp->cc_result_type_valid,
                                             &get_clip_resp->cc_result_type
                                             )
         )
    { // not stk cc case
      response[0] = QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
      if( get_clip_resp->clip_response_valid == TRUE )
      {
        // FIXME: Address the issue of using provision_status rather than
        // active_status for get_clip_resp Tlvs.
        // qcril_qmi_voice_map_qmi_to_ril_provision_status(
        //         get_clip_resp->clip_response.provision_status,
        //         &response[0]);
        if (get_clip_resp->clip_response.active_status == ACTIVE_STATUS_INACTIVE_V02)
        {
          response[0] = QCRIL_QMI_VOICE_CLIR_SRV_NOT_PROVISIONED;
        }
        else if (get_clip_resp->clip_response.active_status == ACTIVE_STATUS_ACTIVE_V02)
        {
          response[0] = QCRIL_QMI_VOICE_CLIR_SRV_PROVISIONED_PERMANENT;
        }
      }
      QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET CLIP RESP response[0]=%d, for Token ID= %" PRId32 "", response[0],qcril_log_get_token_id( params_ptr->t ));

      if( RIL_E_SUCCESS == ril_result )
      {
        QCRIL_LOG_INFO("QCRIL QMI VOICE GET CLIP RESP: SUCCESS");
        if (QCRIL_EVT_RIL_REQUEST_QUERY_CLIP == params_ptr->event_id)
        {
          qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                             params_ptr->t,
                                             params_ptr->event_id,
                                             RIL_E_SUCCESS,
                                             &resp );
          resp.resp_pkt = (void *) response;
          resp.resp_len = sizeof( response );
          qcril_send_request_response( &resp );
        }
        else
        {
           ims_ClipProvisionStatus clip;
           memset(&clip, 0, sizeof(clip));

           clip.has_clip_status = TRUE;
           clip.clip_status = (ims_ClipStatus)response[0];
           imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_QUERY_CLIP, ims_Error_E_SUCCESS, (void *)&clip, sizeof(clip));
        }
      }
      else
      {
        QCRIL_LOG_INFO("QCRIL QMI VOICE GET CLIP RESP: FAILURE");

        if(get_clip_resp->failure_cause_valid == TRUE)
        {
          QCRIL_LOG_ERROR("QCRIL QMI VOICE GET CLIP RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
              get_clip_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
          if (QCRIL_EVT_RIL_REQUEST_QUERY_CLIP == params_ptr->event_id)
          {
            /* Send UNSOL msg with SS error code first */
            qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( get_clip_resp->failure_cause,
              (get_clip_resp->call_id_valid ? get_clip_resp->call_id : VOICE_INVALID_CALL_ID) );
          }
        }

        if (QCRIL_EVT_RIL_REQUEST_QUERY_CLIP != params_ptr->event_id &&
            (get_clip_resp->sip_error_code_valid == TRUE ||
             get_clip_resp->failure_cause_description_valid == TRUE))
        {
           ims_ClipProvisionStatus clip;
           memset(&clip, 0, sizeof(clip));
           clip.has_errorDetails = TRUE;

           if ( get_clip_resp->sip_error_code_valid == TRUE )
           {
             clip.errorDetails.has_sipErrorCode = TRUE;
             clip.errorDetails.sipErrorCode = get_clip_resp->sip_error_code;
             QCRIL_LOG_INFO("sip_error_code %d", clip.errorDetails.sipErrorCode);
           }

           if ( get_clip_resp->failure_cause_description_valid == TRUE )
           {
             memset(get_clip_sip_err_utf8_str, 0x0,
                  sizeof(get_clip_sip_err_utf8_str));
             utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                              (char *)get_clip_resp->failure_cause_description,
                              get_clip_resp->failure_cause_description_len * 2,
                              get_clip_sip_err_utf8_str,
                              sizeof(get_clip_sip_err_utf8_str));
             utf8_len = utf8_len + 1;
             if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN ) )
             {
               QCRIL_LOG_ERROR ("Length exceeds maximum sip error size" );
               utf8_len = (int) (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
               get_clip_sip_err_utf8_str[ utf8_len - 1] = '\0';
             }
             QCRIL_LOG_ERROR("QCRIL QMI VOICE GET CLIP RESP len =%d,"
                             "failure_description=%s", utf8_len,
                             get_clip_sip_err_utf8_str);
             clip.errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
             if ( clip.errorDetails.sipErrorString.arg )
             {
               strlcpy((char *)clip.errorDetails.sipErrorString.arg,
                       get_clip_sip_err_utf8_str, utf8_len);
               QCRIL_LOG_INFO("sip_error_string %s", clip.errorDetails.sipErrorString.arg);
             }
           }

           imsRadioSendMessage(params_ptr->t,
                                     ims_MsgType_RESPONSE,
                                     ims_MsgId_REQUEST_QUERY_CLIP,
                                     ims_Error_E_GENERIC_FAILURE,
                                     (void *)&clip, sizeof(clip));
           qcril_free(clip.errorDetails.sipErrorString.arg);
        }
        else
        {
          ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
          /* Send FAILURE response */
          qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                     params_ptr->t,
                                                     params_ptr->event_id,
                                                     ril_err );
        }
      }
    }
  }
  else
  {
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       RIL_E_SYSTEM_ERR,
                                       &resp );
    qcril_send_request_response( &resp );
  }
}/* qcril_qmi_voice_get_clip_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_get_colp_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI VOICE GET COLP RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_get_colp_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_colp_resp_msg_v02 *get_colp_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_result = RIL_E_GENERIC_FAILURE;
  ims_Error ims_error = ims_Error_E_GENERIC_FAILURE;
  qmi_error_type_v01  qmi_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  if( params_ptr->data != NULL )
  {
    get_colp_resp = (voice_get_colp_resp_msg_v02 *)params_ptr->data;
    qmi_error = get_colp_resp->resp.error;
    ril_result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
      QMI_NO_ERR,
      &get_colp_resp->resp);
    if (RIL_E_SUCCESS == ril_result)
    {
      QCRIL_LOG_INFO("QCRIL QMI VOICE GET COLP RESP: SUCCESS");
    }
    else
    {
      QCRIL_LOG_INFO("QCRIL QMI VOICE GET COLP RESP: FAILURE");
    }
    if(get_colp_resp->failure_cause_valid == TRUE)
    {
      QCRIL_LOG_ERROR("QCRIL QMI VOICE GET COLP RESP sups_failure_cause=%d,\
        for Token ID= %" PRId32 "",
        get_colp_resp->failure_cause,
        qcril_log_get_token_id( params_ptr->t ));
    }
    ims_SuppSvcResponse supp_svc_response;
    memset(&supp_svc_response, 0, sizeof(supp_svc_response));
    qcril_qmi_voice_copy_colp_data(get_colp_resp, &supp_svc_response, ril_result, &ims_error);
    imsRadioSendMessage(params_ptr->t,
      ims_MsgType_RESPONSE,
      ims_MsgId_REQUEST_SUPP_SVC_STATUS,
      ims_error,
      (void *)&supp_svc_response,
      sizeof(supp_svc_response));
    if (supp_svc_response.has_errorDetails)
    {
      if (supp_svc_response.errorDetails.sipErrorString.arg)
      {
        qcril_free(supp_svc_response.errorDetails.sipErrorString.arg);
      }
    }
  }
  else
  {
    QCRIL_LOG_ERROR("params_ptr->data is NULL");
    qcril_send_empty_payload_request_response( instance_id,
      params_ptr->t,
      params_ptr->event_id,
      RIL_E_GENERIC_FAILURE );
  }
}/* qcril_qmi_voice_get_colp_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_get_clir_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle GET CLIR RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_get_clir_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_clir_resp_msg_v02 *get_clir_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  int response[ 2 ];
  boolean success=FALSE;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();

  if( params_ptr->data != NULL )
  {
    /* Entry found in the ReqList */

    QCRIL_LOG_INFO("params_ptr->data is not NULL");

    memset( response, 0, sizeof( response ) );

    get_clir_resp = (voice_get_clir_resp_msg_v02 *)params_ptr->data;
    qmi_result = get_clir_resp->resp.result;
    qmi_error = get_clir_resp->resp.error;
    if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                             instance_id,
                                             &get_clir_resp->resp,
                                             NULL,
                                             get_clir_resp->alpha_id_valid,
                                             &get_clir_resp->alpha_id,
                                             get_clir_resp->call_id_valid,
                                             get_clir_resp->call_id,
                                             get_clir_resp->cc_sups_result_valid,
                                             &get_clir_resp->cc_sups_result,
                                             get_clir_resp->cc_result_type_valid,
                                             &get_clir_resp->cc_result_type
                                             )
         )
    {
      if( (qmi_result == QMI_RESULT_SUCCESS_V01) && (qmi_error == QMI_ERR_SUPS_FAILURE_CAUSE_V01))
      {
        if(get_clir_resp->clir_response_valid == TRUE)
        {
          response[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
          response[0] = qcril_qmi_voice_info.clir;
          success = TRUE;
          QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET CLIR RESP response[0]=%d, response[1]= %d", response[0],response[1]);
        }
      }
      else
      {
        if ( (get_clir_resp->failure_cause_valid == TRUE) &&
             (get_clir_resp->failure_cause == QMI_FAILURE_CAUSE_FACILITY_NOT_SUPPORTED_V02) )
        {
            success = TRUE;

            QCRIL_LOG_DEBUG("feature_fac_not_supp_as_no_nw = %d\n",
                    feature_fac_not_supp_as_no_nw);
            if (feature_fac_not_supp_as_no_nw)
            {
              response[0] = QCRIL_QMI_VOICE_SS_CLIR_PRESENTATION_INDICATOR;
              response[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
            }
            else
            {
              //In case get_clir not supported by IMS at modem, then return cached value.
              if ( qcril_qmi_voice_info.clir == QCRIL_QMI_VOICE_SS_CLIR_INVOCATION_OPTION )
              {
                response[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_PRESENTATION_ALLOWED;
              }
              else if ( qcril_qmi_voice_info.clir == QCRIL_QMI_VOICE_SS_CLIR_SUPPRESSION_OPTION )
              {
                response[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_PRESENTATION_RESTRICTED;
              }
              else
              {
                response[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_PRESENTATION_ALLOWED;
              }
              response[0] = qcril_qmi_voice_info.clir;
            }
        }
        else if ((get_clir_resp->clir_response_valid == TRUE) && (qmi_error == QMI_ERR_NONE_V01))
        {
          response[0] = qcril_qmi_voice_info.clir;
          success = qcril_qmi_voice_map_qmi_to_ril_provision_status(
                  get_clir_resp->clir_response.provision_status,
                  &response[1]);
          QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET CLIR RESP response[0]=%d, response[1]= %d", response[0],response[1]);
        }
        else
        {
          QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET CLIR RESP : FAILURE");
          success = FALSE;
        }
      }

      if( success )
      {
        QCRIL_LOG_INFO("QCRIL QMI VOICE GET CLIR RESP: SUCCESS");
        if (QCRIL_EVT_RIL_REQUEST_GET_CLIR == params_ptr->event_id)
        {
           qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
           resp.resp_pkt = (void *) response;
           resp.resp_len = sizeof( response );
           qcril_send_request_response( &resp );
        }
        else
        {
           ims_Clir clir;
           memset(&clir, 0, sizeof(clir));

           clir.has_param_m = TRUE;
           clir.param_m = response[1];
           clir.has_param_n = TRUE;
           clir.param_n = response[0];
           imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_GET_CLIR, ims_Error_E_SUCCESS, (void *)&clir, sizeof(clir));
        }
      }
      else
      {
        QCRIL_LOG_INFO("QCRIL QMI VOICE GET CLIR RESP: FAILURE");

        if (get_clir_resp->failure_cause_valid)
        {
          QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET CLIR RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
              get_clir_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
          /* Send UNSOL msg with SS error code first */
          qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( get_clir_resp->failure_cause,
              (get_clir_resp->call_id_valid ? get_clir_resp->call_id : VOICE_INVALID_CALL_ID) );
        }

        ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
        /* Send FAILURE response */
        qcril_send_empty_payload_request_response( instance_id, params_ptr->t,params_ptr->event_id, ril_err );
      }
    }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
  QCRIL_LOG_FUNC_RETURN();
}/* qcril_qmi_voice_get_clir_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_query_call_waiting_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Query Call Waiting RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_query_call_waiting_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_call_waiting_resp_msg_v02 *get_cw_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  ims_CallWaitingInfo ims_resp;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  int response[ 2 ];
  char call_waiting_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
  int utf8_len = 0;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  memset(&ims_resp, 0, sizeof(ims_resp));

  if( params_ptr->data != NULL )
  {
      /* Entry found in the ReqList */

      QCRIL_LOG_INFO("params_ptr->data is not NULL");

      get_cw_resp = (voice_get_call_waiting_resp_msg_v02 *)params_ptr->data;
      qmi_result = get_cw_resp->resp.result;
      qmi_error = get_cw_resp->resp.error;
      QCRIL_LOG_INFO("QCRIL QMI VOICE Query Call Waiting qmi_error : %d", qmi_error );

      if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                               instance_id,
                                               &get_cw_resp->resp,
                                               NULL,
                                               get_cw_resp->alpha_id_valid,
                                               &get_cw_resp->alpha_id,
                                               get_cw_resp->call_id_valid,
                                               get_cw_resp->call_id,
                                               get_cw_resp->cc_sups_result_valid,
                                               &get_cw_resp->cc_sups_result,
                                               get_cw_resp->cc_result_type_valid,
                                               &get_cw_resp->cc_result_type
                                               )
           )
      {
          if((qmi_result == QMI_RESULT_SUCCESS_V01) && (get_cw_resp->service_class_valid == TRUE))
          {
            if(get_cw_resp->service_class == 0x00)
            {
              response[0] = FALSE;
              QCRIL_LOG_INFO("QCRIL QMI VOICE Query Call Waiting : Disabled for : %d",get_cw_resp->service_class);
            }
            else
            {
              response[0] = TRUE;
              QCRIL_LOG_INFO("QCRIL QMI VOICE Query Call Waiting : Enabled for : %d",get_cw_resp->service_class);
            }
            response[1] = get_cw_resp->service_class;
            if (QCRIL_EVT_RIL_REQUEST_QUERY_CALL_WAITING == params_ptr->event_id)
            {
               qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
               resp.resp_pkt = (void *) response;
               resp.resp_len = sizeof( response );
               qcril_send_request_response( &resp );
            }
            else
            {
               qcril_qmi_ims_translate_ril_service_status_class_to_ims_callwaitinginfo(response[0], response[1], &ims_resp);
               imsRadioSendMessage( params_ptr->t,
                                          ims_MsgType_RESPONSE,
                                          ims_MsgId_REQUEST_QUERY_CALL_WAITING,
                                          ims_Error_E_SUCCESS,
                                          (void *)&ims_resp,
                                          sizeof(ims_resp)
                                         );
            }
          }
          else
          {
            QCRIL_LOG_INFO("QCRIL QMI VOICE Query Call Waiting RESP: FAILURE");

            if(get_cw_resp->failure_cause_valid == TRUE)
            {
              QCRIL_LOG_ERROR("QCRIL QMI VOICE Query call waiting RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
                  get_cw_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
              /* Send UNSOL msg with SS error code first */
              qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( get_cw_resp->failure_cause,
                  (get_cw_resp->call_id_valid ? get_cw_resp->call_id : VOICE_INVALID_CALL_ID) );
            }

            /* Incase UT on IMS is not supported by the network, modem returns this
               error map it to IMS__ERROR__E_NETWORK_NOT_SUPPORTED so that it is
               known that UT service is not supported by the network */
            if((params_ptr->event_id != QCRIL_EVT_RIL_REQUEST_QUERY_CALL_WAITING) &&
               (qmi_error == QMI_ERR_OP_NETWORK_UNSUPPORTED_V01))
            {
               imsRadioSendMessage( params_ptr->t,
                                          ims_MsgType_RESPONSE,
                                          ims_MsgId_REQUEST_QUERY_CALL_WAITING,
                                          ims_Error_E_NETWORK_NOT_SUPPORTED,
                                          NULL, 0);
               QCRIL_LOG_INFO("QCRIL QMI VOICE Query Call Waiting RESP(ims): NETWORK_UNSUPPORTED");
            }
            else
            {
                if (get_cw_resp->sip_error_code_valid || get_cw_resp->failure_cause_description_valid)
                {
                  ims_resp.has_errorDetails = TRUE;
                  if (get_cw_resp->sip_error_code_valid)
                  {
                    ims_resp.errorDetails.has_sipErrorCode = TRUE;
                    ims_resp.errorDetails.sipErrorCode = get_cw_resp->sip_error_code;
                    QCRIL_LOG_INFO("sip_error_code %d", ims_resp.errorDetails.sipErrorCode);
                  }

                  if(get_cw_resp->failure_cause_description_valid == TRUE)
                  {
                    memset(call_waiting_sip_err_utf8_str, 0x0,
                           sizeof(call_waiting_sip_err_utf8_str));
                    utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                                             (char *)get_cw_resp->failure_cause_description,
                                             get_cw_resp->failure_cause_description_len * 2,
                                             call_waiting_sip_err_utf8_str,
                                             sizeof(call_waiting_sip_err_utf8_str));
                    utf8_len = utf8_len + 1;
                    if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN ) )
                    {
                      QCRIL_LOG_ERROR ("Length exceeds maximum sip error size" );
                      utf8_len = (int) (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
                      call_waiting_sip_err_utf8_str[ utf8_len - 1] = '\0';
                    }
                    QCRIL_LOG_ERROR("QCRIL QMI VOICE CALL WAITING RESP len =%d,"
                                    "failure_description=%s", utf8_len,
                                    call_waiting_sip_err_utf8_str);
                    ims_resp.errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
                    if ( ims_resp.errorDetails.sipErrorString.arg )
                    {
                      strlcpy((char *)ims_resp.errorDetails.sipErrorString.arg,
                              call_waiting_sip_err_utf8_str, utf8_len);
                      QCRIL_LOG_INFO("sipErrorString %s", ims_resp.errorDetails.sipErrorString.arg);
                    }
                  }
                  imsRadioSendMessage(params_ptr->t,
                                          ims_MsgType_RESPONSE,
                                          ims_MsgId_REQUEST_QUERY_CALL_WAITING,
                                          ims_Error_E_GENERIC_FAILURE,
                                          (void*)&ims_resp, sizeof(ims_resp));
                  qcril_free(ims_resp.errorDetails.sipErrorString.arg);
                }
                else
                {
                  ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
                  /* Send FAILURE response */
                  qcril_send_empty_payload_request_response( instance_id, params_ptr->t,params_ptr->event_id, ril_err );
                }
            }
          }

      }
  }
  else
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }
}/* qcril_qmi_voice_query_call_waiting_resp_hdlr */


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_change_call_barring_password_hdlr

===========================================================================*/
/*!
    @brief
    Handle Change Call Barring Password RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_change_call_barring_password_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_set_call_barring_password_resp_msg_v02 *change_cb_pwd_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {
      /* Entry found in the ReqList */

      QCRIL_LOG_INFO("params_ptr->data is not NULL");

      change_cb_pwd_resp = (voice_set_call_barring_password_resp_msg_v02 *)params_ptr->data;
      qmi_result = change_cb_pwd_resp->resp.result;
      qmi_error = change_cb_pwd_resp->resp.error;
      QCRIL_LOG_INFO("QCRIL QMI VOICE Change Call barring pwd, qmi_error : %d", qmi_error );

      if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                               instance_id,
                                               &change_cb_pwd_resp->resp,
                                               NULL,
                                               change_cb_pwd_resp->alpha_id_valid,
                                               &change_cb_pwd_resp->alpha_id,
                                               change_cb_pwd_resp->call_id_valid,
                                               change_cb_pwd_resp->call_id,
                                               change_cb_pwd_resp->cc_sups_result_valid,
                                               &change_cb_pwd_resp->cc_sups_result,
                                               change_cb_pwd_resp->cc_result_type_valid,
                                               &change_cb_pwd_resp->cc_result_type
                                               )
           )
      {
          if((qmi_result == QMI_RESULT_SUCCESS_V01) && ( qmi_error == QMI_ERR_NONE_V01))
          {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
            qcril_send_request_response( &resp );
          }
          else
          {
            QCRIL_LOG_INFO("QCRIL QMI VOICE Change Call barring pwd: FAILURE");

            if(change_cb_pwd_resp->failure_cause_valid == TRUE)
            {
              QCRIL_LOG_ERROR("QCRIL QMI VOICE Change Call barring pwd RESP, sups_failure_cause=%d, for Token ID= %" PRId32 "",
                  change_cb_pwd_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
              /* Send UNSOL msg with SS error code first */
              qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp (
                  change_cb_pwd_resp->failure_cause,
                  (change_cb_pwd_resp->call_id_valid ?
                   change_cb_pwd_resp->call_id : VOICE_INVALID_CALL_ID) );
            }

            ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
            /* Send FAILURE response */
            if( ( RIL_E_MODEM_ERR == ril_err ) &&
                ( TRUE == change_cb_pwd_resp->failure_cause_valid ) &&
                ( QMI_FAILURE_CAUSE_NEGATIVE_PWD_CHECK_V02 == change_cb_pwd_resp->failure_cause ) )
            {
                ril_err = RIL_E_PASSWORD_INCORRECT;
            }

            qcril_default_request_resp_params( instance_id, params_ptr->t,params_ptr->event_id, ril_err, &resp );
            qcril_send_request_response( &resp );
          }

      }
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
    qcril_send_request_response( &resp );
  }
}/* qcril_qmi_voice_change_call_barring_password_resp_hdlr */



/*=========================================================================
  FUNCTION:  qcril_qmi_voice_query_facility_lock_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Query Facility lock RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_query_facility_lock_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_call_barring_resp_msg_v02 *get_cb_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  int response[ 1 ];
  uint32_t i=0, j=0;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  if( params_ptr->data != NULL )
  {
    /* Entry found in the ReqList */

    QCRIL_LOG_INFO("params_ptr->data is not NULL");

    get_cb_resp = (voice_get_call_barring_resp_msg_v02 *)params_ptr->data;
    qmi_result = get_cb_resp->resp.result;
    qmi_error = get_cb_resp->resp.error;
    QCRIL_LOG_INFO("QCRIL QMI VOICE Query Facility lock qmi_error : %d", qmi_error );

    if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                             instance_id,
                                             &get_cb_resp->resp,
                                             NULL,
                                             get_cb_resp->alpha_id_valid,
                                             &get_cb_resp->alpha_id,
                                             get_cb_resp->call_id_valid,
                                             get_cb_resp->call_id,
                                             get_cb_resp->cc_sups_result_valid,
                                             &get_cb_resp->cc_sups_result,
                                             get_cb_resp->cc_result_type_valid,
                                             &get_cb_resp->cc_result_type
                                             )
         )
    {
        if((qmi_result == QMI_RESULT_SUCCESS_V01) && (get_cb_resp->service_class_valid == TRUE))
        {
          if(get_cb_resp->service_class == 0x00)
          {
            response[0] = get_cb_resp->service_class;
            QCRIL_LOG_INFO("QCRIL QMI VOICE Query Facility Lock : Disabled for All Services, Service_class : %d",get_cb_resp->service_class);
          }
          else
          {
            response[0] = get_cb_resp->service_class;
            QCRIL_LOG_INFO("QCRIL QMI VOICE Query Facility Lock : Enabled for Service_class: %d",get_cb_resp->service_class);
          }

          if( QCRIL_EVT_RIL_REQUEST_QUERY_FACILITY_LOCK == params_ptr->event_id )
          {
            qcril_default_request_resp_params( instance_id,
                                               params_ptr->t,
                                               params_ptr->event_id,
                                               RIL_E_SUCCESS,
                                               &resp );
            resp.resp_pkt = (void *) &response[ 0 ];
            resp.resp_len = sizeof( response[ 0 ] );
            qcril_send_request_response( &resp );
          }
          else /* QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS */
          {
            ims_SuppSvcResponse supp_svc_response;
            memset(&supp_svc_response, 0,sizeof(supp_svc_response));

            supp_svc_response.has_status = TRUE;
            supp_svc_response.status = response[0] ?\
              ims_ServiceClassStatus_ENABLED : ims_ServiceClassStatus_DISABLED;

            if (get_cb_resp->cc_sups_result_valid == TRUE)
            {
              supp_svc_response.has_facilityType = qcril_qmi_voice_map_qmi_reason_to_ims_facility(
                  get_cb_resp->cc_sups_result.reason,
                  (ims_SuppSvcFacilityType *)&supp_svc_response.facilityType);
            }
            else
            {
              supp_svc_response.has_facilityType = FALSE;
              QCRIL_LOG_INFO("QCRIL QMI VOICE Get Call Barring No Reason Type");
            }

            ims_CbNumList *cb_num_list_ptr = NULL;
            ims_CbNumList **cb_num_list_dptr = NULL;

            ims_CbNumListType *cb_num_list_type_ptr = NULL;

            if (get_cb_resp->sc_barred_numbers_status_list_valid)
            {
              uint32_t cb_num_list_len = 0;

              cb_num_list_type_ptr = (ims_CbNumListType*)qcril_malloc(sizeof(ims_CbNumListType) *
                               get_cb_resp->sc_barred_numbers_status_list_len);

              supp_svc_response.cbNumListType.arg = qcril_malloc(sizeof(ims_CbNumListType**) *
                      (get_cb_resp->sc_barred_numbers_status_list_len+1));

              if (cb_num_list_type_ptr && supp_svc_response.cbNumListType.arg)
              {
                for (i=0; i<get_cb_resp->sc_barred_numbers_status_list_len; i++)
                {
                  cb_num_list_len =
                        get_cb_resp->sc_barred_numbers_status_list[i].\
                                           call_barring_numbers_list_len;

                  QCRIL_LOG_INFO("cb_num_list_len for service class %d is: %d",
                                get_cb_resp->sc_barred_numbers_status_list[i].\
                                service_class_ext, cb_num_list_len);

                  cb_num_list_ptr = (ims_CbNumList*)qcril_malloc(sizeof(ims_CbNumList) *
                                                         cb_num_list_len);
                  cb_num_list_dptr = (ims_CbNumList**)qcril_malloc(sizeof(ims_CbNumList*) *
                                                       (cb_num_list_len+1));


                  if (cb_num_list_ptr && cb_num_list_dptr)
                  {

                    ((ims_CbNumListType**)supp_svc_response.cbNumListType.arg)[i] =
                                                           &cb_num_list_type_ptr[i];

                    cb_num_list_type_ptr[i].has_serviceClass = TRUE;
                    cb_num_list_type_ptr[i].serviceClass.has_service_Class = TRUE;
                    cb_num_list_type_ptr[i].serviceClass.service_Class =
                            get_cb_resp->sc_barred_numbers_status_list[i].service_class_ext;

                    cb_num_list_type_ptr[i].cb_num_list.arg = (void*) cb_num_list_dptr;

                    for (j=0;
                       j<get_cb_resp->sc_barred_numbers_status_list[i].call_barring_numbers_list_len;
                       j++)
                    {
                        cb_num_list_dptr[j] = &cb_num_list_ptr[j];

                        cb_num_list_ptr[j].has_status = TRUE;
                        cb_num_list_ptr[j].status = (ims_ServiceClassStatus)
          get_cb_resp->sc_barred_numbers_status_list[i].call_barring_numbers_list[j].active_status;
                        cb_num_list_ptr[j].number.arg =
          get_cb_resp->sc_barred_numbers_status_list[i].call_barring_numbers_list[j].barred_number;
                    }
                  }
                  else
                  {
                    QCRIL_LOG_ERROR("malloc failed");
                  }
                }
              }
              else
              {
                QCRIL_LOG_ERROR("malloc failed");
              }
            }
            imsRadioSendMessage(params_ptr->t,
                                      ims_MsgType_RESPONSE,
                                      ims_MsgId_REQUEST_SUPP_SVC_STATUS,
                                      ims_Error_E_SUCCESS,
                                      (void *)&supp_svc_response,
                                      sizeof(supp_svc_response));

            if(cb_num_list_type_ptr)
            {
              for (i=0; i<get_cb_resp->sc_barred_numbers_status_list_len; i++)
              {
                cb_num_list_dptr = (ims_CbNumList **)cb_num_list_type_ptr[i].cb_num_list.arg;
                if (cb_num_list_dptr)
                {
                  cb_num_list_ptr = cb_num_list_dptr[0];
                  if (cb_num_list_ptr)
                  {
                    qcril_free(cb_num_list_ptr);
                  }
                  qcril_free(cb_num_list_dptr);
                }
              }
              qcril_free(cb_num_list_type_ptr);
            }
            if (supp_svc_response.cbNumListType.arg)
            {
              qcril_free(supp_svc_response.cbNumListType.arg);
            }
          }
        }
        else
        {
          QCRIL_LOG_INFO("QCRIL QMI VOICE Query Facility Lock RESP: FAILURE");

          if(get_cb_resp->failure_cause_valid == TRUE)
          {
            QCRIL_LOG_ERROR("QCRIL QMI VOICE Query Facility Lock RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
                get_cb_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
            if( QCRIL_EVT_RIL_REQUEST_QUERY_FACILITY_LOCK == params_ptr->event_id )
            {
              /* Send UNSOL msg with SS error code first */
              qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( get_cb_resp->failure_cause,
                (get_cb_resp->call_id_valid ? get_cb_resp->call_id : VOICE_INVALID_CALL_ID) );
            }
          }
          ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
          /* Send FAILURE response */
          qcril_send_empty_payload_request_response( instance_id,
                                                     params_ptr->t,
                                                     params_ptr->event_id,
                                                     ril_err );
        }
    }
  }
  else
  {
    if( QCRIL_EVT_RIL_REQUEST_QUERY_FACILITY_LOCK == params_ptr->event_id )
    {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         RIL_E_SYSTEM_ERR,
                                         &resp );
      qcril_send_request_response( &resp );
    }
    else /* QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS */
    {
      qcril_send_empty_payload_request_response( instance_id,
                                                 params_ptr->t,
                                                 params_ptr->event_id,
                                                 RIL_E_SYSTEM_ERR );
    }
  }
}/* qcril_qmi_voice_query_facility_lock_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_query_call_forward_status_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Query Call Forwarding RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_query_call_forward_status_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_call_forwarding_resp_msg_v02 *get_cf_resp;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  qcril_qmi_voice_callforwd_info_param_u_type response_buffer[ QCRIL_QMI_VOICE_CFW_RESPONSE_BUF_SZ ];
  qcril_qmi_voice_callforwd_info_param_u_type *response[ QCRIL_QMI_VOICE_CFW_RESPONSE_BUF_SZ ];
  ims_CallForwardInfoList ims_resp;
  memset(&ims_resp, 0, sizeof(ims_resp));

  uint32_t call_forwarding_info_len = 0;
  voice_get_call_forwarding_info_type_v02 *call_fwd_info_ptr;
  uint8_t service_class;

  char * resp_num_ptr;
  uint32 interm_num_len;
  voice_get_call_forwarding_info_type_v02 *cur_fwd_info_slot;
  qcril_qmi_voice_callforwd_info_param_u_type* resp_buf_slot;
  voice_time_type_v02 *call_fwd_start_time = NULL;;
  voice_time_type_v02 *call_fwd_end_time = NULL;;
  qcril_reqlist_public_type req_info;
  int reason = QCRIL_QMI_VOICE_CCFC_REASON_UNCOND;
  char call_forward_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
  int utf8_len = 0;

  QCRIL_LOG_FUNC_ENTRY();

  memset( (void*) response_buffer, 0, sizeof( response_buffer ) );
  memset( (void*) response, 0, sizeof( response ) );


  if( params_ptr->data != NULL )
  {
        QCRIL_LOG_INFO("params_ptr->data is not NULL");

        get_cf_resp = (voice_get_call_forwarding_resp_msg_v02 *)params_ptr->data;
        qmi_result = get_cf_resp->resp.result;
        qmi_error = get_cf_resp->resp.error;
        QCRIL_LOG_INFO("qmi result %d, qmi_error %d", qmi_result, qmi_error );

        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( QMI_NO_ERR, &get_cf_resp->resp );
        QCRIL_LOG_INFO("resp ril err : %d", ril_err );

        if ((qcril_reqlist_query(QCRIL_DEFAULT_INSTANCE_ID,
                params_ptr->t, &req_info) == E_SUCCESS) &&
            (req_info.req_data != NULL))
        {
          reason = *((int *)req_info.req_data);
        }
        QCRIL_LOG_INFO("reason = %d", reason);

        if ( !qcril_qmi_voice_stk_ss_resp_handle(params_ptr,
                                                 QCRIL_DEFAULT_INSTANCE_ID,
                                                 &get_cf_resp->resp,
                                                 NULL,
                                                 get_cf_resp->alpha_id_valid,
                                                 &get_cf_resp->alpha_id,
                                                 get_cf_resp->call_id_valid,
                                                 get_cf_resp->call_id,
                                                 get_cf_resp->cc_sups_result_valid,
                                                 &get_cf_resp->cc_sups_result,
                                                 get_cf_resp->cc_result_type_valid,
                                                 &get_cf_resp->cc_result_type
                                                 )
             )
        {
              call_fwd_info_ptr = get_cf_resp->get_call_forwarding_info;
              QCRIL_LOG_INFO("cf info valid %d", (int)get_cf_resp->get_call_forwarding_info_valid );
              if ( RIL_E_SUCCESS == ril_err &&
                   get_cf_resp->get_call_forwarding_info_valid
                  )
              {
                    size_t i=0, j=0;
                    uint32_t num_of_instances = 0;
                    call_forwarding_info_len = get_cf_resp->get_call_forwarding_info_len;
                    int instance_merged = FALSE;
                    QCRIL_LOG_INFO("cf info len %d", (int)call_forwarding_info_len );

                    for (i = 0;  i < call_forwarding_info_len && i < GET_CALL_FORWARDING_INFO_MAX_V02 && i < QCRIL_QMI_VOICE_CFW_RESPONSE_BUF_SZ; i++ )
                    {
                      cur_fwd_info_slot = &get_cf_resp->get_call_forwarding_info [ i ];

                      // Try to merge this instance with previous instances
                      instance_merged = FALSE;
                      for ( j = 0 ; j < num_of_instances; j++ )
                      {
                        resp_buf_slot = &response_buffer[ j ];

                        if ( resp_buf_slot->number != NULL  )
                        {
                          interm_num_len = strlen( resp_buf_slot->number );
                        }
                        else
                        {
                          interm_num_len = QMI_RIL_ZERO;
                        }
                        if ( ( interm_num_len == cur_fwd_info_slot->number_len ) &&
                             ( QMI_RIL_ZERO == cur_fwd_info_slot->number_len ||
                                   strncmp( cur_fwd_info_slot->number, resp_buf_slot->number,
                                            cur_fwd_info_slot->number_len ) == 0) &&
                             ( cur_fwd_info_slot->service_status == resp_buf_slot->status ) &&
                             ( cur_fwd_info_slot->no_reply_timer == resp_buf_slot->no_reply_timer ) )
                        {
                          // Number, status and timer are same, merge the service_class
                          resp_buf_slot->service_class |= cur_fwd_info_slot->service_class;
                          instance_merged = TRUE;
                          QCRIL_LOG_INFO( "service class 0x%x is merged with %d",
                                          cur_fwd_info_slot->service_class, j );
                        }
                      }

                      if ( !instance_merged )
                      {
                        resp_buf_slot = &response_buffer[num_of_instances];

                        // We can't merge it. So we get a new qcril_qmi_voice_callforwd_info_param_u_type record.
                        resp_buf_slot->status = cur_fwd_info_slot->service_status;

                        service_class = cur_fwd_info_slot->service_class;
                        if ( QMI_RIL_ZERO == service_class )
                        {
                          service_class = QMI_RIL_FF;
                          QCRIL_LOG_INFO( "service_class adjusted to 0xFF for single instance" );
                        }
                        resp_buf_slot->service_class = service_class;
                        resp_buf_slot->reason = reason;
                        interm_num_len = cur_fwd_info_slot->number_len;
                        if ( interm_num_len > QMI_RIL_ZERO )
                        {
                          resp_num_ptr = (char *)qcril_malloc( interm_num_len + 1 );
                          if ( resp_num_ptr )
                          {
                            memcpy( resp_num_ptr, cur_fwd_info_slot->number, interm_num_len );
                            resp_num_ptr[ interm_num_len ] = QMI_RIL_ZERO;

                            resp_buf_slot->toa = ( QCRIl_QMI_VOICE_SS_TA_INTER_PREFIX == *resp_num_ptr ) ?
                                  QCRIL_QMI_VOICE_SS_TA_INTERNATIONAL : QCRIL_QMI_VOICE_SS_TA_UNKNOWN;
                            resp_buf_slot->number = resp_num_ptr;
                            QCRIL_LOG_INFO( "instance %d, response_number = %s, toa = %d", (int) num_of_instances,
                                                                                         resp_buf_slot->number,
                                                                                         (int) resp_buf_slot->toa );
                          }
                          else
                          {
                            QCRIL_LOG_ERROR("out of memory");
                            break;
                          }
                        }

                        if ( cur_fwd_info_slot->no_reply_timer != QMI_RIL_ZERO )
                        {
                          resp_buf_slot->no_reply_timer = cur_fwd_info_slot->no_reply_timer;
                          QCRIL_LOG_INFO( "no_reply_timer = %d", resp_buf_slot->no_reply_timer );
                        }

                        QCRIL_LOG_INFO("Status = %d,Service_class = %d,reason = %d",
                                       resp_buf_slot->status,
                                       resp_buf_slot->service_class,
                                       resp_buf_slot->reason);

                        response[ num_of_instances ] = &response_buffer[num_of_instances];

                        num_of_instances++;
                      }
                    }
                    QCRIL_LOG_INFO("num_of_instances: %d", num_of_instances);

                    if (get_cf_resp->call_fwd_start_time_valid)
                    {
                       call_fwd_start_time = &(get_cf_resp->call_fwd_start_time);
                    }

                    if (get_cf_resp->call_fwd_end_time_valid)
                    {
                       call_fwd_end_time = &(get_cf_resp->call_fwd_end_time);
                    }

                    if ( num_of_instances > 0 )
                    {
                      if (QCRIL_EVT_RIL_REQUEST_QUERY_CALL_FORWARD_STATUS == params_ptr->event_id)
                      {
                        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
                        resp.resp_pkt = (void *) response;
                        resp.resp_len = sizeof(qcril_qmi_voice_callforwd_info_param_u_type *) * num_of_instances;
                        qcril_send_request_response( &resp );
                      }
                      else
                      {
                        qcril_qmi_ims_translate_ril_callforwdinfo_to_ims_callforwdinfo(
                                response_buffer, num_of_instances,
                                call_fwd_start_time, call_fwd_end_time,
                                &ims_resp);
                        imsRadioSendMessage( params_ptr->t,
                                                   ims_MsgType_RESPONSE,
                                                   ims_MsgId_REQUEST_QUERY_CALL_FORWARD_STATUS,
                                                   ims_Error_E_SUCCESS,
                                                   (void *)&ims_resp,
                                                   sizeof(ims_resp)
                                                  );
                        qcril_qmi_npb_release(ims_CallForwardInfoList_fields, &ims_resp);

                      }

                      for ( i=0; i<num_of_instances && i <GET_CALL_FORWARDING_INFO_MAX_V02 && i < QCRIL_QMI_VOICE_CFW_RESPONSE_BUF_SZ ; i++ )
                      {
                        if (response_buffer[ i ].number )
                        {
                          qcril_free( response_buffer[ i ].number );
                        }
                      }
                    }
                    else
                    { // no numbers
                      response_buffer[ 0 ].status = FALSE;
                      /* if call forwarding is interrogated for specific service class, include only that service class in response */
                      if ( call_fwd_info_ptr[0].service_class != 0 )
                      {
                        response_buffer[ 0 ].service_class = call_fwd_info_ptr[0].service_class;
                      }
                      else
                      {
                        response_buffer[ 0 ].service_class = 0xff;
                      }
                      response_buffer[ 0 ].reason = reason;
                      response[ 0 ] = &response_buffer[ 0 ];
                      if (QCRIL_EVT_RIL_REQUEST_QUERY_CALL_FORWARD_STATUS == params_ptr->event_id)
                      {
                        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
                        resp.resp_pkt = (void *) response;
                        resp.resp_len = sizeof( qcril_qmi_voice_callforwd_info_param_u_type * );
                        qcril_send_request_response( &resp );
                      }
                      else
                      {
                        qcril_qmi_ims_translate_ril_callforwdinfo_to_ims_callforwdinfo(
                                response_buffer, num_of_instances,
                                call_fwd_start_time, call_fwd_end_time,
                                &ims_resp);
                        imsRadioSendMessage( params_ptr->t,
                                                   ims_MsgType_RESPONSE,
                                                   ims_MsgId_REQUEST_QUERY_CALL_FORWARD_STATUS,
                                                   ims_Error_E_SUCCESS,
                                                   (void *)&ims_resp,
                                                   sizeof(ims_resp)
                                                  );
                        qcril_qmi_npb_release(ims_CallForwardInfoList_fields, &ims_resp);
                      }
                    }
            }
            else
            {
              if(get_cf_resp->failure_cause_valid == TRUE)
              {
                QCRIL_LOG_ERROR("RESP : sups_failure_cause=%d, for Token ID= %" PRId32 "",
                    get_cf_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));
                /* Send UNSOL msg with SS error code first */
                qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( get_cf_resp->failure_cause,
                    (get_cf_resp->call_id_valid ? get_cf_resp->call_id : VOICE_INVALID_CALL_ID) );
              }

              /* Incase UT on IMS is not supported by the network, modem returns this
                 error map it to IMS__ERROR__E_NETWORK_NOT_SUPPORTED so that it is
                 known that UT service is not supported by the network */
              if (params_ptr->event_id != QCRIL_EVT_RIL_REQUEST_QUERY_CALL_FORWARD_STATUS)
              {
                  ims_Error error = (qmi_error != QMI_ERR_OP_NETWORK_UNSUPPORTED_V01) ?
                                    qcril_qmi_ims_map_ril_error_to_ims_error(ril_err):
                                    ims_Error_E_NETWORK_NOT_SUPPORTED;

                  ims_CallForwardInfoList ims_cf_resp;
                  memset(&ims_cf_resp, 0, sizeof(ims_cf_resp));

                  if(get_cf_resp->sip_error_code_valid == TRUE ||
                     get_cf_resp->failure_cause_description_valid == TRUE)
                  {
                    ims_cf_resp.has_errorDetails = TRUE;
                    if(get_cf_resp->sip_error_code_valid == TRUE) {
                      ims_cf_resp.errorDetails.has_sipErrorCode = TRUE;
                      ims_cf_resp.errorDetails.sipErrorCode = get_cf_resp->sip_error_code;
                      QCRIL_LOG_INFO("sip_error_code %d", ims_cf_resp.errorDetails.sipErrorCode);
                    }
                    if(get_cf_resp->failure_cause_description_valid == TRUE)
                    {
                      memset(call_forward_sip_err_utf8_str, 0x0,
                           sizeof(call_forward_sip_err_utf8_str));
                      utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                                               (char *)get_cf_resp->failure_cause_description,
                                               get_cf_resp->failure_cause_description_len * 2,
                                               call_forward_sip_err_utf8_str,
                                               sizeof(call_forward_sip_err_utf8_str));
                      utf8_len = utf8_len + 1;
                      if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN ) )
                      {
                        QCRIL_LOG_ERROR ("Length exceeds maximum sip error size" );
                        utf8_len = (int) (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
                        call_forward_sip_err_utf8_str[ utf8_len - 1] = '\0';
                      }
                      QCRIL_LOG_ERROR("QCRIL QMI VOICE CALL FORWARD RESP len =%d,"
                                      "failure_description=%s", utf8_len,
                                      call_forward_sip_err_utf8_str);
                      ims_cf_resp.errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
                      if ( ims_cf_resp.errorDetails.sipErrorString.arg )
                      {
                        strlcpy((char *)ims_cf_resp.errorDetails.sipErrorString.arg,
                                call_forward_sip_err_utf8_str, utf8_len);
                        QCRIL_LOG_INFO("sip_error_string %s",
                                       ims_cf_resp.errorDetails.sipErrorString.arg);
                      }
                    }
                  }
                  else
                  {
                    ims_cf_resp.has_errorDetails = FALSE;
                  }
                  imsRadioSendMessage( params_ptr->t,
                                             ims_MsgType_RESPONSE,
                                             ims_MsgId_REQUEST_QUERY_CALL_FORWARD_STATUS,
                                             error,
                                             (void *)&ims_cf_resp, sizeof(ims_cf_resp));
                  qcril_free(ims_cf_resp.errorDetails.sipErrorString.arg);
              }
              else
              {
                  qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t,params_ptr->event_id, ril_err );
              }
            }
        }
  }
  else
  {
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR );
  }

  QCRIL_LOG_FUNC_RETURN();

}/* qcril_qmi_voice_query_call_forward_status_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_orig_ussd_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Orig USSD RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_orig_ussd_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_orig_ussd_resp_msg_v02 *orig_ussd_resp;
  qcril_instance_id_e_type instance_id;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;
  char ussd_utf8_str[QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2];
  char type_code[2];
  char *response_buff[2];
  int utf8_len =0;
  qcril_request_resp_params_type resp;
  qcril_unsol_resp_params_type unsol_resp;
  uint8 uss_dcs=QCRIL_QMI_VOICE_USSD_DCS_UNSPECIFIED;
  boolean success = TRUE;
  RIL_Errno ril_err;
  qcril_qmi_voice_stk_cc_modification_e_type stk_cc_modification;
  int i=0;

  qcril_request_resp_params_type ril_response;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  do
  {
    if( params_ptr->data != NULL )
    {
      /* Entry found in the ReqList */

      QCRIL_LOG_INFO("params_ptr->data is not NULL");

      memset( ussd_utf8_str, '\0', sizeof( ussd_utf8_str ) );
      memset( type_code, '\0', sizeof( type_code ) );
      memset( response_buff, 0, sizeof( response_buff ) );

      orig_ussd_resp = (voice_orig_ussd_resp_msg_v02 *)params_ptr->data;
      qmi_result = orig_ussd_resp->resp.result;
      qmi_error = orig_ussd_resp->resp.error;
      QCRIL_LOG_INFO("QCRIL QMI VOICE Orig USSD Response qmi_error : %d", qmi_error );

      ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( QMI_NO_ERR,
                                                                            &orig_ussd_resp->resp,
                                                                            QCRIL_QMI_ERR_CTX_SEND_USSD_TXN,
                                                                            orig_ussd_resp );
      if (ril_err == RIL_E_USSD_MODIFIED_TO_DIAL_VIDEO)
      {
        // Telephony expects RIL_E_OEM_ERROR_1 for USSD_MODIFIED_TO_DIAL_VIDEO
        // on ril (cs) interface.
        ril_err = RIL_E_OEM_ERROR_1;
      }

      QCRIL_LOG_INFO("ORIG USSD RESP : ril_err=%d, orig_ussd_resp_result=%d, orig_ussd_resp_error=%d, cc_sups_result_valid=%d, cc_result_type_valid=%d, cc_result_type=%d",
                     (int)ril_err,
                     (int)orig_ussd_resp->resp.result,
                     (int)orig_ussd_resp->resp.error,
                     (int)orig_ussd_resp->cc_sups_result_valid,
                     (int)orig_ussd_resp->cc_result_type_valid,
                     (int)orig_ussd_resp->cc_result_type
                     );

      if( ril_err && orig_ussd_resp->cc_sups_result_valid)
      {
        QCRIL_LOG_INFO("Error Details : cc_sups_result_reason=%d, cc_sups_result_service=%d",orig_ussd_resp->cc_sups_result.reason,
                       orig_ussd_resp->cc_sups_result.service_type);
      }

      stk_cc_modification = qcril_qmi_voice_map_ril_error_to_stk_cc_modification_type((int)ril_err);

      if (ril_err == RIL_E_CANCELLED)
      {
        // Send success to telephony in case of CANCEL. This is to avoid error pop up
        // due to telephony design limitation when cancelling the multi USSD session.
        QCRIL_LOG_INFO("ril_err(%d) convert to RIL_E_SUCCESS", ril_err);
        ril_err = RIL_E_SUCCESS;
      }

      // QMI_VOICE can send valid Alpha in case of QMI_ERR_CARD_CALL_CONTROL_FAILED.
      // Handling Alpha for both success and failure cases.
      if ( orig_ussd_resp->alpha_id_valid )
      {
        stk_cc_info.alpha_ident = orig_ussd_resp->alpha_id;
        // Alpha id is present; return success.
        ril_err = RIL_E_SUCCESS;
      }
      else
      {
        memset( &stk_cc_info.alpha_ident, 0, sizeof( stk_cc_info.alpha_ident ) );
      }

      if ( QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE != stk_cc_modification )
      { // STK CC session started
        qcril_qmi_voice_reset_stk_cc();

        stk_cc_info.modification                      = stk_cc_modification;
        stk_cc_info.is_alpha_relayed                  = FALSE;

        if ( orig_ussd_resp->call_id_valid )
        {
          stk_cc_info.call_id_info = orig_ussd_resp->call_id;
        }

        if ( orig_ussd_resp->cc_sups_result_valid )
        {
          stk_cc_info.ss_ussd_info = orig_ussd_resp->cc_sups_result;
        }

        QCRIL_LOG_INFO( "org req altered. ril_err: %d, call_id: %d", (int)ril_err, (int)orig_ussd_resp->call_id );

        qcril_qmi_voice_stk_cc_dump();
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &ril_response );
        qcril_send_request_response( &ril_response );
      }
      else
      {
        if(orig_ussd_resp->failure_cause_valid == TRUE)
        {
          /* Send UNSOL msg with SS error code first */
          qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp ( orig_ussd_resp->failure_cause,
              (orig_ussd_resp->call_id_valid ? orig_ussd_resp->call_id : VOICE_INVALID_CALL_ID) );

          QCRIL_LOG_ERROR("QCRIL QMI VOICE Orig USSD RESP sups_failure_cause=%d, for Token ID= %" PRId32 "",
              orig_ussd_resp->failure_cause, qcril_log_get_token_id( params_ptr->t ));

          if( (orig_ussd_resp->failure_cause == QMI_FAILURE_CAUSE_FACILITY_REJECTED_V02) ||
              (orig_ussd_resp->failure_cause == QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK_V02 ) )
          {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_ABORTED, &resp );
            qcril_send_request_response( &resp );
            break;
          }
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_err, &resp );
        qcril_send_request_response( &resp );
        if (ril_err != RIL_E_SUCCESS)
        {
          QCRIL_LOG_ERROR("Failure response for SEND_USSD!! : ril_err=%d\n", ril_err);
          break;
        }

        /* send RIL_UNSOL_STK_CC_ALPHA_NOTIFY to Telephony if Alpha is valid */
        qcril_qmi_voice_stk_cc_relay_alpha_if_necessary(QCRIL_DEFAULT_INSTANCE_ID, TRUE);

        if( (qmi_result == QMI_RESULT_SUCCESS_V01) &&
            ( (orig_ussd_resp->uss_info_valid == TRUE) || (orig_ussd_resp->uss_info_utf16_valid == TRUE) )
          )
        {
          if ( orig_ussd_resp->uss_info_utf16_valid == TRUE ) // using uss_info_utf16 instead of uss_info if it is available
          {
            QCRIL_LOG_ERROR ("USSD Orig resp, utf16 len=%d", orig_ussd_resp->uss_info_utf16_len );

            utf8_len = qcril_cm_ss_convert_ucs2_to_utf8( (char *) orig_ussd_resp->uss_info_utf16, orig_ussd_resp->uss_info_utf16_len * 2, ussd_utf8_str, sizeof(ussd_utf8_str) );
            for(i=0 ; i< utf8_len ; i++ )
            {
              QCRIL_LOG_DEBUG ("utf8 data bytes : %x\n", ussd_utf8_str[ i ]);
            }
            if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
            {
              QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
              utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
              ussd_utf8_str[ utf8_len - 1] = '\0';
            }
          }
          else
          {
            QCRIL_LOG_ERROR ("USSD Orig resp dcs=%d , len=%d", orig_ussd_resp->uss_info.uss_dcs,orig_ussd_resp->uss_info.uss_data_len );
            switch(orig_ussd_resp->uss_info.uss_dcs)
            {
              case USS_DCS_ASCII_V02 :
                utf8_len = qcril_cm_ss_ascii_to_utf8((unsigned char *)orig_ussd_resp->uss_info.uss_data, orig_ussd_resp->uss_info.uss_data_len,
                                                     ussd_utf8_str, sizeof(ussd_utf8_str));
                break;
              case USS_DCS_8BIT_V02 :
                uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_8_BIT;
                utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( uss_dcs,
                                                                    orig_ussd_resp->uss_info.uss_data,
                                                                    orig_ussd_resp->uss_info.uss_data_len,
                                                                    ussd_utf8_str,
                                                                    sizeof(ussd_utf8_str) );
                if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
                {
                  QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
                  utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
                  ussd_utf8_str[ utf8_len - 1] = '\0';
                }
                break;
              case USS_DCS_UCS2_V02 :
                uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_UCS2;
                utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( uss_dcs,
                                                                    orig_ussd_resp->uss_info.uss_data,
                                                                    orig_ussd_resp->uss_info.uss_data_len,
                                                                    ussd_utf8_str,
                                                                    sizeof(ussd_utf8_str));
                if ( utf8_len > ( QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2 ) )
                {
                  QCRIL_LOG_ERROR ("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
                  utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
                  ussd_utf8_str[ utf8_len - 1] = '\0';
                }
                break;
              default :
                QCRIL_LOG_ERROR ("Invalid USSD dcs : %d", orig_ussd_resp->uss_info.uss_dcs );
                success = FALSE;
                break;
            }
          }

          if ( success )
          {
            type_code[ 0 ] = '0';  /* QCRIL_CM_SS_CUSD_RESULT_DONE */
            type_code[ 1 ] = '\0';
            response_buff[ 0 ] = type_code;

            if ( orig_ussd_resp->uss_info.uss_data_len > 0)
            {
              response_buff[ 1 ] = ussd_utf8_str;
            }
            else
            {
              response_buff[ 1 ] = NULL;
            }

            /* Sending the response received from the network for the USSD request */
            QCRIL_LOG_DEBUG ( "USSD Conf Success, data_len : %d", orig_ussd_resp->uss_info.uss_data_len );
            QCRIL_LOG_DEBUG ("USSD : type_code=%s",type_code);
            if ( NULL != response_buff[ 1 ] )
            {
              QCRIL_LOG_DEBUG ("USSD : response_buff[1]=%s",response_buff[ 1 ]);
              QCRIL_LOG_DEBUG ("USSD : strlen=%d",strlen(response_buff[ 1 ]));
            }
            else
            {
              QCRIL_LOG_DEBUG ("USSD : response_buff[1] is NULL");
            }
          }
          else
          {
             QCRIL_LOG_DEBUG ("USSD abort");
             type_code[ 0 ] = '2';  /* QCRIL_CM_SS_CUSD_RESULT_ABORT */
             type_code[ 1 ] = '\0';
             response_buff[ 0 ] = type_code;
             response_buff[ 1 ] = NULL;
          }

          qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
          unsol_resp.resp_pkt = (void *) response_buff;
          unsol_resp.resp_len = sizeof( response_buff );
          unsol_resp.logstr = NULL;
          qcril_send_unsol_response( &unsol_resp );
        }
        else
        {
          /* sending the unsol indication so that RIL can close the USSD session */
          if ( (orig_ussd_resp->failure_cause_valid == TRUE) &&
             (orig_ussd_resp->failure_cause == QMI_FAILURE_CAUSE_FACILITY_NOT_SUPPORTED_V02) ) /*facilityNotSupported*/
          {
            type_code[ 0 ] = '4';  /*QCRIL_CM_SS_CUSD_RESULT_NOSUP */
            type_code[ 1 ] = '\0';
          }
          else if (qmi_error == QMI_ERR_CARD_CALL_CONTROL_FAILED_V01)
          {
            type_code[ 0 ] = '3';  /* QCRIL_CM_SS_CUSD_RESULT_OTHER */
            type_code[ 1 ] = '\0';
          }
          else if (qmi_error == QMI_ERR_ABORTED_V01)
          {
            // User cancelled the on going ussd session.
            // Not required to send the UNSOL_ON_USSD
            break;
          }
          else
          {
            type_code[ 0 ] = '2';  /* QCRIL_CM_SS_CUSD_RESULT_ABORT */
            type_code[ 1 ] = '\0';
          }
          response_buff[ 0 ] = type_code;
          response_buff[ 1 ] = NULL;
          QCRIL_LOG_DEBUG ("USSD Failure: type_code=%s",type_code);
          qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
          unsol_resp.resp_pkt = (void *) response_buff;
          unsol_resp.resp_len = sizeof( response_buff );
          unsol_resp.logstr = NULL;
          qcril_send_unsol_response( &unsol_resp );
        }
      }
    }
    else
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
      qcril_send_request_response( &resp );
    }
  }while(0);
}/* qcril_qmi_voice_orig_ussd_resp_hdlr */

/*=========================================================================
  FUNCTION: qcril_qmi_voice_is_wps_call
===========================================================================*/
boolean qcril_qmi_voice_is_wps_call(const char* voice_dial_address)
{
  const char* WPS_CALL_PREFIX = "*272";
  return strncmp(voice_dial_address, WPS_CALL_PREFIX, strlen(WPS_CALL_PREFIX)) == 0;
} // qcril_qmi_voice_is_wps_call

/*=========================================================================
  FUNCTION: qcril_qmi_voice_wps_call_over_cs
===========================================================================*/
boolean qcril_qmi_voice_wps_call_over_cs()
{
  char mcc[NAS_MCC_MNC_MAX_SIZE] = {0};
  char mnc[NAS_MCC_MNC_MAX_SIZE] = {0};

  if (qcril_qmi_nas_fetch_mcc_mnc_of_current_system(mcc, mnc, TRUE, TRUE))
  {
    return qcril_db_query_wps_call_over_cs(mcc, mnc);
  }
  return false;
} // qcril_qmi_voice_wps_call_over_cs

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_answer_ussd_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Answer USSD RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_answer_ussd_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_answer_ussd_resp_msg_v02 *ans_ussd_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {

  /* Entry found in the ReqList */

  QCRIL_LOG_INFO("params_ptr->data is not NULL");

  ans_ussd_resp = (voice_answer_ussd_resp_msg_v02 *)params_ptr->data;
  qmi_result = ans_ussd_resp->resp.result;
  qmi_error = ans_ussd_resp->resp.error;
  QCRIL_LOG_INFO("QCRIL QMI VOICE Answer USSD qmi_error : %d", qmi_error );

  if(qmi_result == QMI_RESULT_SUCCESS_V01)
  {
    QCRIL_LOG_INFO("QCRIL QMI VOICE Answer USSD Success: user_act_req = %d",qcril_qmi_voice_info.ussd_user_action_required);
    qcril_qmi_voice_info.ussd_user_action_required = FALSE;
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_INFO("QCRIL QMI VOICE Answer USSD Failure: user_act_req = %d",qcril_qmi_voice_info.ussd_user_action_required);
    qcril_qmi_voice_info.ussd_user_action_required = FALSE;
    ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
    /* Send FAILURE response */
    qcril_default_request_resp_params( instance_id, params_ptr->t,params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
    qcril_send_request_response( &resp );
  }

}/* qcril_qmi_voice_answer_ussd_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_cancel_ussd_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle Cancel USSD RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_cancel_ussd_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_cancel_ussd_resp_msg_v02 *cancel_ussd_resp;
  qcril_instance_id_e_type instance_id;
  RIL_Errno ril_err;
  qcril_request_resp_params_type resp;
  qmi_result_type_v01 qmi_result;
  qmi_error_type_v01  qmi_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  if( params_ptr->data != NULL )
  {
  /* Entry found in the ReqList */

  QCRIL_LOG_INFO("params_ptr->data is not NULL");

  cancel_ussd_resp = (voice_cancel_ussd_resp_msg_v02 *)params_ptr->data;
  qmi_result = cancel_ussd_resp->resp.result;
  qmi_error = cancel_ussd_resp->resp.error;
  QCRIL_LOG_INFO("QCRIL QMI VOICE Cancel USSD qmi_error : %d", qmi_error );

  if(qmi_result == QMI_RESULT_SUCCESS_V01)
  {
    QCRIL_LOG_INFO("QCRIL QMI VOICE Cancel USSD Success: user_act_req = %d",qcril_qmi_voice_info.ussd_user_action_required);
    qcril_qmi_voice_info.ussd_user_action_required = FALSE;
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_INFO("QCRIL QMI VOICE Cancel USSD Failure: user_act_req = %d",qcril_qmi_voice_info.ussd_user_action_required);
    qcril_qmi_voice_info.ussd_user_action_required = FALSE;
    ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
    /* Send FAILURE response */
    qcril_default_request_resp_params( instance_id, params_ptr->t,params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SYSTEM_ERR, &resp );
    qcril_send_request_response( &resp );
  }

}/*qcril_qmi_voice_cancel_ussd_resp_hdlr*/

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_dial

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DIAL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_dial
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  RIL_Dial *in_data_ptr = NULL;
  ims_Dial *ims_in_data_ptr = NULL;
  qcril_reqlist_public_type reqlist_entry;
  voice_dial_call_req_msg_v02  dial_call_req_msg;
  int is_non_std_otasp;
  int is_conf_uri = FALSE;
  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  bool isCallPull = FALSE;
  bool isCallPull_valid = FALSE;
  bool isEncrypted = FALSE;
  bool isEncrypted_valid = FALSE;
  bool origination_number_valid = FALSE;
  const char* originating_number = NULL;
  bool is_secondary = FALSE;

  RIL_LastCallFailCause last_call_fail_cause = CALL_FAIL_NORMAL;

  uint32_t                                    nw_reg_status_overview;
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;
  RIL_Errno                                   call_setup_result;

  char * subaddr = NULL;
  size_t subaddr_len = 0;
  size_t addr_len = 0;
  size_t sip_uri_overflow_len = 0;
  char *sip_uri_overflow = NULL;
  int clir = QCRIL_QMI_VOICE_SS_CLIR_PRESENTATION_INDICATOR;
  RIL_UUS_Info *  uusInfo = NULL;    /* NULL or Pointer to User-User Signaling Information */
  ims_CallDetails *callDetails = NULL;
  char *token = NULL, *lastPtr = NULL;
  char *displayText = NULL;
  int rc = 0;

  qmi_ril_voice_ims_command_exec_oversight_type*                      command_oversight;
  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type   oversight_cmd_params;

  char voice_dial_address[QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN];
  qcril_qmi_voice_emer_num_ims_addr_info_type emer_num_ims_addr_info;

  size_t overlay_dial_num_len;

  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  QCRIL_LOG_FUNC_ENTRY();

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  memset(voice_dial_address, 0, sizeof(voice_dial_address));
  memset(&emer_num_ims_addr_info, 0, sizeof(emer_num_ims_addr_info));
  memset(&call_summary, 0, sizeof(call_summary));

  if (NULL == params_ptr || NULL == params_ptr->data)
  {
    QCRIL_LOG_INFO("params_ptr or params_ptr is NULL");
    return;
  }

  if (QCRIL_EVT_RIL_REQUEST_DIAL == params_ptr->event_id)
  {
    in_data_ptr = (RIL_Dial *)params_ptr->data;
    if (in_data_ptr->address)
    {
      strlcpy(voice_dial_address, in_data_ptr->address, sizeof(voice_dial_address));
    }
    clir = in_data_ptr->clir;
    uusInfo = in_data_ptr->uusInfo;
  }
  else
  {
    ims_in_data_ptr = (ims_Dial *)params_ptr->data;
    if (ims_in_data_ptr->address.arg)
    {
      strlcpy(voice_dial_address, (char*)(ims_in_data_ptr->address.arg),
              sizeof(voice_dial_address));
    }
    if (ims_in_data_ptr->has_clir)
    {
      clir = ims_in_data_ptr->clir;
    }
    if (ims_in_data_ptr->has_isCallPull)
    {
      isCallPull_valid = TRUE;
      isCallPull = ims_in_data_ptr->isCallPull;
    }
    if (ims_in_data_ptr->has_isEncrypted)
    {
      isEncrypted_valid = TRUE;
      isEncrypted = ims_in_data_ptr->isEncrypted;
    }
    if (ims_in_data_ptr->has_callDetails)
    {
      callDetails = &ims_in_data_ptr->callDetails;
      QCRIL_LOG_INFO("call domain: %d, call type: %d", callDetails->callDomain,
              callDetails->callType);

      if (callDetails->extras.arg)
      {
        void ** extras_iter = (void**) callDetails->extras.arg;
        while (*extras_iter)
        {
          char *extras_str = (char*)(*extras_iter);
          QCRIL_LOG_INFO("get extras: %s", extras_str);
          token = strtok_r(extras_str, "=", &lastPtr);
          if (token == NULL)
          {
            continue;
          }

          if(0 == strcmp(token, "DisplayText"))
          {
            //Retrieve the remaining string after DisplayText=<str>
            displayText = strtok_r(NULL, "\0", &lastPtr);
            QCRIL_LOG_INFO("%s: %s", token, displayText);
          }
          ++extras_iter;
        }
      }
    }

    if (ims_in_data_ptr->has_isConferenceUri)
    {
      is_conf_uri = ims_in_data_ptr->isConferenceUri;
    }
    QCRIL_LOG_INFO("is_conf_uri: %d", is_conf_uri);

    originating_number = (const char*)ims_in_data_ptr->originatingNumber.arg;
    if (originating_number && strlen(originating_number) > 0) {
        origination_number_valid = TRUE;
        is_secondary = ims_in_data_ptr->isSecondary;
    }
    QCRIL_LOG_INFO("origination_number_valid: %d", origination_number_valid);
    if (origination_number_valid) {
        QCRIL_LOG_INFO("originating number : %s", originating_number);
    }
  }

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/
  /* first check if it is emergency number and if it needs to be pending */
  int is_emergency_call = FALSE;
  int need_enforce_emergency_directly = FALSE;
  int is_emer_num_to_ims_addr = FALSE;
  int dial_pended = 0;
  unsigned int escv_type = 0;
  boolean is_alt_emer_retry = FALSE;

  if (!is_conf_uri)
  {
#ifndef USING_NAS_PUBLIC_API
    int is_number_part_of_ril_ecclist = qmi_ril_phone_number_is_emergency( voice_dial_address );
    int is_number_emergency_for_display_purpose_only = qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only( voice_dial_address );
    if (TRUE == is_number_emergency_for_display_purpose_only && qmi_ril_in_apm_leave_window())
    {
        if (!qcril_qmi_nas_has_normal_voice_call_capability())
        {
            PEND_EMER_LOCK();
            dial_pended = qcril_qmi_voice_pend_emergency_call(params_ptr);
            PEND_EMER_UNLOCK();
            // double check in case we miss the notification
            if (qcril_qmi_nas_has_normal_voice_call_capability())
                qcril_qmi_voice_trigger_possible_pending_emergency_call();
        }
    }
    if( TRUE == is_number_part_of_ril_ecclist && FALSE == is_number_emergency_for_display_purpose_only )
    {
      is_emergency_call = TRUE;
      need_enforce_emergency_directly = qmi_ril_nwreg_is_designated_number_enforcable_ncl( voice_dial_address );
      if (need_enforce_emergency_directly)
         escv_type = qcril_qmi_nas_get_escv_type(voice_dial_address);

      if( QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id &&
          TRUE == need_enforce_emergency_directly )
      {//IMS DIAL request - Convert the emergency number to IMS address If needed
        strlcpy(emer_num_ims_addr_info.emergency_number,
                voice_dial_address,
                sizeof(emer_num_ims_addr_info.emergency_number));

        is_emer_num_to_ims_addr = qmi_ril_nwreg_convert_emergency_number_to_ims_address(voice_dial_address);

        strlcpy(emer_num_ims_addr_info.ims_address,
                voice_dial_address,
                sizeof(emer_num_ims_addr_info.ims_address));
      }
    }
#else
    auto nas_interface = qcril_qmi_voice_get_nas_interface();
    if (nas_interface != nullptr) {
      EmergencyCallExtraInfo info;
      nas_interface->getEmergencyCallDetails(std::string(voice_dial_address), info);

      need_enforce_emergency_directly = info.enforceAsEmergency;
      bool is_display_only = info.isForDisplayPurposeOnly;
      is_emergency_call = (need_enforce_emergency_directly && (!is_display_only));
      if (info.emergencyCategoryValid)
        escv_type = info.emergencyCategory;

      if (QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id &&
          TRUE == need_enforce_emergency_directly) {
        strlcpy(emer_num_ims_addr_info.emergency_number,
                voice_dial_address,
                sizeof(emer_num_ims_addr_info.emergency_number));
        if (info.imsEmergencyAddressValid) {
          is_emer_num_to_ims_addr = 1;
          strlcpy(emer_num_ims_addr_info.ims_address,
                  info.imsEmergencyAddress.c_str(),
                  sizeof(emer_num_ims_addr_info.ims_address));
        }
      }
    } // nas_interface != null
#endif
    if (qmi_ril_is_alternate_emergency_call(voice_dial_address))
    {
      QCRIL_LOG_ESSENTIAL("Alternative emergency call retry case");
      is_alt_emer_retry = TRUE;
      is_emergency_call = TRUE;
      need_enforce_emergency_directly = TRUE;
      escv_type = qmi_ril_get_alternate_emergency_call_category();
    }
  }
  QCRIL_LOG_ESSENTIAL(".. is_emergency %d", is_emergency_call);
  QCRIL_LOG_ESSENTIAL(".. need_enforce_emergency_directly %d", need_enforce_emergency_directly );
  QCRIL_LOG_ESSENTIAL(".. is_emer_num_to_ims_addr %d", is_emer_num_to_ims_addr );
  QCRIL_LOG_ESSENTIAL(".. dial_pended %d", dial_pended);
  if (dial_pended)
    return;

  /*-----------------------------------------------------------------------*/
  QCRIL_LOG_INFO("Starting MO voice call: requesting qxdm logging\n");
  rc = qcril_start_diag_log();
  if (rc == 0)
  {
       QCRIL_LOG_INFO("logging started successfully\n");
  }

  boolean is_wps_call_over_cs = qcril_qmi_voice_is_wps_call(voice_dial_address) && qcril_qmi_voice_wps_call_over_cs();

  QCRIL_LOG_ESSENTIAL(".. is_wps_call_over_cs: %d", is_wps_call_over_cs);
  qcril_qmi_voice_voip_lock_overview();
  if (is_wps_call_over_cs)
  {
    qcril_qmi_voice_hangup_all_calls_vcl(qcril_qmi_voice_call_to_atel, TRUE);
  }

  qcril_qmi_voice_voip_generate_summary(&call_summary);


#ifndef USING_NAS_PUBLIC_API
  nw_reg_status_overview = qmi_ril_nw_reg_get_status_overview();
#else
  if (qcril_qmi_voice_nas_reported_info.status_overview_valid)
    nw_reg_status_overview = qcril_qmi_voice_nas_reported_info.status_overview;
  else
    nw_reg_status_overview = 0;
#endif

  QCRIL_LOG_INFO(".. nw reg status overview %d", (int)nw_reg_status_overview);
  call_info_entry        = NULL;
  call_setup_result      = RIL_E_GENERIC_FAILURE;
  command_oversight      = NULL;
  do
  {
      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
      {
        call_setup_result = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
        break;
      }

      if( TRUE == is_emergency_call )
      {
        call_setup_result = qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally();
        if( RIL_E_SUCCESS != call_setup_result )
        {
          call_setup_result = RIL_E_INVALID_STATE;
          break;
        }
      }
      if (qmi_ril_voice_is_audio_inactive_vcl() && !is_emergency_call)
      {
        call_setup_result = RIL_E_INVALID_STATE;
        break;
      }
      if ( params_ptr->datalen == 0 || params_ptr->data == NULL )
      {
        call_setup_result = RIL_E_INVALID_ARGUMENTS;
        break;
      }

      // check address/subaddress length overflow
      addr_len = strlen( voice_dial_address );

      if( addr_len > 0 )
      {
        if ( feature_subaddress_support_amp )
        {
          subaddr = strchr(voice_dial_address,'&');
        }

        if ( feature_subaddress_support && '*' != voice_dial_address[0] && subaddr == NULL )
        {
           subaddr = strchr(voice_dial_address, '*');
        }

        if (subaddr)
        {
           subaddr++;
           subaddr_len = addr_len - (subaddr - voice_dial_address);
           if (subaddr_len > 0)
           {

              const uint SUBADDR_LEN_MAX = QMI_VOICE_SUBADDRESS_LEN_MAX_V02 - 2; // by the limitation on QMI VOICE, need to reserve two bytes for them to add padding 0x50 and the NULL terminator
              if ( ((unsigned int)subaddr_len) > SUBADDR_LEN_MAX )
              {
                 QCRIL_LOG_ERROR("subaddr_len: %d is greater than SUBADDRESS_LEN_MAX(%d)",
                                 subaddr_len, SUBADDR_LEN_MAX );
                 call_setup_result = RIL_E_INVALID_ARGUMENTS;
                 break;
              }
              else
              {
                 addr_len = addr_len - 1 - subaddr_len;
              }
           }
        }
      }

      if ( addr_len == 0  && !is_conf_uri )
      {
        QCRIL_LOG_ERROR("Calling number is null");
        call_setup_result = RIL_E_INVALID_ARGUMENTS;
        break;
      }


      if (is_conf_uri)
      {
        if ( addr_len > QMI_VOICE_CONF_URI_LIST_MAX_LEN_V02 )
        {
          call_setup_result = RIL_E_INVALID_ARGUMENTS;
          break;
        }
      }
      else if (QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id)
      {
         /* In case of VoIP/VT, number(URI) can be larger than QMI_VOICE_NUMBER_MAX_V02 */
        if (voice_dial_address[0] == '+')
        {
          if (addr_len > (QMI_VOICE_NUMBER_MAX_V02 + QMI_VOICE_SIP_URI_OVERFLOW_MAX_V02))
          {
            call_setup_result = RIL_E_INVALID_ARGUMENTS;
            break;
          }
        }
        else
        {
          if (addr_len > (QMI_VOICE_NUMBER_MAX_V02 - 1 + QMI_VOICE_SIP_URI_OVERFLOW_MAX_V02))
          {
            call_setup_result = RIL_E_INVALID_ARGUMENTS;
            break;
          }
        }
      }
      else
      {
         if ( addr_len > QMI_VOICE_NUMBER_MAX_V02 )
         {
           call_setup_result = RIL_E_INVALID_ARGUMENTS;
           break;
         }
      }

      call_info_entry = qcril_qmi_voice_voip_create_call_info_entry(
              VOICE_INVALID_CALL_ID,
              INVALID_MEDIA_ID,
              TRUE,
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP,
              &call_setup_result );
      if ( NULL == call_info_entry )
      {
        break;
      }

      call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_QMI_ID_RECEIVED;

      call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_RIL_CALL_STATE_VALID;
      call_info_entry->ril_call_state = RIL_CALL_DIALING;
      if (is_alt_emer_retry)
      {
        qcril_qmi_voice_voip_call_info_set_single_elaboration(call_info_entry,
            QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_ALTERNATE_EMERGENCY_CALL, TRUE);
      }

      if (!is_conf_uri)
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;
        call_info_entry->voice_svc_remote_party_number.number_pi = PRESENTATION_NUM_ALLOWED_V02;
        call_info_entry->voice_svc_remote_party_number.number_len = std::min(sizeof(call_info_entry->voice_svc_remote_party_number.number),
                                                                             addr_len);
        memcpy(call_info_entry->voice_svc_remote_party_number.number, voice_dial_address, call_info_entry->voice_svc_remote_party_number.number_len);

        call_info_entry->voice_scv_info.is_mpty = FALSE;
      }
      else
      {
        call_info_entry->voice_scv_info.is_mpty = TRUE;
      }

      call_info_entry->voice_scv_info.direction = CALL_DIRECTION_MO_V02;

      call_info_entry->voice_scv_info.als = ALS_LINE1_V02;

      if( TRUE == is_emer_num_to_ims_addr )
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMER_NUM_TO_IMS_ADDR;
        memcpy(&call_info_entry->emer_num_ims_addr_info,
               &emer_num_ims_addr_info,
               sizeof(call_info_entry->emer_num_ims_addr_info));
      }

      if ( QCRIL_EVT_RIL_REQUEST_DIAL == params_ptr->event_id ||
           QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id )
      {
        command_oversight = qmi_ril_voice_ims_create_command_oversight(params_ptr->t,
                params_ptr->event_id, TRUE);
        if ( NULL != command_oversight )
        {
          qmi_ril_voice_ims_command_oversight_add_call_link( command_oversight,
                                                             QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN,
                                                             QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP,
                                                             VOICE_INVALID_CALL_ID,
                                                             CALL_STATE_ORIGINATING_V02 );

          memset( &oversight_cmd_params, 0, sizeof( oversight_cmd_params ) );
          oversight_cmd_params.locator.command_oversight = command_oversight;

          qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_COMMENCE_AWAIT_RESP_IND,
                                                            QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                                            &oversight_cmd_params );
        } // if ( NULL != command_oversight )
        else
        {
          call_setup_result = RIL_E_NO_MEMORY;
          break;
        }
      } // if ( QCRIL_EVT_RIL_REQUEST_DIAL == params_ptr->event_id )


      if ( is_emergency_call &&
           ( ( nw_reg_status_overview & QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE ) &&
           !(nw_reg_status_overview & QMI_RIL_NW_REG_FULL_SERVICE) )
          )
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EME_FROM_OOS |
                                        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
      }

      if ( is_emergency_call )
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMERGENCY_CALL;
      }

      if ( !is_emergency_call && !(nw_reg_status_overview & QMI_RIL_NW_REG_FULL_SERVICE) )
      { // non emergency ialed from OOS (specific to certain customer extensions)
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_DIAL_FROM_OOS |
                                        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING;
      }
#ifndef USING_NAS_PUBLIC_API
      unsigned int old_call_radio_tech = qcril_qmi_voice_nas_control_get_reported_voice_radio_tech();
#else
      unsigned int old_call_radio_tech = RADIO_TECH_UNKNOWN;
      if (qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid)
        old_call_radio_tech = qcril_qmi_voice_nas_reported_info.voice_radio_tech;
#endif
      unsigned int old_call_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(old_call_radio_tech);

      is_non_std_otasp = qmi_ril_phone_number_is_non_std_otasp( voice_dial_address ) && (RADIO_TECH_3GPP2 == old_call_radio_tech_family);
      QCRIL_LOG_INFO(".. is_non_std_otasp %d", is_non_std_otasp);

      memset(&dial_call_req_msg, 0, sizeof(dial_call_req_msg));


      QCRIL_LOG_INFO(".. Number sent %s",voice_dial_address);

      if (!is_conf_uri)
      {
        /* Copy the Calling address and subaddress*/
        if (NULL == subaddr || 0 == subaddr_len)
        {
          size_t len = addr_len;
          if (voice_dial_address[0] == '+')
          {
            // Max dial_number TLV length if number starts with '+' is 81
            if (addr_len > QMI_VOICE_NUMBER_MAX_V02)
            {
              len = QMI_VOICE_NUMBER_MAX_V02;
            }
          }
          else
          {
            // Max dial_number TLV length if number does not starts with '+' is 80
            if (addr_len > (QMI_VOICE_NUMBER_MAX_V02 - 1))
            {
              len = QMI_VOICE_NUMBER_MAX_V02-1;
            }
          }
          sip_uri_overflow_len = addr_len - len;
          sip_uri_overflow = voice_dial_address + len;
          memcpy(dial_call_req_msg.calling_number, voice_dial_address, len);
        }
        else
        {
          // address
          memcpy(dial_call_req_msg.calling_number, voice_dial_address,
                 std::min(sizeof(dial_call_req_msg.calling_number), addr_len));

          // subaddress
          dial_call_req_msg.called_party_subaddress_valid = TRUE;
          dial_call_req_msg.called_party_subaddress.extension_bit = 1; // Always set to 1 according to spec Table 10.5.119/3GPP TS 24.008
          dial_call_req_msg.called_party_subaddress.subaddress_type = SUBADDRESS_TYPE_NSAP_V02;
          dial_call_req_msg.called_party_subaddress.odd_even_ind = subaddr_len % 2;
          if(feature_subaddress_ia5_id_support)
          {
            dial_call_req_msg.called_party_subaddress.subaddress_len = subaddr_len + 1;
            memset(&dial_call_req_msg.called_party_subaddress.subaddress[0],'\0',QMI_VOICE_SUBADDRESS_LEN_MAX_V02);
            dial_call_req_msg.called_party_subaddress.subaddress[0] = QCRIL_QMI_VOICE_SUBADDRESS_IA5_IDENTIFIER;
            memcpy(&dial_call_req_msg.called_party_subaddress.subaddress[1], subaddr, subaddr_len);
          }
          else
          {
            memcpy( dial_call_req_msg.called_party_subaddress.subaddress, subaddr, subaddr_len);
            dial_call_req_msg.called_party_subaddress.subaddress_len = subaddr_len;
          }
        }
      }
      else
      {
        memcpy(dial_call_req_msg.calling_number, "Conference Call", strlen("Conference Call"));
        /* Copy the conf_uri_list */
        dial_call_req_msg.conf_uri_list_valid = TRUE;
        memcpy(dial_call_req_msg.conf_uri_list, voice_dial_address, addr_len);
      }

      // store STK CC emulation overlay number. we will free it at DIAL_RESP if not needed
      overlay_dial_num_len = strlen( voice_dial_address );
      call_info_entry->overlayed_number_storage_for_emulated_stk_cc = (char*)qcril_malloc( overlay_dial_num_len + 1);
      if ( NULL != call_info_entry->overlayed_number_storage_for_emulated_stk_cc )
      {
         strlcpy( call_info_entry->overlayed_number_storage_for_emulated_stk_cc, voice_dial_address, overlay_dial_num_len + 1 );
      }

      /* In case of VoIP/VT, number(URI) can be greater than QMI_VOICE_NUMBER_MAX_V02,
           in which copy the remaining to URI tlv */
      if (sip_uri_overflow && sip_uri_overflow_len)
      {
         QCRIL_LOG_INFO(".. set sip_uri_overflow TLV");
         memcpy(dial_call_req_msg.sip_uri_overflow, sip_uri_overflow,
                std::min(sizeof(dial_call_req_msg.sip_uri_overflow), sip_uri_overflow_len));
         dial_call_req_msg.sip_uri_overflow_valid = TRUE;
      }

      /* Set the clir type */
      /* Use CLIR setting specified in DIAL request */
      if ( clir == QCRIL_QMI_VOICE_SS_CLIR_INVOCATION_OPTION )
      {
          dial_call_req_msg.clir_type_valid = TRUE;
          dial_call_req_msg.clir_type = CLIR_INVOCATION_V02;
      }
      /* Use CLIR setting specified in DIAL request */
      else if ( clir == QCRIL_QMI_VOICE_SS_CLIR_SUPPRESSION_OPTION )
      {
          dial_call_req_msg.clir_type_valid = TRUE;
          dial_call_req_msg.clir_type = CLIR_SUPPRESSION_V02;
      }
      /* Use the default CLIR setting */
      else
      {
        clir = qcril_qmi_voice_info.clir;

        if ( clir == QCRIL_QMI_VOICE_SS_CLIR_INVOCATION_OPTION )
        {
          dial_call_req_msg.clir_type_valid = TRUE;
          dial_call_req_msg.clir_type = CLIR_INVOCATION_V02;
        }
        else if ( clir == QCRIL_QMI_VOICE_SS_CLIR_SUPPRESSION_OPTION )
        {
          dial_call_req_msg.clir_type_valid = TRUE;
          dial_call_req_msg.clir_type = CLIR_SUPPRESSION_V02;
        }
        else
        {
          dial_call_req_msg.clir_type_valid = FALSE;
        }
      }

      QCRIL_LOG_INFO(".. Clir type sent %d",dial_call_req_msg.clir_type);

      if ((QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id) &&
          dial_call_req_msg.clir_type_valid)
      {
        dial_call_req_msg.pi_valid = TRUE;
        dial_call_req_msg.pi = (dial_call_req_msg.clir_type == CLIR_INVOCATION_V02)
                                   ? IP_PRESENTATION_NUM_RESTRICTED_V02
                                   : IP_PRESENTATION_NUM_ALLOWED_V02;
      }

      /* If not set call type will be assumed to be VOICE ---- but we set it anyway */
      dial_call_req_msg.call_type_valid = TRUE;

      if (callDetails)
      {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN;
        qcril_qmi_voice_get_modem_call_type_info(callDetails->callType,
                                                 callDetails->callDomain,
                                                 FALSE,
                                                 &dial_call_req_msg.call_type,
                                                 &dial_call_req_msg.audio_attrib_valid,
                                                 &dial_call_req_msg.audio_attrib,
                                                 &dial_call_req_msg.video_attrib_valid,
                                                 &dial_call_req_msg.video_attrib);

        if ((RIL_CALL_DOMAIN_PS == (RIL_Call_Domain)callDetails->callDomain) &&
            ((CALL_TYPE_VOICE_IP_V02 == dial_call_req_msg.call_type) ||
             (CALL_TYPE_VT_V02 == dial_call_req_msg.call_type) ||
             (CALL_TYPE_EMERGENCY_IP_V02 == dial_call_req_msg.call_type) ||
             (CALL_TYPE_EMERGENCY_VT_V02 == dial_call_req_msg.call_type)))
        {
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
        }
        if (CALL_TYPE_VT_V02 == dial_call_req_msg.call_type ||
            CALL_TYPE_EMERGENCY_VT_V02 == dial_call_req_msg.call_type)
        {
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUDIO_ATTR_VALID;
          call_info_entry->voice_audio_attrib.call_attributes =
              VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VIDEO_ATTR_VALID;
          call_info_entry->voice_video_attrib.call_attributes =
              VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
        }
        if (callDetails->has_rttMode)
        {
          dial_call_req_msg.rtt_mode_valid = qcril_qmi_ims_map_ims_rtt_mode_to_qcril(
              callDetails->rttMode, &dial_call_req_msg.rtt_mode);
        }
      }
      else
      {
        dial_call_req_msg.call_type = CALL_TYPE_VOICE_V02;
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN;
      }

      /* set service type for dial request only if domain is other than PS (CS/AUTO)*/
      if (!(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN))
      {
        dial_call_req_msg.service_type_valid = TRUE;
        dial_call_req_msg.service_type =
            qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat(
                call_info_entry->elaboration);
      }

      /* Set the UUS Info if present */
      if ( uusInfo != NULL )
      {
        dial_call_req_msg.uus_valid = TRUE;

        if( uusInfo->uusData != NULL )
        {
           dial_call_req_msg.uus.uus_data_len = uusInfo->uusLength;
           memcpy(dial_call_req_msg.uus.uus_data, uusInfo->uusData, uusInfo->uusLength);
        }

        switch ( uusInfo->uusType )
        {
          case RIL_UUS_TYPE1_IMPLICIT:
            dial_call_req_msg.uus.uus_type = UUS_TYPE1_IMPLICIT_V02;
            break;

          case RIL_UUS_TYPE1_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE1_REQUIRED_V02;
            break;

          case RIL_UUS_TYPE1_NOT_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE1_NOT_REQUIRED_V02;
            break;

          case RIL_UUS_TYPE2_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE2_REQUIRED_V02;
            break;

          case RIL_UUS_TYPE2_NOT_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE2_NOT_REQUIRED_V02;
            break;

          case RIL_UUS_TYPE3_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE3_REQUIRED_V02;
            break;

          case RIL_UUS_TYPE3_NOT_REQUIRED:
            dial_call_req_msg.uus.uus_type = UUS_TYPE3_NOT_REQUIRED_V02;
            break;

          default:
            dial_call_req_msg.uus.uus_type = UUS_TYPE_DATA_V02;
            break;
        }
        switch ( uusInfo->uusDcs )
        {
          case RIL_UUS_DCS_USP:
            dial_call_req_msg.uus.uus_dcs  = UUS_DCS_USP_V02;
            break;

          case RIL_UUS_DCS_OSIHLP:
            dial_call_req_msg.uus.uus_dcs  = UUS_DCS_OHLP_V02;
            break;

          case RIL_UUS_DCS_X244:
            dial_call_req_msg.uus.uus_dcs  = UUS_DCS_X244_V02;
            break;

          case RIL_UUS_DCS_IA5c:
            dial_call_req_msg.uus.uus_dcs  = UUS_DCS_IA5_V02;
            break;

          case RIL_UUS_DCS_RMCF:  // todo: mapping
          default:
            break;
        }

        QCRIL_LOG_INFO("..  UUS info sent type %d, dcs %d, length %d",
                           dial_call_req_msg.uus.uus_type, dial_call_req_msg.uus.uus_dcs,
                           dial_call_req_msg.uus.uus_data_len);
      }

      if (displayText)
      {
        dial_call_req_msg.display_text_valid = TRUE;
        dial_call_req_msg.display_text_len = qcril_cm_ss_convert_utf8_to_ucs2(
            displayText, strlen(displayText), (char *)dial_call_req_msg.display_text,
            sizeof(dial_call_req_msg.display_text));
        if (dial_call_req_msg.display_text_len)
        {
          dial_call_req_msg.display_text_len /= 2;
        }
        QCRIL_LOG_ESSENTIAL(".. display text len: %d str: %s ", dial_call_req_msg.display_text_len,
                            dial_call_req_msg.display_text);
      }

      if (need_enforce_emergency_directly)
      {
        dial_call_req_msg.call_type_valid = TRUE;
        dial_call_req_msg.call_type =
            (dial_call_req_msg.call_type == CALL_TYPE_VT_V02 ? CALL_TYPE_EMERGENCY_VT_V02
                                                             : CALL_TYPE_EMERGENCY_V02);
        if (escv_type > 0)
        {
          dial_call_req_msg.emer_cat_valid = TRUE;
          dial_call_req_msg.emer_cat = escv_type;
        }
      }

      if (is_wps_call_over_cs)
      {
        dial_call_req_msg.call_type = CALL_TYPE_VOICE_V02;
        dial_call_req_msg.service_type_valid = TRUE;
        dial_call_req_msg.service_type = VOICE_DIAL_CALL_SRV_TYPE_CS_ONLY_V02;
      }

      if (is_non_std_otasp)
      {
        dial_call_req_msg.call_type_valid = TRUE;
        dial_call_req_msg.call_type       = CALL_TYPE_NON_STD_OTASP_V02;

        // Reset unwanted TLVs in case of NON_STD_OTASP
        dial_call_req_msg.rtt_mode_valid     = FALSE;
        dial_call_req_msg.audio_attrib_valid = FALSE;
        dial_call_req_msg.video_attrib_valid = FALSE;
        dial_call_req_msg.clir_type_valid    = FALSE;
        dial_call_req_msg.pi_valid           = FALSE;
        dial_call_req_msg.uus_valid          = FALSE;
        dial_call_req_msg.service_type_valid = FALSE;
      }

      QCRIL_LOG_DEBUG(".. final elaboration %x, %x hex", (uint32)(call_info_entry->elaboration >> 32),(uint32)call_info_entry->elaboration );
      QCRIL_LOG_DEBUG(".. call type set %d emer cat %x", (int)dial_call_req_msg.call_type, dial_call_req_msg.emer_cat);

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

      /* Send QMI VOICE DIAL CALL REQ */

      if(isCallPull_valid)
      {
        dial_call_req_msg.call_pull_valid = TRUE;
        dial_call_req_msg.call_pull = isCallPull;
      }

      if (feature_encrypted_calls_support && isEncrypted_valid)
      {
        dial_call_req_msg.is_secure_call_valid = TRUE;
        dial_call_req_msg.is_secure_call = isEncrypted;
      }

      if (origination_number_valid) {
        dial_call_req_msg.origination_number_valid = 1;
        strlcpy(dial_call_req_msg.origination_number, originating_number,
            sizeof(dial_call_req_msg.origination_number));
        dial_call_req_msg.is_secondary_valid = 1;
        dial_call_req_msg.is_secondary = is_secondary;
      }

      QCRIL_LOG_INFO("RTT_MODE in call is  %d , %d",
              (int)dial_call_req_msg.rtt_mode_valid,
                   (int)dial_call_req_msg.rtt_mode);

      if(!is_wps_call_over_cs || call_summary.nof_voip_calls == 0)
      {
        qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                    QMI_VOICE_DIAL_CALL_REQ_V02,
                                    &dial_call_req_msg,
                                    sizeof(voice_dial_call_req_msg_v02),
                                    sizeof(voice_dial_call_resp_msg_v02),
                                    qcril_qmi_voice_command_cb,
                                    (void*)(uintptr_t)user_data);
        QCRIL_LOG_INFO(".. qmi send async res %d", (int) qmi_client_error );
        // assign one result value
        call_setup_result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                            qmi_client_error,NULL );
      }
      else if(is_wps_call_over_cs)
      {
        has_wps_pending_dial = TRUE;
        memcpy(&wps_dial_request, &dial_call_req_msg, sizeof(voice_dial_call_req_msg_v02));
        wps_user_data = user_data;
        call_setup_result = RIL_E_SUCCESS;
      }
  } while (FALSE);

  if ( RIL_E_SUCCESS != call_setup_result )
  { // rollback
    QCRIL_LOG_INFO(".. rolling back with %d", (int) call_setup_result);
    qcril_send_empty_payload_request_response(instance_id, params_ptr->t, params_ptr->event_id, call_setup_result);
    last_call_fail_cause = (RIL_LastCallFailCause) CALL_END_CAUSE_CLIENT_END_V02;

    if ( call_info_entry )
    {
      qcril_qmi_voice_voip_destroy_call_info_entry( call_info_entry );
      call_info_entry = NULL;
    }
    if ( NULL != command_oversight )
    {
      qmi_ril_voice_ims_destroy_command_oversight( command_oversight );
    }
  }
  qcril_qmi_voice_voip_unlock_overview();

  if (qcril_qmi_voice_voip_call_info_entries_is_empty())
  {
      QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
      if (!qcril_stop_diag_log())
      {
          QCRIL_LOG_INFO("qxdm logging disabled successfully");
      }
  }

  qcril_qmi_voice_handle_new_last_call_failure_cause( last_call_fail_cause,
      TRUE, FALSE, 0, FALSE, 0, FALSE, NULL, call_info_entry);
  QCRIL_LOG_INFO(".. last_call_fail_cause %d", (int) last_call_fail_cause);

  if (QCRIL_EVT_IMS_SOCKET_REQ_DIAL == params_ptr->event_id)
  {
    qcril_qmi_voice_enable_voice_indications(TRUE);
  }
  QCRIL_LOG_FUNC_RETURN();

} /* qcril_qmi_voice_request_dial */

boolean qcril_qmi_voice_pend_emergency_call(const qcril_request_params_type* params_ptr)
{
  if (params_ptr && (QCRIL_EVT_RIL_REQUEST_DIAL == params_ptr->event_id))
  {
    RIL_Dial *holder = qcril_qmi_pending_emergency_call_info.dial_holder;
    if (!holder || !holder->address || !params_ptr || !params_ptr->data ||
        !((RIL_Dial*)params_ptr->data)->address)
    {
      qcril_qmi_pending_emergency_call_info.emergency_params_ptr.datalen = 0;
      qcril_qmi_pending_emergency_call_info.emergency_params_ptr.data = NULL;
      return FALSE;
    }

    // for CS pipe emergency call, only copy address. The other fields remain 0
    qcril_qmi_pending_emergency_call_info.emergency_params_ptr = *params_ptr;
    qcril_qmi_pending_emergency_call_info.emergency_params_ptr.data = holder;

    strlcpy(holder->address, ((RIL_Dial*)params_ptr->data)->address,
              QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
  }
  else
  {
    ims_Dial *holder = qcril_qmi_pending_emergency_call_info.ims_dial_holder;
    if (!holder || !holder->address.arg || !params_ptr || !params_ptr->data ||
        !((ims_Dial*)params_ptr->data)->address.arg)
    {
      qcril_qmi_pending_emergency_call_info.emergency_params_ptr.datalen = 0;
      qcril_qmi_pending_emergency_call_info.emergency_params_ptr.data = NULL;
      return FALSE;
    }

    // copy the params structure (token, event, data len)
    qcril_qmi_pending_emergency_call_info.emergency_params_ptr = *params_ptr;
    // copy the fields except address (callDetails, isCallPull....)
    void* arg = holder->address.arg;
    memcpy(holder, params_ptr->data, sizeof(*holder));
    // copy the address
    strlcpy((char*)arg, (const char*)((ims_Dial*)params_ptr->data)->address.arg,
                QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
    holder->address.arg = arg;
    // No need to copy extras for emergency call.
    holder->callDetails.extras.arg = NULL;
    qcril_qmi_pending_emergency_call_info.emergency_params_ptr.data = holder;
  }

  qcril_qmi_pending_emergency_call_info.is_emergency_call_pending = TRUE;
  return TRUE;
}

static void qcril_qmi_voice_dial_pending_emergency_call_handler(void* params)
{
  QCRIL_NOTUSED(params);
  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_request_dial(&qcril_qmi_pending_emergency_call_info.emergency_params_ptr, NULL);
}

void qcril_qmi_voice_trigger_possible_pending_emergency_call()
{
  PEND_EMER_LOCK();
  if (qcril_qmi_pending_emergency_call_info.is_emergency_call_pending)
  {
    QCRIL_LOG_DEBUG("trigger pending emergency call...");
    // dial in the [main] thread
    qcril_qmi_pending_emergency_call_info.is_emergency_call_pending = FALSE;
    qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            qcril_qmi_voice_dial_pending_emergency_call_handler,
            NULL,
            NULL);
  }
  PEND_EMER_UNLOCK();
}

//===========================================================================
// qcril_qmi_voice_get_current_call_name
//===========================================================================
IxErrnoType qcril_qmi_voice_get_current_call_name
(
 const qcril_qmi_voice_voip_call_info_entry_type *const call_info_entry, // in
 boolean                                          is_ims_req,            // in
 char                                           **name,                  // out
 int                                             *name_presentation       // out
)
{
  IxErrnoType result          = E_SUCCESS;
  uint32_t    caller_name_len = 0;
  const char       *caller_name_ptr = NULL;
  int         name_pi         = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;
  char        ip_caller_name[(QMI_VOICE_IP_CALLER_NAME_MAX_LEN_V02 * 2)] = "\0";

  QCRIL_LOG_INFO("Enter");

  do {
    if (!call_info_entry || !name_presentation || !name)
    {
      QCRIL_LOG_INFO("Invalid parameters!");
      result = E_INVALID_ARG;
      break;
    }

    *name_presentation = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;

    // ------------------------------------------------------------------------------------------
    // 1. Caller Name for IP Call - IMS specific and goes to name field and has the high priority
    // If IP call and ip_caller_name valid, then set the caller name in 'name' field
    // ------------------------------------------------------------------------------------------
    if ((call_info_entry->voice_scv_info.call_type == CALL_TYPE_VOICE_IP_V02 ||
         call_info_entry->voice_scv_info.call_type == CALL_TYPE_VT_V02 ||
         call_info_entry->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_IP_V02 ||
         call_info_entry->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_VT_V02) &&
        (call_info_entry->ip_caller_name_valid))
    {
      QCRIL_LOG_INFO("ip caller name len: %d, caller name:",
                     call_info_entry->ip_caller_name.ip_caller_name_len);
      qcril_qmi_print_hex((unsigned char *)call_info_entry->ip_caller_name.ip_caller_name,
                          call_info_entry->ip_caller_name.ip_caller_name_len*2);

      // ip caller name TLV is valid. Set the name field
      caller_name_len = qcril_cm_ss_convert_ucs2_to_utf8(
                                       (const char *)call_info_entry->ip_caller_name.ip_caller_name,
                                       call_info_entry->ip_caller_name.ip_caller_name_len*2,
                                       ip_caller_name,
                                       sizeof(ip_caller_name));

      if (caller_name_len > 0)
      {
        caller_name_ptr = ip_caller_name;
        name_pi = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;
        break;
      }
    }

    if (is_ims_req)
    {
    // ------------------------------------------------------------------------------------------
    // 2. Connected Party Number Extension
    // ------------------------------------------------------------------------------------------
      if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONN_PARTY_IP_NUM_VALID)
      {
        caller_name_len = strlen(call_info_entry->voice_svc_conn_party_ip_num.conn_ip_num);
        caller_name_ptr = call_info_entry->voice_svc_conn_party_ip_num.conn_ip_num;
        name_pi = qcril_qmi_voice_map_qmi_to_ril_name_pi((pi_name_enum_v02)
                call_info_entry->voice_svc_conn_party_ip_num.conn_ip_num_pi);
        break;
      }

    // ------------------------------------------------------------------------------------------
    // 3. Connected Party Number
    // ------------------------------------------------------------------------------------------
      if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONN_PARTY_NUM_VALID)
      {
        caller_name_len = call_info_entry->voice_svc_conn_party_num.conn_num_len;
        caller_name_ptr = call_info_entry->voice_svc_conn_party_num.conn_num;
        name_pi = qcril_qmi_voice_map_qmi_to_ril_name_pi((pi_name_enum_v02)
                call_info_entry->voice_svc_conn_party_num.conn_num_pi);
        break;
      }
    }

    // ------------------------------------------------------------------------------------------
    // 4. Remote Party Name
    // ------------------------------------------------------------------------------------------
    if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NAME_VALID)
    {
      QCRIL_LOG_INFO("remote name len %d, str %s",
              call_info_entry->voice_svc_remote_party_name.name_len,
              call_info_entry->voice_svc_remote_party_name.name);

      if (*(call_info_entry->voice_svc_remote_party_name.name) &&
              (call_info_entry->voice_svc_remote_party_name.name_len <
               QCRIL_QMI_VOICE_INTERCODING_BUF_LEN))
      {
        caller_name_len = call_info_entry->voice_svc_remote_party_name.name_len;
        caller_name_ptr = call_info_entry->voice_svc_remote_party_name.name;
        name_pi = qcril_qmi_voice_map_qmi_to_ril_name_pi(
                call_info_entry->voice_svc_remote_party_name.name_pi);
        break;
      }
      else
      {
        QCRIL_LOG_ERROR("remote party name is null, or "
                "remote party name len >= QCRIL_QMI_VOICE_INTERCODING_BUF_LEN");
      }
    }
  } while (FALSE);

  if (caller_name_ptr)
  {
    *name = (char*)qcril_malloc(caller_name_len+1);

    if (*name)
    {
      memcpy(*name, caller_name_ptr, caller_name_len+1);
      *name_presentation = name_pi;
      QCRIL_LOG_INFO("name = %s, name_pi = %d", *name, name_pi);
    }
    else
    {
      result = E_NO_MEMORY;
    }
  }
  else
  {
    result = E_NOT_FOUND;
  }
  QCRIL_LOG_INFO("Exit: result = %d", result);

  return result;
}

//===========================================================================
// qcril_qmi_voice_get_current_call_number
//===========================================================================
IxErrnoType qcril_qmi_voice_get_current_call_number
(
 const qcril_qmi_voice_voip_call_info_entry_type *const call_info_entry, // in
 boolean                                          is_ims_req,            // in
 char                                           **number,                // out
 int                                             *number_presentation    // out
)
{
  IxErrnoType  result        = E_SUCCESS;
  uint32_t number_len        = 0;
  const char    *caller_number_ptr = NULL;
  int      number_pi         = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;
  char     rp_number[QMI_VOICE_SIP_URI_MAX_V02+QMI_VOICE_NUMBER_MAX_V02+1];

  QCRIL_LOG_INFO("Enter");

  do {
    if (!call_info_entry || !number_presentation || !number)
    {
      QCRIL_LOG_INFO("Invalid parameters!");
      result = E_INVALID_ARG;
      break;
    }

    *number_presentation = QCRIL_QMI_VOICE_RIL_PI_UNKNOWN;

    // ------------------------------------------------------------------------------------------
    // 1. Connected Party Number
    // ------------------------------------------------------------------------------------------
    if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONN_PARTY_NUM_VALID)
    {
      number_len = call_info_entry->voice_svc_conn_party_num.conn_num_len;
      caller_number_ptr = call_info_entry->voice_svc_conn_party_num.conn_num;
      number_pi = qcril_qmi_voice_map_qmi_to_ril_num_pi(
              call_info_entry->voice_svc_conn_party_num.conn_num_pi);
      break;
    }
    // ------------------------------------------------------------------------------------------
    // 2. Remote Party Number / Remote Party Number Extn
    // ------------------------------------------------------------------------------------------
    if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID ||
        call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_IP_NUMBER_VALID)
    {
      pi_num_enum_v02 rp_number_pi;
      memset(rp_number, 0, sizeof(rp_number));

      if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_IP_NUMBER_VALID)
      {
        rp_number_pi = call_info_entry->voice_svc_remote_party_ip_number.ip_num_pi;
        number_len = strlen(call_info_entry->voice_svc_remote_party_ip_number.ip_num);
        memcpy(rp_number, call_info_entry->voice_svc_remote_party_ip_number.ip_num, number_len);
      }
      else
      {
        rp_number_pi = call_info_entry->voice_svc_remote_party_number.number_pi;
        number_len = call_info_entry->voice_svc_remote_party_number.number_len;
        strlcpy(rp_number,
                call_info_entry->voice_svc_remote_party_number.number,
                sizeof(rp_number));
      }

      if(is_ims_req &&
         (QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMER_NUM_TO_IMS_ADDR & call_info_entry->elaboration) &&
         (CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_IP_V02 == call_info_entry->voice_scv_info.call_type ||
          CALL_TYPE_EMERGENCY_VT_V02 == call_info_entry->voice_scv_info.call_type))
      {
        //convert the ims emergency address back to corresponding emergency number If needed
        if(!strcmp(call_info_entry->emer_num_ims_addr_info.ims_address, rp_number))
        {
          strlcpy(rp_number,
                  call_info_entry->emer_num_ims_addr_info.emergency_number,
                  sizeof(rp_number));
          number_len = strlen(rp_number);
          rp_number_pi = PRESENTATION_NUM_ALLOWED_V02;
        }
      }

    // ------------------------------------------------------------------------------------------
    // 3. Redirecting Party Num
    // ------------------------------------------------------------------------------------------
      QCRIL_LOG_INFO("feature_redir_party_num_support is %senabled",
              feature_redir_party_num_support ? "" : "not ");

      if (feature_redir_party_num_support &&
              call_info_entry->voice_svc_redirecting_party_num.num_len > 0)
      {
        rp_number[number_len] = '&';
        memcpy(&rp_number[number_len+1],
                call_info_entry->voice_svc_redirecting_party_num.num,
                call_info_entry->voice_svc_redirecting_party_num.num_len + 1);
        number_len += (call_info_entry->voice_svc_redirecting_party_num.num_len + 1);
      }

      caller_number_ptr = rp_number;
      number_pi = qcril_qmi_voice_map_qmi_to_ril_num_pi(rp_number_pi);
    }
  } while (FALSE);

  if (caller_number_ptr)
  {
    *number = (char*)qcril_malloc(number_len+1);

    if (*number)
    {
      memcpy(*number, caller_number_ptr, number_len+1);
      *number_presentation = number_pi;
      QCRIL_LOG_INFO("number = %s, number_pi = %d", *number, number_pi);
    }
    else
    {
      result = E_NO_MEMORY;
    }
  }
  else
  {
    result = E_NOT_FOUND;
  }
  QCRIL_LOG_INFO("Exit: result = %d", result);

  return result;
}

RIL_AudioQuality convertToRil(voice_speech_codec_enum_v02 speechCodec)
{
    RIL_AudioQuality ret = RIL_AUDIO_QUAL_UNSPECIFIED;
    switch(speechCodec) {
        case VOICE_SPEECH_CODEC_AMR_NB_V02:
            ret = RIL_AUDIO_QUAL_AMR;
            break;
        case VOICE_SPEECH_CODEC_AMR_WB_V02:
            ret = RIL_AUDIO_QUAL_AMR_WB;
            break;
        case VOICE_SPEECH_CODEC_GSM_EFR_V02:
            ret = RIL_AUDIO_QUAL_GSM_EFR;
            break;
        case VOICE_SPEECH_CODEC_GSM_FR_V02:
            ret = RIL_AUDIO_QUAL_GSM_FR;
            break;
        case VOICE_SPEECH_CODEC_GSM_HR_V02:
            ret = RIL_AUDIO_QUAL_GSM_HR;
            break;
        case VOICE_SPEECH_CODEC_EVRC_V02:
            ret = RIL_AUDIO_QUAL_EVRC;
            break;
        case VOICE_SPEECH_CODEC_EVRC_B_V02:
            ret = RIL_AUDIO_QUAL_EVRC_B;
            break;
        case VOICE_SPEECH_CODEC_EVRC_WB_V02:
            ret = RIL_AUDIO_QUAL_EVRC_WB;
            break;
        case VOICE_SPEECH_CODEC_EVRC_NW_V02:
            ret = RIL_AUDIO_QUAL_EVRC_NW;
            break;
        default:
            ret = RIL_AUDIO_QUAL_UNSPECIFIED;
    }
    return ret;
}
//===========================================================================
// qcril_qmi_voice_gather_current_call_information
//===========================================================================
RIL_Errno qcril_qmi_voice_gather_current_call_information
(
   unsigned int iter,
   const qcril_request_params_type *const params_ptr,
   qcril_qmi_voice_current_calls_type *payload_ptr,
   const qcril_qmi_voice_voip_call_info_entry_type *const call_info_entry
)
{
    RIL_Errno result = RIL_E_SUCCESS;

    IxErrnoType err  = E_SUCCESS;

    uint32_t         rp_number_len;
    uint32_t         rp_name_len;

    int              number_overlayed;

    do
    {
        if (NULL == params_ptr ||
            NULL == payload_ptr ||
            NULL == call_info_entry)
        {
            result = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_ERROR("Null pointer: params_ptr %p,"
                            " payload_ptr %p,"
                            " call_info_entry %p",
                            params_ptr,
                            payload_ptr,
                            call_info_entry);
            break;
        }
        if (CM_CALL_ID_MAX <= iter)
        {
            result = RIL_E_INVALID_ARGUMENTS;
            QCRIL_LOG_ERROR("out of range: iter %u, max %u", iter, CM_CALL_ID_MAX);
            break;
        }
        // call state
        if( CALL_STATE_END_V02 == call_info_entry->voice_scv_info.call_state &&
                 qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id) )
        {
            payload_ptr->info[ iter ].state = (RIL_CallState) ims_CallState_CALL_END;
        }
        else if ( call_info_entry->elaboration &
                  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EXTENDED_DIALING )
        {
            payload_ptr->info[iter].state = RIL_CALL_DIALING;
        }
        else
        {
            payload_ptr->info[iter].state = call_info_entry->ril_call_state;
        }

        // call id
        payload_ptr->info[iter].index = call_info_entry->android_call_id;

        //Media id
        payload_ptr->media_id[iter] = call_info_entry->media_id;

        // Encryption
        payload_ptr->is_secure_call[iter] = call_info_entry->is_secure_call;

        // History info
        if (call_info_entry->history_info_valid)
        {
          payload_ptr->history_info_valid[iter] = TRUE;
          char history_info_utf8[QMI_VOICE_IP_HIST_INFO_MAX_LEN_V02 * 2] = "\0";

          qcril_cm_ss_convert_ucs2_to_utf8((const char *)call_info_entry->history_info.ip_hist_info,
                  call_info_entry->history_info.ip_hist_info_len * 2,
                  history_info_utf8,
                  sizeof(history_info_utf8));

          size_t history_info_utf8_size = strlen(history_info_utf8) + 1;
          payload_ptr->history_info[iter] = (char *)qcril_malloc(history_info_utf8_size);
          strlcpy(payload_ptr->history_info[iter], history_info_utf8, history_info_utf8_size);
        }

        // Number & Number Presentation
        err = qcril_qmi_voice_get_current_call_number(call_info_entry,
                qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id),
                &payload_ptr->info[iter].number,
                &payload_ptr->info[iter].numberPresentation);

        if (err == E_NO_MEMORY)
        {
            result = RIL_E_NO_MEMORY;
            QCRIL_LOG_ERROR("No memory");
            break;
        }

        // TOA
        if (err == E_SUCCESS)
        {
            if (payload_ptr->info[iter].number[0] == QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER_PREFIX)
            {
                payload_ptr->info[iter].toa = QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER;
            }
            else
            {
                payload_ptr->info[iter].toa = QCRIL_QMI_VOICE_DOMESTIC_NUMBER;
            }
        }

        // Name & Name Presentation
        err = qcril_qmi_voice_get_current_call_name(call_info_entry,
                qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id),
                &payload_ptr->info[iter].name,
                &payload_ptr->info[iter].namePresentation);

        if (err == E_NO_MEMORY)
        {
            result = RIL_E_NO_MEMORY;
            QCRIL_LOG_ERROR("No memory");
            break;
        }

        // overlay check - number
        number_overlayed = FALSE;
        if ( qcril_qmi_voice_voip_call_info_is_single_elaboration_set( call_info_entry, QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_STK_CC_EMULATED_OVERLAY )
              &&
              ( NULL != call_info_entry->overlayed_number_storage_for_emulated_stk_cc )
            )
        { // apply overlay for emulated STK CC
               if ( NULL != payload_ptr->info[iter].number )
               {
                  qcril_free ( payload_ptr->info[iter].number );
               }

               rp_number_len = strlen( call_info_entry->overlayed_number_storage_for_emulated_stk_cc );
               payload_ptr->info[iter].number = (char*)qcril_malloc( rp_number_len + 1 );
               if ( payload_ptr->info[iter].number )
               {
                  strlcpy( payload_ptr->info[iter].number, call_info_entry->overlayed_number_storage_for_emulated_stk_cc, rp_number_len + 1 );
                  number_overlayed = TRUE;
               }

               payload_ptr->info[iter].numberPresentation = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;

               if ( NULL != payload_ptr->info[iter].number && QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER_PREFIX == payload_ptr->info[iter].number[0] )
               {
                 payload_ptr->info[iter].toa = QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER;
               }
               else
               {
                 payload_ptr->info[iter].toa = QCRIL_QMI_VOICE_DOMESTIC_NUMBER;
               }

               QCRIL_LOG_INFO("..applied overlayed number %s for android call id %d", call_info_entry->overlayed_number_storage_for_emulated_stk_cc, call_info_entry->android_call_id );
        } // end overlay number

        // overlay check - name
        if ( qcril_qmi_voice_voip_call_info_is_single_elaboration_set( call_info_entry, QCRIL_QMI_VOICE_VOIP_CALLINFO_EXTENDED_ELA_STK_CC_EMULATED_OVERLAY )
              &&
              ( NULL != call_info_entry->overlayed_name_storage_for_emulated_stk_cc )
            )
        { // apply overlay name for emulated STK CC
               if ( NULL != payload_ptr->info[iter].name )
               {
                  qcril_free( payload_ptr->info[iter].name );
               }

               rp_name_len = strlen( call_info_entry->overlayed_name_storage_for_emulated_stk_cc );
               payload_ptr->info[iter].name = (char*)qcril_malloc( rp_name_len + 1 );
               if ( payload_ptr->info[iter].name )
               {
                  strlcpy( payload_ptr->info[iter].name, call_info_entry->overlayed_name_storage_for_emulated_stk_cc, rp_name_len + 1 );
               }
               payload_ptr->info[iter].namePresentation = QCRIL_QMI_VOICE_RIL_PI_ALLOWED;

               QCRIL_LOG_INFO("..applied overlayed name %s for android call id %d", call_info_entry->overlayed_name_storage_for_emulated_stk_cc, call_info_entry->android_call_id );
        } // end overlay name

        // end of number and name ********

        // is multiparty
        payload_ptr->info[iter].isMpty = (call_info_entry->voice_scv_info.is_mpty) ? TRUE : FALSE;

        // is mobile terminated
        payload_ptr->info[iter].isMT = ( call_info_entry->voice_scv_info.direction == CALL_DIRECTION_MT_V02 ) ? TRUE : FALSE;
        QCRIL_LOG_INFO("Call state %d, IsMT=%d", call_info_entry->ril_call_state, call_info_entry->voice_scv_info.is_mpty );

        // ALS
        payload_ptr->info[iter].als = ( call_info_entry->voice_scv_info.als == ALS_LINE2_V02 ) ? TRUE : FALSE;

        // privacy
        if ( call_info_entry->voice_scv_info.call_type != CALL_TYPE_SUPS_V02)
        {
            payload_ptr->info[iter].isVoice = TRUE;
            if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VOICE_PRIVACY_VALID )
            {
                payload_ptr->info[iter].isVoicePrivacy = ( call_info_entry->voice_svc_voice_privacy == VOICE_PRIVACY_ENHANCED_V02) ? TRUE : FALSE;
            }
        }
        else
        {
            payload_ptr->info[iter].isVoice = FALSE;
        }

        // codec and call capabilities
        if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CODEC_VALID)
        {
            payload_ptr->info[iter].audioQuality = convertToRil(call_info_entry->codec);
        }

        if ( qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id) )
        {
            if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CODEC_VALID)
            {
                payload_ptr->codec_valid[iter] = TRUE;
                payload_ptr->codec[iter] = call_info_entry->codec;
            }

            if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LOCAL_CALL_CAPBILITIES_VALID)
            {
                payload_ptr->local_call_capabilities_info_valid[iter] = TRUE;
                payload_ptr->local_call_capabilities_info[iter] = call_info_entry->local_call_capabilities_info;
            }

            if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PEER_CALL_CAPBILITIES_VALID)
            {
                payload_ptr->peer_call_capabilities_info_valid[iter] = TRUE;
                payload_ptr->peer_call_capabilities_info[iter] = call_info_entry->peer_call_capabilities_info;
            }

            if ( call_info_entry->rtt_mode_valid)
            {
                payload_ptr->rtt_mode_valid[iter] =  TRUE;
                payload_ptr->rtt_mode[iter] = call_info_entry->rtt_mode;
            }

            if ( call_info_entry->rtt_capabilities_info_valid )
            {
                payload_ptr->rtt_capabilities_info_type_valid[iter] =  TRUE;
                payload_ptr->rtt_capabilities_info_type[iter] =
                                      call_info_entry->rtt_capabilities_info;
            }

            if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_CHILD_NUMBER_VALID)
            {
                char  child_number[QMI_VOICE_SIP_URI_MAX_V02+25] = "\0"; //Extra len 25 - to put the string "ChildNum="

                payload_ptr->child_number_valid[iter] = TRUE;
                snprintf(child_number, sizeof(child_number), "ChildNum=%s", call_info_entry->child_number.number);

                size_t child_number_size = strlen(child_number) + 1;
                payload_ptr->child_number[iter] = (char *)qcril_malloc(child_number_size);
                strlcpy(payload_ptr->child_number[iter], child_number, child_number_size);
            }

            if (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_DISPLAY_TEXT_VALID)
            {
                char  display_text[(QMI_VOICE_DISPLAY_TEXT_MAX_LEN_V02 * 2)+25] = "\0"; //Extra len 25 - to put the string "DisplayText="

                payload_ptr->display_text_valid[iter] = TRUE;
                snprintf(display_text, sizeof(display_text), QCRIL_DISPLAY_TEXT_STR);

                qcril_cm_ss_convert_ucs2_to_utf8((const char *)call_info_entry->display_text.display_text,
                        call_info_entry->display_text.display_text_len*2,
                        display_text + strlen(QCRIL_DISPLAY_TEXT_STR),
                        sizeof(display_text) - strlen(QCRIL_DISPLAY_TEXT_STR));

                size_t display_text_size = strlen(display_text) + 1;
                payload_ptr->display_text[iter] = (char*)qcril_malloc(display_text_size);
                strlcpy(payload_ptr->display_text[iter], display_text, display_text_size);
            }
            if (qcril_qmi_voice_is_additional_call_info_available(call_info_entry))
            {
                int total_size = strlen(QCRIL_ADD_CALL_INFO_STR) +
                                 call_info_entry->additional_call_info.total_size + 1;
                payload_ptr->additional_call_info_valid[iter] = TRUE;
                payload_ptr->additional_call_info[iter]       = (char*) qcril_malloc(total_size);
                snprintf(payload_ptr->additional_call_info[iter],  total_size, "%s%s",
                         QCRIL_ADD_CALL_INFO_STR,
                         call_info_entry->additional_call_info.buffer);
            }
        }

        //parentCallID
        if( ( call_info_entry->srvcc_parent_call_info_valid ) &&
               ( call_info_entry->android_call_id != call_info_entry->srvcc_parent_call_info.parent_call_id ) )
        {
            if(strlen(call_info_entry->parent_call_id) > 0)
            {
                payload_ptr->parentCallID[iter] = (char*)qcril_malloc( strlen(call_info_entry->parent_call_id)+1 );
                if( NULL != payload_ptr->parentCallID[iter] )
                {
                    payload_ptr->parentCallID_valid[iter] = TRUE;
                    strlcpy(payload_ptr->parentCallID[iter], call_info_entry->parent_call_id, strlen(call_info_entry->parent_call_id)+1);
                    QCRIL_LOG_INFO("payload_ptr->parentCallID[%d]: %s", iter, payload_ptr->parentCallID[iter]);
                }
            }
        }

        // lcf
        if (call_info_entry->lcf_valid && qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id))
        {
            payload_ptr->lcf_valid[iter] = TRUE;
            payload_ptr->lcf[iter] = call_info_entry->lcf;
            memcpy(payload_ptr->lcf_extended_codes[iter], call_info_entry->lcf_extended_codes, MAX_DEC_INT_STR);
        }

        //sip error code
        if ( call_info_entry->sip_error_code_valid )
        {
            payload_ptr->sip_error_code_valid[iter] = TRUE;
            payload_ptr->sip_error_code[iter] = call_info_entry->sip_error_code.sip_error_code;
            QCRIL_LOG_INFO("sip_error_code %d", payload_ptr->sip_error_code[iter]);
        }

        //sip alternate uri
        if (call_info_entry->alternate_sip_uri_valid)
        {
            uint8 alternate_sip_uris_len = 0;
            alternate_sip_uris_len = strnlen((char *)call_info_entry->alternate_sip_uri.sip_uri,
                                              QMI_VOICE_SIP_URI_MAX_V02 + 1);

            if (alternate_sip_uris_len > 0)
            {
              payload_ptr->alternate_sip_uris[iter] =  (char*)qcril_malloc(alternate_sip_uris_len + 1);
              if (payload_ptr->alternate_sip_uris[iter] != nullptr)
              {
                payload_ptr->alternate_sip_uris_valid[iter] = TRUE;
                strlcpy(payload_ptr->alternate_sip_uris[iter],
                         call_info_entry->alternate_sip_uri.sip_uri,
                         alternate_sip_uris_len + 1);
                QCRIL_LOG_INFO("alternate_sip_uri %s", payload_ptr->alternate_sip_uris[iter]);
              } else
              {
                QCRIL_LOG_ERROR("Failed to allocate memory for alternate_sip_uris");
                result = RIL_E_NO_MEMORY;
                break;
              }
            }
        }

        // end_reason_text
        QCRIL_LOG_INFO("call_info_entry->end_reason_text_valid = %d\n", call_info_entry->end_reason_text_valid);
        if (call_info_entry->end_reason_text_valid &&
                qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id))
        {
            uint8 end_reason_text_len = 0;
            char end_reason_text[QMI_VOICE_END_REASON_TEXT_MAX_LEN_V02*2];

            QCRIL_LOG_INFO("end_reason_text_len: %d, end_reason_text (UTF-16):",
                    call_info_entry->end_reason_text.end_reason_text_len);
            qcril_qmi_print_hex((unsigned char *)call_info_entry->end_reason_text.end_reason_text,
                    call_info_entry->end_reason_text.end_reason_text_len*2);

            end_reason_text_len = qcril_cm_ss_convert_ucs2_to_utf8(
                    (const char *)call_info_entry->end_reason_text.end_reason_text,
                    call_info_entry->end_reason_text.end_reason_text_len*2,
                    end_reason_text,
                    sizeof(end_reason_text));

            if (end_reason_text_len > 0)
            {
                QCRIL_LOG_INFO("end_reason_text (UTF-8): %s", end_reason_text);
                payload_ptr->end_reason_text[iter] = (char*)qcril_malloc(end_reason_text_len + 1);
                if (payload_ptr->end_reason_text[iter])
                {
                    strlcpy(payload_ptr->end_reason_text[iter], end_reason_text,
                            end_reason_text_len + 1);
                    payload_ptr->end_reason_text_valid[iter] = TRUE;
                }
            }
        }

        // uus
        payload_ptr->info[iter].uusInfo = NULL;
        if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_UUS_VALID )
        {
            payload_ptr->uus_info[iter].uusType    = (RIL_UUS_Type)call_info_entry->voice_svc_uus.uus_type;
            payload_ptr->uus_info[iter].uusDcs     = (RIL_UUS_DCS)call_info_entry->voice_svc_uus.uus_dcs;
            payload_ptr->uus_info[iter].uusLength  = call_info_entry->voice_svc_uus.uus_data_len;
            payload_ptr->uus_info[iter].uusData    =  (char*)call_info_entry->voice_svc_uus.uus_data;
            payload_ptr->info[iter].uusInfo        = &payload_ptr->uus_info[iter];
        }

        // Call mode
        payload_ptr->mode[iter] = call_info_entry->voice_scv_info.mode;

        // Call Modified Cause
        QCRIL_LOG_INFO("call_info_entry->call_modified_cause_valid = %d\n",
                call_info_entry->call_modified_cause_valid);
        if (call_info_entry->call_modified_cause_valid &&
                qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id))
        {
          QCRIL_LOG_INFO("call_info_entry->call_modified_cause = %d\n",
                call_info_entry->call_modified_cause);
          payload_ptr->call_modified_cause_valid[iter] = TRUE;
          payload_ptr->call_modified_cause[iter]       = (voice_call_modified_cause_enum_v02)
              qcril_qmi_ims_map_qmi_call_modified_cause_to_ims_cause_code(
                      call_info_entry->call_modified_cause);
        }
        // Is called party ringing at remote end
        QCRIL_LOG_INFO("call_info_entry->is_called_party_ringing_valid = %d\n",
                call_info_entry->is_called_party_ringing_valid);
        if (call_info_entry->is_called_party_ringing_valid)
        {
          QCRIL_LOG_INFO("call_info_entry->is_called_party_ringing = %d\n",
                call_info_entry->is_called_party_ringing.is_called_party_ringing);
          payload_ptr->is_called_party_ringing_valid[iter] = TRUE;
          payload_ptr->is_called_party_ringing[iter]       =
                      call_info_entry->is_called_party_ringing.is_called_party_ringing;
        }
        // Remote Party Conf Capability
        QCRIL_LOG_INFO("call_info_entry->remote_party_conf_capability_valid = %d\n",
                call_info_entry->remote_party_conf_capability_valid);
        if (call_info_entry->remote_party_conf_capability_valid)
        {
          QCRIL_LOG_INFO("call_info_entry->remote_party_conf_capability->conf_is_enabled = %d\n",
                call_info_entry->remote_party_conf_capability.conf_is_enabled);
          payload_ptr->remote_party_conf_capability_valid[iter] = TRUE;
          payload_ptr->remote_party_conf_capability[iter]       =
                      call_info_entry->remote_party_conf_capability.conf_is_enabled;
        }
        // Verstat info
        payload_ptr->verstat_info_valid[iter] =
                call_info_entry->has_verstat_info;
        QCRIL_LOG_INFO("call_info_entry->has_verstat_info = %d\n",
                call_info_entry->has_verstat_info);
        if (call_info_entry->has_verstat_info)
        {
          payload_ptr->verstat_info[iter] =
                  call_info_entry->verstat_info;
          QCRIL_LOG_INFO("call_info_entry->verstat_info->"
                 "can_mark_unwanted_call = %d , "
                 "call_info_entry->verstat_info->validataion_status = %d\n",
                 call_info_entry->verstat_info.network_supports_unwanted_call,
                 call_info_entry->verstat_info.mt_call_verstat_info);

        }
        //terminating number info
        payload_ptr->terminating_num_valid[iter] =
            call_info_entry->terminating_num_valid;
        QCRIL_LOG_INFO("call_info_entry->terminating_num_valid = %d\n",
                call_info_entry->terminating_num_valid);
        if (call_info_entry->terminating_num_valid)
        {
          int length = strlen(call_info_entry->terminating_num);
          payload_ptr->terminating_num[iter] = (char*)qcril_malloc(length + 1);
          if (payload_ptr->terminating_num[iter] == NULL)
          {
            QCRIL_LOG_ERROR("malloc failed for payload_ptr->terminating_num[%d]" , iter);
            payload_ptr->terminating_num_valid[iter] = 0;
            break;
          }
          strlcpy(payload_ptr->terminating_num[iter], call_info_entry->terminating_num, length +1);
          payload_ptr->is_secondary[iter] = call_info_entry->is_secondary;
          QCRIL_LOG_INFO("call_info_entry->terminating_num = %s , "
                         "call_info_entry->is_secondary = %d\n" ,
                         call_info_entry->terminating_num,
                         call_info_entry->is_secondary);
        }
    } while (FALSE);
    QCRIL_LOG_FUNC_RETURN_WITH_RET(result);
    return result;
} // qcril_qmi_voice_gather_current_call_information

//===========================================================================
// qcril_qmi_get_call_list_to_send
//===========================================================================
void qcril_qmi_get_call_list_to_send
(
   const qcril_request_params_type *const params_ptr,
   qcril_qmi_voice_current_calls_type **payload_ptr_ptr,
   RIL_Call_Details call_details_copy[CM_CALL_ID_MAX],
   RIL_Errno *ril_req_res_ptr,
   int *is_ril_number_already_freed
)
{
   unsigned int k;
   int need_consider_voice_call_obj_cleanup = FALSE;
   qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;

   unsigned int call_radio_tech = RADIO_TECH_UNKNOWN;
   unsigned int call_radio_tech_family = RADIO_TECH_UNKNOWN;

   qcril_qmi_voice_current_calls_type *payload_ptr;
   uint32 num_of_calls = 0;
   uint32 nof_cs_calls = 0;

   int   log_nof_reported_calls = 0;
   int   log_nof_skipped_calls = 0;
   int   log_nof_call_objects = 0;
   char  log_essence[ QCRIL_MAX_LOG_MSG_SIZE ];
   char  log_addon[ QCRIL_MAX_LOG_MSG_SIZE ];

   QCRIL_LOG_FUNC_ENTRY();

#ifndef USING_NAS_PUBLIC_API
   call_radio_tech = qcril_qmi_voice_nas_control_get_reported_voice_radio_tech();
#else
   if (qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid)
     call_radio_tech = qcril_qmi_voice_nas_reported_info.voice_radio_tech;
#endif
   call_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(call_radio_tech);

   snprintf( log_essence, QCRIL_MAX_LOG_MSG_SIZE,
                "RILVI: calls rep:" );

   *ril_req_res_ptr = RIL_E_GENERIC_FAILURE;
   *is_ril_number_already_freed = FALSE;

   qcril_qmi_voice_voip_lock_overview();

   if (RADIO_TECH_3GPP2 == call_radio_tech_family)
   {
      qcril_qmi_voice_voip_current_call_summary_type calls_summary;
      qcril_qmi_voice_voip_generate_summary( &calls_summary );
      nof_cs_calls = calls_summary.nof_voice_calls;
   }

   do
   {
      payload_ptr = ( qcril_qmi_voice_current_calls_type * ) qcril_malloc( sizeof ( qcril_qmi_voice_current_calls_type ) )  ;
      if ( NULL == payload_ptr )
      {
        *ril_req_res_ptr = RIL_E_NO_MEMORY;
        break;
      }

      memset(payload_ptr, 0, sizeof(qcril_qmi_voice_current_calls_type));
      memset(call_details_copy, 0, sizeof(*call_details_copy) * CM_CALL_ID_MAX);
      QCRIL_LOG_INFO( "iteration through call objects start" );
      k = 0;
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
      while ( NULL != call_info_entry )
      {
        log_nof_call_objects++;

        /* In case of VoiIP conference(mpty) call, only the conference call is considered  */
        /* Telephony is only aware of the associated call */
        if (VOICE_INVALID_CALL_ID != call_info_entry->android_call_id &&        // not a shadow call
            ((VOICE_INVALID_CALL_ID != call_info_entry->qmi_call_id) ||
             (call_info_entry->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_QMI_ID_RECEIVED) ||
             (CALL_STATE_END_V02 == call_info_entry->voice_scv_info.call_state &&
              qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id))) &&      // not a call without a valid qmi call ID
            CALL_STATE_SETUP_V02 != call_info_entry->voice_scv_info.call_state && // not a setup call
            CALL_TYPE_OTAPA_V02 != call_info_entry->voice_scv_info.call_type && // notan OTAPA call
            (CALL_STATE_END_V02 != call_info_entry->voice_scv_info.call_state ||
             qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id)) &&        // not an ended CS call
            (!(call_info_entry->elaboration &
               QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_WAITING_FOR_MATCHING_VOICE_RTE) || // call mode matches with reported voice radio tech
             (call_info_entry->elaboration &
              (QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EME_FROM_OOS |
               QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_EMERGENCY_CALL |
               QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1x_CSFB_CALL))) &&              // emergency call originated from limited service or emergency call or 1x CSFB call
            (call_info_entry->elaboration &
             QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_RIL_CALL_STATE_VALID) &&
            !(call_info_entry->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_1X_REMOTE_NUM_PENDING) &&
            (qcril_qmi_voice_is_qmi_call_emergency(&call_info_entry->voice_scv_info) ||
             !qmi_ril_voice_is_audio_inactive_vcl() ||
              qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id)) &&
            !((call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PHANTOM_CALL) &&
              (call_info_entry->voice_scv_info.call_state == CALL_STATE_ORIGINATING_V02 ||
               call_info_entry->voice_scv_info.call_state == CALL_STATE_ALERTING_V02) &&
              (qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state(RIL_CALL_ACTIVE) != NULL)))
          {
            if ( (qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id) && qcril_qmi_voice_call_to_ims(call_info_entry)) ||
                 (QCRIL_EVT_RIL_REQUEST_GET_CURRENT_CALLS == params_ptr->event_id && qcril_qmi_voice_call_to_atel(call_info_entry))
               )
            {
              num_of_calls++;
              snprintf( log_addon, QCRIL_MAX_LOG_MSG_SIZE,
                      "[qmi call id %d, android call id %d, qmi call state %d]",
                      call_info_entry->qmi_call_id,
                      call_info_entry->android_call_id,
                      call_info_entry->voice_scv_info.call_state
                      );
              strlcat( log_essence, log_addon, sizeof( log_essence ) );
              log_nof_reported_calls++;
              if (RIL_E_SUCCESS != qcril_qmi_voice_gather_current_call_information
                                                        (k,
                                                         params_ptr,
                                                         payload_ptr,
                                                         call_info_entry))
              {
                  *ril_req_res_ptr = RIL_E_INTERNAL_ERR;
                  break;
              }

              if ( qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id) )
              {
                qcril_qmi_voice_get_atel_call_type_info_by_call_info( call_info_entry, &call_details_copy[k] );
              }

              // Call Modified Cause need to be reported only once to telephony.
              if (payload_ptr->call_modified_cause_valid[k])
              {
                call_info_entry->call_modified_cause_valid = FALSE;
              }

              if (payload_ptr->lcf_valid[k])
              {
                call_info_entry->lcf_valid = FALSE;
              }

              payload_ptr->info_ptr[ k ] = &payload_ptr->info[ k ];
              payload_ptr->num_of_calls++;
              k++;
            }
          }
          else
          { // call not reported
            log_nof_skipped_calls++;
          }

          if ( CALL_STATE_END_V02 == call_info_entry->voice_scv_info.call_state &&
                  VOICE_INVALID_CALL_ID != call_info_entry->android_call_id )
          {
             if ((qcril_qmi_voice_call_to_ims(call_info_entry) &&
                         qcril_qmi_voice_is_ims_send_calls(params_ptr->event_id)) ||
                     (qcril_qmi_voice_call_to_atel(call_info_entry) &&
                      params_ptr->event_id == QCRIL_EVT_RIL_REQUEST_GET_CURRENT_CALLS))
             {
                // Need to add this to destroy the call object.
                call_info_entry->elaboration |=  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_ENDED_REPORTED;

                // - For IMS call, failure is sent along with
                //   UNSOL_RESPONSE_CALL_STATE_CHANGED. so set the elab here.
                // - For CS call, call is cleared after LAST_CALL_FAILURE
                //   req is handled, elab is set by then
                if (qcril_qmi_voice_call_to_ims(call_info_entry) &&
                        params_ptr->event_id == QCRIL_EVT_IMS_SOCKET_SEND_UNSOL_CURRENT_CALLS)
                {
                   call_info_entry->elaboration |=
                       QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LAST_CALL_FAILURE_REPORTED;
                }
                need_consider_voice_call_obj_cleanup = TRUE;
             }
          }

          call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
      }
      *ril_req_res_ptr = RIL_E_SUCCESS;

  } while ( FALSE );


  if ( NULL != payload_ptr && 1 == payload_ptr->num_of_calls )
  {
    *is_ril_number_already_freed = qcril_qmi_voice_handle_ril_call_entry(payload_ptr->info_ptr[ QMI_RIL_ZERO ]);
  }

  if ( need_consider_voice_call_obj_cleanup )
  {
    qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl();
  }

  qcril_qmi_voice_voip_unlock_overview();

  if (qcril_qmi_voice_voip_call_info_entries_is_empty())
  {
      QCRIL_LOG_INFO("Terminating MO call, request to stop DIAG logging");
      if (!qcril_stop_diag_log())
      {
          QCRIL_LOG_INFO("qxdm logging disabled successfully");
      }
  }

  *payload_ptr_ptr = payload_ptr;

  if (QCRIL_EVT_RIL_REQUEST_GET_CURRENT_CALLS == params_ptr->event_id)
  {
     if( !num_of_calls )
     {
       qcril_qmi_nas_control_signal_nas_on_current_calls_change();
     }
  }

  snprintf( log_addon, QCRIL_MAX_LOG_MSG_SIZE,
            " reported/skipped %d/%d calls",
           log_nof_reported_calls, log_nof_skipped_calls);
  strlcat( log_essence, log_addon, sizeof( log_essence ) );

  QCRIL_LOG_ESSENTIAL( "%s", log_essence );
} // qcril_qmi_get_call_list_to_send

//===========================================================================
// qcril_qmi_voice_get_current_calls_cleanup
//===========================================================================
void qcril_qmi_voice_get_current_calls_cleanup
(
  qcril_qmi_voice_current_calls_type *payload_ptr,
  int is_ril_number_already_freed
)
{
  uint32 i;
  QCRIL_LOG_FUNC_ENTRY();
  if ( NULL != payload_ptr )
  {
    for ( i=0; i < payload_ptr->num_of_calls; i++ )
    {
      if ( payload_ptr->info[ i ].number && FALSE == is_ril_number_already_freed )
      {
        qcril_free( payload_ptr->info[ i ].number );
      }
      if( payload_ptr->info[ i ].name )
      {
        qcril_free(payload_ptr->info[ i ].name);
      }
      if( NULL != payload_ptr->parentCallID[i])
      {
        qcril_free(payload_ptr->parentCallID[i]);
      }
      if( NULL != payload_ptr->child_number[i])
      {
        qcril_free(payload_ptr->child_number[i]);
      }
      if( NULL != payload_ptr->display_text[i])
      {
        qcril_free(payload_ptr->display_text[i]);
      }
      if( NULL != payload_ptr->additional_call_info[i])
      {
        qcril_free(payload_ptr->additional_call_info[i]);
      }
      if( NULL != payload_ptr->end_reason_text[i])
      {
        qcril_free(payload_ptr->end_reason_text[i]);
      }
      if( NULL != payload_ptr->terminating_num[i])
      {
        qcril_free(payload_ptr->terminating_num[i]);
      }
    }
    qcril_free( payload_ptr );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_get_current_calls_cleanup

//===========================================================================
// RIL_REQUEST_GET_CURRENT_CALLS
//===========================================================================
void qcril_qmi_voice_request_get_current_atel_calls
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_qmi_voice_current_calls_type *payload_ptr;
  qcril_request_resp_params_type resp;
  unsigned int i;
  const char *call_state[ 6 ] = { "Active", "Holding", "Dialing", "Alerting", "Incoming", "Waiting" };
  RIL_Errno ril_req_res;
  int is_ril_number_already_freed;
  RIL_Call_Details call_details_copy[CM_CALL_ID_MAX];

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_get_call_list_to_send(params_ptr, &payload_ptr, call_details_copy, &ril_req_res, &is_ril_number_already_freed);

  // respond
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
    resp.resp_pkt = (void *) &payload_ptr->info_ptr;
    resp.resp_len = sizeof( RIL_Call * ) * payload_ptr->num_of_calls;

    QCRIL_LOG_INFO( "Reply to RIL --> Number of calls : %d", payload_ptr->num_of_calls );

    for ( i = 0; i < payload_ptr->num_of_calls; i++ )
    {
      QCRIL_LOG_INFO( "Reply to RIL --> call[%d] :state %s index %d, toa %d, isMpty %d, isMT %d, "
                      "als %d, isVoice %d, isVoicePrivacy %d",
                       i,call_state[ payload_ptr->info_ptr[ i ]->state ],
                       payload_ptr->info_ptr[ i ]->index,
                       payload_ptr->info_ptr[ i ]->toa,
                       payload_ptr->info_ptr[ i ]->isMpty,
                       payload_ptr->info_ptr[ i ]->isMT,
                       payload_ptr->info_ptr[ i ]->als,
                       payload_ptr->info_ptr[ i ]->isVoice,
                       payload_ptr->info_ptr[ i ]->isVoicePrivacy );

      QCRIL_LOG_INFO( "...num %s, num presentation %d, name %s, name presentation %d",
                       payload_ptr->info_ptr[ i ]->number,
                       payload_ptr->info_ptr[ i ]->numberPresentation,
                       payload_ptr->info_ptr[ i ]->name,
                       payload_ptr->info_ptr[ i ]->namePresentation);
    }
  }

  qcril_send_request_response( &resp );

  qcril_qmi_voice_get_current_calls_cleanup(payload_ptr, is_ril_number_already_freed);

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_get_current_atel_calls

//===========================================================================
// qcril_qmi_voice_send_current_ims_calls
//===========================================================================
void qcril_qmi_voice_send_current_ims_calls
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
   qcril_qmi_voice_current_calls_type *payload_ptr;
   unsigned int i;
   const char *call_state[ 7 ] = { "Active", "Holding", "Dialing", "Alerting", "Incoming", "Waiting", "END" };
   RIL_Errno ril_req_res;
   int is_ril_number_already_freed;
   RIL_Call_Details call_details_copy[CM_CALL_ID_MAX];

   QCRIL_NOTUSED( ret_ptr );

   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_get_call_list_to_send(params_ptr, &payload_ptr, call_details_copy, &ril_req_res, &is_ril_number_already_freed);

   const char *codec_str[] = { "Codec=NONE",
                               "Codec=QCELP13K",
                               "Codec=EVRC",
                               "Codec=EVRC_B",
                               "Codec=EVRC_WB",
                               "Codec=EVRC_NW",
                               "Codec=AMR_NB",
                               "Codec=AMR_WB",
                               "Codec=GSM_EFR",
                               "Codec=GSM_FR",
                               "Codec=GSM_HR",
                               "Codec=G711U",
                               "Codec=G723",
                               "Codec=G711A",
                               "Codec=G722",
                               "Codec=G711AB",
                               "Codec=G729",
                               "Codec=EVS_NB",
                               "Codec=EVS_WB",
                               "Codec=EVS_SWB",
                               "Codec=EVS_FB",
                              };

   // respond
   if ( RIL_E_SUCCESS == ril_req_res )
   {
      QCRIL_LOG_INFO( "Reply to RIL --> Number of calls : %d", payload_ptr->num_of_calls );

      ims_CallList call_list;
      memset(&call_list, 0, sizeof(call_list));

      call_list.callAttributes.arg =  qcril_malloc(sizeof (ims_CallList_Call*) *
          (payload_ptr->num_of_calls+1));
      ims_CallList_Call *calls = (ims_CallList_Call *)qcril_malloc(sizeof(ims_CallList_Call) *
          payload_ptr->num_of_calls);
      const uint8 MAX_EXTRAS_PER_CALL = 5;
      const char** call_details_extras = (const char**)qcril_malloc(sizeof(char*) *
          payload_ptr->num_of_calls * (MAX_EXTRAS_PER_CALL+1));
      qcril_binary_data_type *bin_data = (qcril_binary_data_type *)qcril_malloc(
          sizeof(qcril_binary_data_type) * payload_ptr->num_of_calls);

      if (NULL == call_list.callAttributes.arg || NULL == calls || NULL == call_details_extras ||
          NULL == bin_data)
      {
        QCRIL_LOG_FATAL("malloc failed");
        if ( call_list.callAttributes.arg )
        {
          qcril_free(call_list.callAttributes.arg);
        }
        if ( calls )
        {
          qcril_free(calls);
        }
        if ( call_details_extras )
        {
          qcril_free(call_details_extras);
        }
        if ( bin_data )
        {
          qcril_free(bin_data);
        }

        ril_req_res = RIL_E_GENERIC_FAILURE;
      }
      else
      {
        for ( i = 0; i < payload_ptr->num_of_calls; i++ )
        {
          ((ims_CallList_Call**)call_list.callAttributes.arg)[i] = &calls[i];
          QCRIL_LOG_INFO( "Reply to RIL --> call[%d] :state %s index %d, toa %d, isMpty %d, "
                          "isMT %d, als %d, isVoice %d, isVoicePrivacy %d",
                           i,call_state[ payload_ptr->info_ptr[ i ]->state ],
                           payload_ptr->info_ptr[ i ]->index,
                           payload_ptr->info_ptr[ i ]->toa,
                           payload_ptr->info_ptr[ i ]->isMpty,
                           payload_ptr->info_ptr[ i ]->isMT,
                           payload_ptr->info_ptr[ i ]->als,
                           payload_ptr->info_ptr[ i ]->isVoice,
                           payload_ptr->info_ptr[ i ]->isVoicePrivacy );

          QCRIL_LOG_INFO( "...num %s, num presentation %d, name %s, name presentation %d",
                           payload_ptr->info_ptr[ i ]->number,
                           payload_ptr->info_ptr[ i ]->numberPresentation,
                           payload_ptr->info_ptr[ i ]->name,
                           payload_ptr->info_ptr[ i ]->namePresentation);

          memset(&(calls[i]), 0, sizeof(calls[i]));

          calls[i].has_state = TRUE;
          calls[i].state     = (ims_CallState)payload_ptr->info_ptr[ i ]->state;
          calls[i].has_index = TRUE;
          calls[i].index     = payload_ptr->info_ptr[ i ]->index;
          calls[i].has_toa   = TRUE;
          calls[i].toa       = payload_ptr->info_ptr[ i ]->toa;
          calls[i].has_isMpty = TRUE;
          calls[i].isMpty    = payload_ptr->info_ptr[ i ]->isMpty;
          calls[i].has_isMT  = TRUE;
          calls[i].isMT      = payload_ptr->info_ptr[ i ]->isMT;
          calls[i].has_als   = TRUE;
          calls[i].als       = payload_ptr->info_ptr[ i ]->als;
          calls[i].has_isVoice = TRUE;
          calls[i].isVoice     = payload_ptr->info_ptr[ i ]->isVoice;
          calls[i].has_isVoicePrivacy = TRUE;
          calls[i].isVoicePrivacy     = payload_ptr->info_ptr[ i ]->isVoicePrivacy;
          calls[i].number.arg  = payload_ptr->info_ptr[ i ]->number;
          calls[i].has_numberPresentation = TRUE;
          calls[i].numberPresentation     = payload_ptr->info_ptr[ i ]->numberPresentation;
          calls[i].name.arg   = payload_ptr->info_ptr[ i ]->name;
          calls[i].has_namePresentation = TRUE;
          calls[i].namePresentation     = payload_ptr->info_ptr[ i ]->namePresentation;
          calls[i].has_isEncrypted = TRUE;
          calls[i].isEncrypted = payload_ptr->is_secure_call[ i ];
          if (payload_ptr->history_info_valid[ i ] == TRUE)
          {
            calls[i].historyInfo.arg = payload_ptr->history_info[ i ];
          }

          //Call details
          calls[i].has_callDetails = TRUE;
          calls[i].callDetails.has_callType = TRUE;
          calls[i].callDetails.callType = qcril_qmi_ims_map_ril_call_type_to_ims_call_type(call_details_copy[i].callType);
          calls[i].callDetails.has_callDomain = TRUE;
          calls[i].callDetails.callDomain = qcril_qmi_ims_map_ril_call_domain_to_ims_call_domain(call_details_copy[i].callDomain);
          // Set call sub state
          calls[i].callDetails.has_callSubstate = TRUE;
          calls[i].callDetails.callSubstate = qcril_qmi_ims_map_ril_call_substate_to_ims_call_substate(
                call_details_copy[i].callSubState);
          calls[i].callDetails.has_mediaId = TRUE;
          calls[i].callDetails.mediaId = payload_ptr->media_id[i];
          QCRIL_LOG_INFO("...callType %d, callDomain %d, callSubstate %d, Media id %d",
              calls[i].callDetails.callType, calls[i].callDetails.callDomain,
              calls[i].callDetails.callSubstate, calls[i].callDetails.mediaId);

          calls[i].callDetails.has_causeCode = payload_ptr->call_modified_cause_valid[i];
          if (calls[i].callDetails.has_causeCode)
          {
            calls[i].callDetails.causeCode = (ims_CauseCodes)payload_ptr->call_modified_cause[i];
          }
          QCRIL_LOG_INFO("has_causecode = %d, causecode = %d",
                         calls[i].callDetails.has_causeCode, calls[i].callDetails.causeCode);
          if (payload_ptr->alternate_sip_uris_valid[i])
          {
              calls[i].callDetails.sipAlternateUri.arg = payload_ptr->alternate_sip_uris[i];
          }
          if (payload_ptr->lcf_valid[i])
          {
             calls[i].has_failCause = TRUE;
             calls[i].failCause.has_failcause = TRUE;
             calls[i].failCause.failcause = (ims_CallFailCause)payload_ptr->lcf[i];
             if (strlen(payload_ptr->lcf_extended_codes[i]) > 0)
             {
                calls[i].failCause.failcause = qcril_qmi_ims_map_ril_failcause_to_ims_failcause(
                    payload_ptr->lcf[i],
                    atoi(payload_ptr->lcf_extended_codes[i]),
                    payload_ptr->sip_error_code_valid[i],
                    payload_ptr->sip_error_code[i]
                );
                bin_data[i].len = strlen(payload_ptr->lcf_extended_codes[i]);
                bin_data[i].data = (uint8 *) payload_ptr->lcf_extended_codes[i];
                calls[i].failCause.errorinfo.arg = &bin_data[i];
             }

             if (payload_ptr->end_reason_text_valid[i])
             {
                calls[i].failCause.networkErrorString.arg = payload_ptr->end_reason_text[i];
             }
             if (payload_ptr->sip_error_code_valid[i] || payload_ptr->end_reason_text_valid[i])
             {
               calls[i].failCause.has_errorDetails = TRUE;
               if (payload_ptr->sip_error_code_valid[i])
               {
                 calls[i].failCause.errorDetails.has_sipErrorCode = TRUE;
                 calls[i].failCause.errorDetails.sipErrorCode = payload_ptr->sip_error_code[i];
               }
               if (payload_ptr->end_reason_text_valid[i])
               {
                 calls[i].failCause.errorDetails.sipErrorString.arg = payload_ptr->end_reason_text[i];
               }
             }
          }

          calls[i].has_isCalledPartyRinging = payload_ptr->is_called_party_ringing_valid[i];
          if (calls[i].has_isCalledPartyRinging)
          {
            calls[i].isCalledPartyRinging = payload_ptr->is_called_party_ringing[i];
          }
          QCRIL_LOG_INFO("has_isCalledPartyRinging = %d, isCalledPartyRinging = %d",
                         calls[i].has_isCalledPartyRinging, calls[i].isCalledPartyRinging);

          calls[i].has_peerConfAbility = payload_ptr->remote_party_conf_capability_valid[i];
          if (calls[i].has_peerConfAbility)
          {
            calls[i].peerConfAbility.has_isVideoConfSupported = TRUE;
            calls[i].peerConfAbility.isVideoConfSupported =
                      payload_ptr->remote_party_conf_capability[i];
          }
          QCRIL_LOG_INFO("has_peerConfAbility = %d, peerConfAbility.isVideoConfSupported = %d",
                         calls[i].has_peerConfAbility,
                         calls[i].peerConfAbility.isVideoConfSupported);

          //Fill CallDetails extras
          unsigned int base_call_details_extras_idx = i * (MAX_EXTRAS_PER_CALL + 1);
          unsigned int cur_call_details_extras_idx = 0;
          calls[i].callDetails.extras.arg = &(call_details_extras[base_call_details_extras_idx]);
          if (payload_ptr->codec_valid[i])
          {
             if (payload_ptr->codec[i] >= 0 &&
                ((unsigned int)payload_ptr->codec[i] < sizeof(codec_str)/sizeof(codec_str[0])))
             {
                if( cur_call_details_extras_idx < MAX_EXTRAS_PER_CALL )
                {
                   call_details_extras[base_call_details_extras_idx+cur_call_details_extras_idx]
                           = codec_str[payload_ptr->codec[i]];
                   cur_call_details_extras_idx++;
                }
             }
             else
             {
                QCRIL_LOG_ERROR( "invalid payload_ptr->codec[i]: %d", payload_ptr->codec[i]);
             }
          }

          if( TRUE == payload_ptr->parentCallID_valid[i] )
          {
             if( cur_call_details_extras_idx < MAX_EXTRAS_PER_CALL )
             {
                call_details_extras[base_call_details_extras_idx+cur_call_details_extras_idx]
                       = payload_ptr->parentCallID[i];
                cur_call_details_extras_idx++;
             }
          }

          if( TRUE == payload_ptr->child_number_valid[i] )
          {
             if( cur_call_details_extras_idx < MAX_EXTRAS_PER_CALL )
             {
                call_details_extras[base_call_details_extras_idx+cur_call_details_extras_idx]
                        = payload_ptr->child_number[i];
                cur_call_details_extras_idx++;
             }
          }

          if( TRUE == payload_ptr->display_text_valid[i] )
          {
            if( cur_call_details_extras_idx < MAX_EXTRAS_PER_CALL )
            {
              call_details_extras[base_call_details_extras_idx+cur_call_details_extras_idx]
                      = payload_ptr->display_text[i];
              cur_call_details_extras_idx++;
            }
          }

          if( TRUE == payload_ptr->additional_call_info_valid[i] )
          {
            if( cur_call_details_extras_idx < MAX_EXTRAS_PER_CALL )
            {
              call_details_extras[base_call_details_extras_idx+cur_call_details_extras_idx]
                      = payload_ptr->additional_call_info[i];
              cur_call_details_extras_idx++;
            }
          }

          QCRIL_LOG_INFO( "...No. of call_details extras %d ", cur_call_details_extras_idx);
          QCRIL_LOG_INFO( "...%s, %s, %s, %s, %s",
                           call_details_extras[ i*(MAX_EXTRAS_PER_CALL+1) ],
                           call_details_extras[ (i*(MAX_EXTRAS_PER_CALL+1))+1 ],
                           call_details_extras[ (i*(MAX_EXTRAS_PER_CALL+1))+2 ],
                           call_details_extras[ (i*(MAX_EXTRAS_PER_CALL+1))+3 ],
                           call_details_extras[ (i*(MAX_EXTRAS_PER_CALL+1))+4 ]);

          calls[i].callDetails.has_localAbility = TRUE;
          qcril_qmi_ims_translate_ril_callcapabilities_to_ims_srvstatusinfo(
              payload_ptr->local_call_capabilities_info_valid[i],
              &payload_ptr->local_call_capabilities_info[i],
              payload_ptr->rtt_capabilities_info_type_valid[i],
              payload_ptr->rtt_capabilities_info_type[i].rtt_capabilities.local_rtt_cap,
              &calls[i].callDetails.localAbility,
              calls[i].callDetails.callType,
              payload_ptr->mode[i]);

          QCRIL_LOG_INFO("RTT SETTINGS: Valid %d, local capability: %d",
              (int)payload_ptr->rtt_capabilities_info_type_valid[i],
              (int)payload_ptr->rtt_capabilities_info_type[i].rtt_capabilities.local_rtt_cap);

          if ( payload_ptr->peer_call_capabilities_info_valid[i] ||
               payload_ptr->rtt_capabilities_info_type_valid[i] )
          {
            calls[i].callDetails.has_peerAbility = TRUE;
            qcril_qmi_ims_translate_ril_callcapabilities_to_ims_srvstatusinfo(
              payload_ptr->peer_call_capabilities_info_valid[i],
              &payload_ptr->peer_call_capabilities_info[i],
              payload_ptr->rtt_capabilities_info_type_valid[i],
              payload_ptr->rtt_capabilities_info_type[i].rtt_capabilities.peer_rtt_cap,
              &calls[i].callDetails.peerAbility,
              payload_ptr->peer_call_capabilities_info_valid[i] ?
              ims_CallType_CALL_TYPE_UNKNOWN : calls[i].callDetails.callType,
              CALL_MODE_NO_SRV_V02);
            QCRIL_LOG_INFO("RTT SETTINGS: Valid %d, peer  capability: %d",
                           (int)payload_ptr->rtt_capabilities_info_type_valid[i],
                           (int)payload_ptr->rtt_capabilities_info_type[i].rtt_capabilities.peer_rtt_cap);
          }
          calls[i].callDetails.has_rttMode =  qcril_qmi_ims_map_qcril_rtt_mode_to_ims(
                                                payload_ptr->rtt_mode[i].rtt_mode,
                                                &calls[i].callDetails.rttMode);
          calls[i].hasVerstatInfo = payload_ptr->verstat_info_valid[i];
          if (calls[i].hasVerstatInfo)
          {
            qcril_qmi_map_verstat_info_to_ims(
                    payload_ptr->verstat_info[i],
                    calls[i].verstatInfo);
          }
          if (payload_ptr->terminating_num_valid[i])
          {
            calls[i].terminatingNumber.arg = payload_ptr->terminating_num[i];
            calls[i].isSecondary = payload_ptr->is_secondary[i];
          }
        }
        if (QCRIL_EVT_IMS_SOCKET_SEND_UNSOL_CURRENT_CALLS == params_ptr->event_id)
        {
            imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_RESPONSE_CALL_STATE_CHANGED, ims_Error_E_SUCCESS, &call_list, sizeof(call_list));
        }
        else
        {
            imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_GET_CURRENT_CALLS, qcril_qmi_ims_map_ril_error_to_ims_error(ril_req_res), &call_list, sizeof(call_list));
        }

        if ( NULL != call_list.callAttributes.arg )
        {
          qcril_free(call_list.callAttributes.arg);
        }
        if ( NULL != calls )
        {
          size_t i;
          for (i=0; i<payload_ptr->num_of_calls; i++)
          {
              qcril_qmi_npb_release(ims_SrvStatusList_fields, &calls[i].callDetails.localAbility);
              qcril_qmi_npb_release(ims_SrvStatusList_fields, &calls[i].callDetails.peerAbility);
          }
          qcril_free(calls);
        }
        if ( NULL != call_details_extras )
        {
          qcril_free(call_details_extras);
        }
        if ( NULL != bin_data )
        {
          qcril_free(bin_data);
        }
      }
   }

   if (RIL_E_SUCCESS != ril_req_res && QCRIL_EVT_IMS_SOCKET_REQ_GET_CURRENT_CALLS == params_ptr->event_id)
   {
      imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_GET_CURRENT_CALLS, qcril_qmi_ims_map_ril_error_to_ims_error(ril_req_res), NULL, 0);
   }

   qcril_qmi_voice_get_current_calls_cleanup(payload_ptr, is_ril_number_already_freed);

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_send_current_ims_calls

//===========================================================================
//qcril_qmi_voice_create_emer_voice_entry
//===========================================================================
 void qcril_qmi_voice_create_emer_voice_entry(qcril_qmi_voice_emer_voice_feature_info_type * emer_voice_number, voice_remote_party_number2_type_v02 * remote_party_number)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_INFO("entry %p, remote svc entry %p", emer_voice_number, remote_party_number);
  if( emer_voice_number && remote_party_number)
  {
    emer_voice_number->is_valid = TRUE;
    if ( remote_party_number->number[0] == QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER_PREFIX )
    {
      emer_voice_number->toa = QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER;
    }
    else
    {
      emer_voice_number->toa = QCRIL_QMI_VOICE_DOMESTIC_NUMBER;
    }
    emer_voice_number->number = (char*)qcril_malloc( remote_party_number->number_len + 1 );
    if ( emer_voice_number->number )
    {
      memcpy( emer_voice_number->number, remote_party_number->number, remote_party_number->number_len + 1 );
      emer_voice_number->numberPresentation = qcril_qmi_voice_map_qmi_to_ril_num_pi( remote_party_number->number_pi );
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_voice_create_emer_voice_entry

//===========================================================================
//qcril_qmi_voice_is_emer_voice_entry_valid
//===========================================================================
int qcril_qmi_voice_is_emer_voice_entry_valid(qcril_qmi_voice_emer_voice_feature_info_type * emer_voice_number)
{
  int ret = FALSE;

  QCRIL_LOG_FUNC_ENTRY();
  if( emer_voice_number && TRUE == emer_voice_number->is_valid )
  {
    ret = TRUE;
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_voice_is_emer_voice_entry_valid

//===========================================================================
//qcril_qmi_voice_handle_ril_call_entry
//===========================================================================
int qcril_qmi_voice_handle_ril_call_entry(RIL_Call *info_ptr)
{
  qcril_qmi_voice_voip_call_info_entry_type *cdma_voice_call_info_entry = NULL;
  qcril_qmi_voice_voip_call_info_entry_type *cdma_no_srv_emer_call_info_entry = NULL;
  qcril_qmi_voice_emer_voice_feature_info_type * temp_ptr = NULL;
  int is_cdma_voice_emergency_calls_present;
  int ret;

  QCRIL_LOG_FUNC_ENTRY();

  cdma_voice_call_info_entry = NULL;
  cdma_no_srv_emer_call_info_entry = NULL;
  temp_ptr = NULL;
  is_cdma_voice_emergency_calls_present = FALSE;
  ret = FALSE;

  QCRIL_LOG_INFO("call type to be considered %d", qcril_qmi_voice_cdma_call_type_to_be_considered);
  is_cdma_voice_emergency_calls_present = qcril_qmi_voice_is_cdma_voice_emergency_calls_present(&cdma_voice_call_info_entry, &cdma_no_srv_emer_call_info_entry);

  if( CALL_TYPE_EMERGENCY_V02 == qcril_qmi_voice_cdma_call_type_to_be_considered )
  {
    if( NULL != cdma_no_srv_emer_call_info_entry &&
        VOICE_LOWEST_CALL_ID < cdma_no_srv_emer_call_info_entry->voice_scv_info.call_id &&
        //mode of the emergency call would be either CDMA or NO_SRV
        //In case of NO_SRV we conclude that it is a CDMA emergency + voice call scenario by checking If there is a CDMA voice call present
        ( CALL_MODE_CDMA_V02 == cdma_no_srv_emer_call_info_entry->voice_scv_info.mode || TRUE == is_cdma_voice_emergency_calls_present ) &&
        CALL_TYPE_EMERGENCY_V02 == cdma_no_srv_emer_call_info_entry->voice_scv_info.call_type &&
        //Should not be considering the ENDed call's number as we not going to destroy and not report this call to Atel
        //QMI Voice replaces the voice call's number with a emergency number by the time emergency call is ENDed
        CALL_STATE_END_V02 != cdma_no_srv_emer_call_info_entry->voice_scv_info.call_state
      )
    {
      temp_ptr = &(cdma_no_srv_emer_call_info_entry->emer_voice_number);
    }
  }
  else
  {
    if( NULL != cdma_voice_call_info_entry &&
        ( CALL_MODE_CDMA_V02 == cdma_voice_call_info_entry->voice_scv_info.mode ) &&
        (cdma_voice_call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_REPORT_CACHED_RP_NUMBER)
      )
    {
      temp_ptr = &(cdma_voice_call_info_entry->emer_voice_number);
    }
  }

  if( temp_ptr )
  {
    QCRIL_LOG_INFO( "Found call entry - valid %d, number %s, presentation %d, toa %d",temp_ptr->is_valid, temp_ptr->number, temp_ptr->numberPresentation, temp_ptr->toa);
    if( temp_ptr->is_valid )
    {
      QCRIL_LOG_INFO("freeing up the original ril call entry %p as we need to report cached entry",info_ptr);
      if( info_ptr )
      {
        ret = TRUE;
        if( info_ptr->number )
        {
          free(info_ptr->number);
        }
        if ( temp_ptr->number[0] == QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER_PREFIX )
        {
          info_ptr->toa = QCRIL_QMI_VOICE_INTERNATIONAL_NUMBER;
        }
        else
        {
          info_ptr->toa = QCRIL_QMI_VOICE_DOMESTIC_NUMBER;
        }
        info_ptr->number = temp_ptr->number;
        info_ptr->numberPresentation = temp_ptr->numberPresentation;
      }
    }
    else
    { // should not be ending up here
      QCRIL_LOG_FATAL("Invalid state in cdma call handling");
    }
  }
  else
  {
    QCRIL_LOG_INFO("ril call entry unchanged");
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_voice_handle_ril_call_entry

//===========================================================================
// qcril_qmi_voice_nas_control_is_any_calls_present
//===========================================================================
boolean qcril_qmi_voice_nas_control_is_any_calls_present()
{
  QCRIL_LOG_FUNC_ENTRY();
  boolean result = FALSE;
  qcril_qmi_voice_voip_current_call_summary_type calls_summary;
  memset( &calls_summary, 0, sizeof( calls_summary ) );

  qcril_qmi_voice_voip_lock_overview();
  qcril_qmi_voice_voip_generate_summary( &calls_summary );
  if (calls_summary.nof_calls_overall)
  {
    result = TRUE;
  }
  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) result);
  return result;
} //qcril_qmi_voice_nas_control_is_any_calls_present

//===========================================================================
// qcril_qmi_voice_auto_answer_timeout_handler
//===========================================================================
void qcril_qmi_voice_auto_answer_timeout_handler( void * param )
{
  voice_answer_call_req_msg_v02               ans_call_req_msg;
  qcril_qmi_voice_voip_call_info_entry_type   *call_info_entry = NULL;
  uint32 user_data;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( param );

  do
  {
    qcril_qmi_voice_voip_lock_overview();
    qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
        QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, TRUE);
    if ( NULL == call_info_entry ){
      QCRIL_LOG_INFO(".. pending incoming call record entry not found");
      break;
    }

    memset( &ans_call_req_msg, 0, sizeof(ans_call_req_msg ) );
    ans_call_req_msg.call_id = call_info_entry->qmi_call_id;
    QCRIL_LOG_INFO(".. call id qmi %d", (int) ans_call_req_msg.call_id );

    if ( call_info_entry->qmi_call_id == VOICE_INVALID_CALL_ID )
    {
      QCRIL_LOG_INFO(".. Invalid Call id!");
      break;
    }

    ans_call_req_msg.call_type_valid = TRUE;
    ans_call_req_msg.call_type = call_info_entry->voice_scv_info.call_type;

    //Fill call type details for VT & VOIP calls from the call_info_entry
    if(call_info_entry->voice_scv_info.call_type == CALL_TYPE_VT_V02)
    {
      ans_call_req_msg.audio_attrib_valid = TRUE;
      ans_call_req_msg.audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);

      ans_call_req_msg.video_attrib_valid = TRUE;
      ans_call_req_msg.video_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);
    }

    user_data = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
        QCRIL_REQ_ID_INTERNAL);
    // Send QMI VOICE ANSWER CALL REQ
    qmi_client_error_type client_err = qmi_client_voice_send_async(
                                 QMI_VOICE_ANSWER_CALL_REQ_V02,
                                 &ans_call_req_msg,
                                 sizeof(ans_call_req_msg),
                                 sizeof(voice_answer_call_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if ( client_err )
    {
      QCRIL_LOG_INFO(".. failed to post qmi answer message");
    }
    else
    {
        call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL;
#ifndef QMI_RIL_UTF
        qcril_am_handle_event(qcril_qmi_voice_get_answer_am_event(call_info_entry), NULL);
#endif
    }
  } while (FALSE);

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// RIL_REQUEST_ANSWER
//===========================================================================
void qcril_qmi_voice_request_answer
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  RIL_Errno                                   res = RIL_E_GENERIC_FAILURE;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_voip_lock_overview();
  res = qcril_qmi_voice_send_request_answer(
                                params_ptr,
                                FALSE);

  if ( RIL_E_SUCCESS != res )
  {
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, res );
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_voice_request_answer

/*===========================================================================

  FUNCTION:  qcril_qmi_process_hangup_on_call_being_setup

===========================================================================*/
/*!
    @brief
    Retrieve call id for MO call for which RIL has not sent response back
    to RIL client.

    Update call info elaboration if need to wait for CC_IN_PROGRESS

    @return
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_process_hangup_on_call_being_setup
(
    int *conn_index
)
{
    qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
    RIL_Errno                                  ril_err         = RIL_E_GENERIC_FAILURE;

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
                                QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_MO_CALL_BEING_SETUP,
                                TRUE );
    QCRIL_LOG_INFO( "call_info_entry %p", call_info_entry );

    if (call_info_entry)
    {
      QCRIL_LOG_INFO( "qmi call id %d android call id %d",
                      call_info_entry->qmi_call_id,
                      call_info_entry->android_call_id);
      if (VOICE_INVALID_CALL_ID == call_info_entry->qmi_call_id)
      {
        call_info_entry->elaboration |=
                          QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_HANGUP_AFTER_VALID_QMI_ID;
        ril_err = RIL_E_SUCCESS;
      }
      else
      {
        *conn_index = call_info_entry->android_call_id;
        ril_err = RIL_E_SUCCESS;
      }
    }
    else
    {
      // Telephony will use HANGUP -1 if user tries to hangup the call
      // before the GET_CURRENT_CALLS response received eventhough the
      // RIL have already sent the DIAL response.
      // In this cases, RIL would be alread cleared the ELA_MO_CALL_BEING_SETUP
      // and thus it will not find any valid call_info_entry and send failure
      // back to telephony.
      // Add support to handle the HANGUP -1 for disconnecting the call in
      // DIALING/ALERTING/ACTIVE state.
      QCRIL_LOG_INFO("call_info_entry with ELA_MO_CALL_BEING_SETUP not found. "
                     "Check if any calls in DIALING/ALERTING/ACTIVE state");

      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state(
                                RIL_CALL_DIALING);
      if (!call_info_entry)
      {
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state(
                                  RIL_CALL_ALERTING);
      }
      if (!call_info_entry)
      {
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state(
                                  RIL_CALL_ACTIVE);
      }

      // Found a DIALING/ACTIVE call
      if (call_info_entry &&
              call_info_entry->qmi_call_id != VOICE_INVALID_CALL_ID)
      {
        QCRIL_LOG_INFO("qmi call id %d android call id %d ril call state %d",
                       call_info_entry->qmi_call_id,
                       call_info_entry->android_call_id,
                       call_info_entry->ril_call_state);
        *conn_index = call_info_entry->android_call_id;
        ril_err = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_ERROR("Failed to find call entry, aborting!");
      }
    }

    return ril_err;
}

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_send_hangup_on_call

===========================================================================*/
/*!
    @brief
    Send hangup request for pending call

    @return
*/
/*=========================================================================*/
void qcril_qmi_voice_send_hangup_on_call
(
    int conn_index
)
{
    qcril_request_params_type  req_data;
    qcril_reqlist_public_type  req_info;
    ims_Hangup                 hangup_req;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&req_data, 0, sizeof(req_data));
    memset(&req_info, 0, sizeof(req_info));
    memset(&hangup_req, 0, sizeof(ims_Hangup));

    /* Lookup the hangup request */
    if (qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_RIL_REQUEST_HANGUP,
                &req_info) == E_SUCCESS)
    {
        req_data.datalen = sizeof(conn_index);
        req_data.data    = &conn_index;
    }

    if (qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_IMS_SOCKET_REQ_HANGUP,
                &req_info) == E_SUCCESS)
    {
        hangup_req.has_conn_index = TRUE;
        hangup_req.conn_index     = conn_index;

        req_data.datalen = sizeof(ims_Hangup);
        req_data.data    = &hangup_req;
    }

    if (req_data.data && req_data.datalen)
    {
        req_data.modem_id       = QCRIL_DEFAULT_MODEM_ID;
        req_data.instance_id    = QCRIL_DEFAULT_INSTANCE_ID;
        req_data.t              = req_info.t;
        req_data.event_id       = req_info.request;

        qcril_reqlist_free(QCRIL_DEFAULT_INSTANCE_ID , req_data.t);
        qcril_qmi_voice_request_hangup(&req_data, NULL);
    }

    return;
}

//===========================================================================
//RIL_REQUEST_HANGUP
//===========================================================================
void qcril_qmi_voice_request_hangup
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    uint32                                          user_data;
    boolean                                         conn_index_valid = FALSE;
    int                                             conn_index = 0;
    boolean                                         conn_uri_valid = FALSE;
    const char*                                     conn_uri = NULL;
    qcril_reqlist_public_type                       reqlist_entry;
    voice_end_call_req_msg_v02                      call_end_req_msg;
    voice_manage_ip_calls_req_msg_v02               manage_ip_calls_req_msg;
    voice_answer_call_req_msg_v02                   ans_call_req_msg;
    qcril_qmi_voice_voip_call_info_entry_type*      call_info_entry = NULL;
    qcril_qmi_voice_voip_current_call_summary_type  calls_summary;
    RIL_Errno                                       ril_err = RIL_E_GENERIC_FAILURE;
    boolean                                         need_to_reject_incoming_call = FALSE;
    int32_t                                         ims_call_end_reason = INVALID_NEGATIVE_ONE;
    char*                                     temp_buf = NULL;
    IxErrnoType                                     error;
    ims_Hangup* ims_hangup_ptr = NULL;
    uint8_t is_pending_ecall_clearing_status = FALSE;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    is_pending_ecall_clearing_status = qcril_qmi_voice_cancel_pending_emergency_call();
    qcril_qmi_voice_voip_lock_overview();

    do
    {
      if ( QCRIL_EVT_RIL_REQUEST_HANGUP == params_ptr->event_id )
      {
        if ( NULL == params_ptr->data )
        {
          QCRIL_LOG_ERROR(".. invalid param");
          ril_err = RIL_E_INVALID_ARGUMENTS;
          break;
        }
        conn_index_valid = TRUE;
        conn_index = *(( int *) params_ptr->data);

      }
      else
      {
        ims_hangup_ptr = (ims_Hangup*) params_ptr->data;
        if (ims_hangup_ptr->has_conn_index)
        {
          conn_index_valid = TRUE;
          conn_index = ims_hangup_ptr->conn_index;
        }

        if (ims_hangup_ptr->conn_uri.arg)
        {
          conn_uri_valid = TRUE;
          conn_uri = (const char*)ims_hangup_ptr->conn_uri.arg;
          QCRIL_LOG_INFO("conn_uri: %s", conn_uri);
        }

        if( ( FALSE == conn_index_valid ) && ( FALSE == conn_uri_valid ) )
        {
          QCRIL_LOG_ERROR("both conn_index and conn_uri are not available in is hangup request");
          ril_err = RIL_E_INVALID_ARGUMENTS;
          break;
        }
        if (ims_hangup_ptr->has_failCauseResponse)
        {
          if (TRUE == ims_hangup_ptr->failCauseResponse.has_failcause)
          {
            if(ims_CallFailCause_CALL_FAIL_MISC !=
               ims_hangup_ptr->failCauseResponse.failcause)
            {
              ims_call_end_reason =
              qcril_qmi_ims_map_ims_failcause_qmi_reject_cause(
              ims_hangup_ptr->failCauseResponse.failcause);

              if(INVALID_NEGATIVE_ONE != ims_call_end_reason)
              {
                need_to_reject_incoming_call = TRUE;
                QCRIL_LOG_INFO ("call end reason is %d", (int) ims_call_end_reason);
              }
            }
            else if (ims_CallFailCause_CALL_FAIL_MISC ==
                ims_hangup_ptr->failCauseResponse.failcause &&
                ims_hangup_ptr->failCauseResponse.errorinfo.arg &&
              ((qcril_binary_data_type*)ims_hangup_ptr->failCauseResponse.errorinfo.arg)->len > 0)
            {
              temp_buf = (char*) qcril_malloc(
              ((qcril_binary_data_type*)ims_hangup_ptr->failCauseResponse.errorinfo.arg)->len + 1);

              if (temp_buf != NULL)
              {
                memcpy( temp_buf,
                ((qcril_binary_data_type*)ims_hangup_ptr->failCauseResponse.errorinfo.arg)->data,
                ((qcril_binary_data_type*)ims_hangup_ptr->failCauseResponse.errorinfo.arg)->len );

                // Here no need for appending last byte of temp_buf with null
                // since qcril_malloc internally does the memset to 0.
                need_to_reject_incoming_call = TRUE;
                ims_call_end_reason = atoi(temp_buf);
                QCRIL_LOG_INFO ("call end reason is %d", (int) ims_call_end_reason);
              }
              else
              {
               QCRIL_LOG_ERROR ("qcril malloc failed");
               ril_err = RIL_E_NO_MEMORY;
               break;
              }
            }
          }
        }
      }

      QCRIL_LOG_INFO( "conn_index_valid: %d, conn_index: %d", conn_index_valid, conn_index );

      // add entry to ReqList
      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE,
                                   NULL,
                                   &reqlist_entry );

      reqlist_entry.req_datalen = sizeof(conn_index);
      reqlist_entry.req_data = (void*)(uintptr_t) &conn_index;

      if ( (error = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
      {
          // Fail to add entry to ReqList
          QCRIL_LOG_ERROR(".. failed to Add into Req list");
          ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(error);
          break;
      }

      QCRIL_LOG_INFO( "is_pending_ecall_clearing_status: %d", is_pending_ecall_clearing_status );
      if(TRUE == is_pending_ecall_clearing_status)
      {
          QCRIL_LOG_INFO( "Don't process Hangup request, send failure response" );
          ril_err = RIL_E_GENERIC_FAILURE;
          break;
      }

      if (QCRIL_EVT_RIL_REQUEST_HANGUP == params_ptr->event_id ||
          QCRIL_EVT_IMS_SOCKET_REQ_HANGUP == params_ptr->event_id)
      {
        /* Not documented in ril.h, if Hangup is coming with a connection index
           it is assumed that this is for the MO call that is being setup. */
        if (!conn_uri_valid &&
            conn_index_valid && conn_index == -1)
        {
          if (RIL_E_SUCCESS != qcril_qmi_process_hangup_on_call_being_setup(&conn_index))
          {
            /* Could not retrieve call id */
            ril_err = RIL_E_INVALID_ARGUMENTS;
            break;
          }
          else if (conn_index == -1)
          {
            /* Have not received call id, hence we will wait to receive call id. */
            ril_err = RIL_E_SUCCESS;
            break;
          }
        }
      }

      // preparation
      user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

      qcril_qmi_voice_voip_generate_summary( &calls_summary );

      // find call info
      if (conn_index_valid)
      {
        call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id( conn_index );
        if (NULL == call_info_entry)
        {
           QCRIL_LOG_ERROR("Failed to find call entry, aborting!");
           ril_err = RIL_E_INVALID_ARGUMENTS;
           break;
        }

        QCRIL_LOG_INFO("Is pending incoming call: %s",
                call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING ?
                "TRUE" : "FALSE");

        if (need_to_reject_incoming_call &&
              !(call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING))
        {
          need_to_reject_incoming_call = FALSE;
        }
      }

      if (call_info_entry && need_to_reject_incoming_call)
      {
        memset (&ans_call_req_msg, 0, sizeof (ans_call_req_msg));
        ans_call_req_msg.call_id = call_info_entry->qmi_call_id;
        ans_call_req_msg.reject_call_valid = TRUE;
        ans_call_req_msg.reject_call = TRUE;
        ans_call_req_msg.reject_cause_valid = TRUE;
        ans_call_req_msg.reject_cause = (voice_reject_cause_enum_v02)ims_call_end_reason;
        qmi_client_error_type client_err = qmi_client_voice_send_async(
                                     QMI_VOICE_ANSWER_CALL_REQ_V02,
                                     &ans_call_req_msg,
                                     sizeof(voice_answer_call_req_msg_v02),
                                     sizeof(voice_answer_call_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data);
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(client_err, NULL);
      }
      else if (call_info_entry &&  conn_index_valid && !conn_uri_valid )
      {
        memset( &call_end_req_msg, 0, sizeof(call_end_req_msg) );
        call_end_req_msg.call_id = call_info_entry->qmi_call_id;

        if(INVALID_NEGATIVE_ONE != ims_call_end_reason)
        {
          call_end_req_msg.end_cause_valid = TRUE;
          call_end_req_msg.end_cause = (voice_reject_cause_enum_v02)ims_call_end_reason;
        }

        qmi_client_error_type client_err = qmi_client_voice_send_async(
                                     QMI_VOICE_END_CALL_REQ_V02,
                                     &call_end_req_msg,
                                     sizeof(voice_end_call_req_msg_v02),
                                     sizeof(voice_end_call_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data);
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(client_err, NULL);
      }
      else if (conn_uri_valid && NULL != conn_uri)
      {
        if (strlen(conn_uri) > QMI_VOICE_SIP_URI_MAX_V02)
        {
          QCRIL_LOG_ERROR("strlen(conn_uri) > QMI_VOICE_SIP_URI_MAX_V02");
          ril_err = RIL_E_INVALID_ARGUMENTS;
          break;
        }

        if (call_info_entry)
        {
            call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONF_PATICIAPNT_CALL_END_REPORTED;
        }

        memset( &manage_ip_calls_req_msg, 0, sizeof(manage_ip_calls_req_msg) );
        manage_ip_calls_req_msg.sups_type = VOIP_SUPS_TYPE_RELEASE_SPECIFIED_CALL_FROM_CONFERENCE_V02;
        manage_ip_calls_req_msg.sip_uri_valid = TRUE;
        memcpy( manage_ip_calls_req_msg.sip_uri, conn_uri, strlen(conn_uri) );

        qmi_client_error_type client_err = qmi_client_voice_send_async(
                                     QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                     &manage_ip_calls_req_msg,
                                     sizeof(voice_manage_ip_calls_req_msg_v02),
                                     sizeof(voice_manage_ip_calls_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data);
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(client_err, NULL);
      }

      if ( RIL_E_SUCCESS != ril_err )
        break;

    } while ( FALSE );

    qcril_qmi_voice_voip_unlock_overview();

    // respond
    if ( RIL_E_SUCCESS != ril_err )
    {
        qcril_qmi_send_hangup_response(params_ptr->event_id, params_ptr->t, ril_err);

        if( NULL != call_info_entry )
        {
          call_info_entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONF_PATICIAPNT_CALL_END_REPORTED;
        }
    }

    if (temp_buf)
    {
        qcril_free( temp_buf );
    }
    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_hangup

static void qcril_qmi_voice_set_dtmf_concurrency_requirement(qcril_reqlist_generic_concurency_requests_requirement_type *req_ptr)
{
  static qcril_evt_e_type req_ids[3];
  req_ids[0] = QCRIL_EVT_RIL_REQUEST_DTMF;
  req_ids[1] = QCRIL_EVT_RIL_REQUEST_DTMF_START;
  req_ids[2] = QCRIL_EVT_RIL_REQUEST_DTMF_STOP;

  req_ptr->max_concurrency = 1;
  req_ptr->max_pending = 1024;
  req_ptr->req_ids_num = sizeof(req_ids)/sizeof(req_ids[0]);
  req_ptr->req_ids = req_ids;
}

// TODO: Keep the interface as it is now since it is a type
// of qcril_reqlist_dispatch_blocked_req_handler, that is used
// by cocurrency control
static void qcril_qmi_voice_send_start_cont_dtmf_request
(
  qcril_instance_id_e_type instance_id,
  struct qcril_reqlist_buf_tag *req,
  void *data,
  size_t datalen
)
{
  uint32 user_data;
  voice_start_cont_dtmf_req_msg_v02 *start_cont_dtmf_req_msg_ptr =
                (voice_start_cont_dtmf_req_msg_v02*)data;
  RIL_Errno ril_err = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(datalen);

  do
  {
    if( NULL == start_cont_dtmf_req_msg_ptr )
    {
      QCRIL_LOG_DEBUG("start_cont_dtmf_req_msg_ptr is NULL");
      ril_err = RIL_E_INTERNAL_ERR;
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, req->pub.req_id );

    qcril_qmi_voice_info_lock();
    qcril_qmi_voice_info.pending_dtmf_req_id = req->pub.req_id;
    qcril_qmi_voice_info_unlock();
    QCRIL_LOG_DEBUG("dtmf req id %d", req->pub.req_id);

    /* Send QMI VOICE START CONT DTMF REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_START_CONT_DTMF_REQ_V02,
                                 start_cont_dtmf_req_msg_ptr,
                                 sizeof(voice_start_cont_dtmf_req_msg_v02),
                                 sizeof(voice_start_cont_dtmf_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if (qmi_client_error != QMI_NO_ERR) {
      qcril_qmi_voice_info_lock();
      qcril_qmi_voice_info.pending_dtmf_req_id = QMI_RIL_ZERO; // reset
      qcril_qmi_voice_info_unlock();
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }

    qcril_qmi_voice_info_lock();
    QCRIL_LOG_DEBUG("dtmf req id %d", (int)qcril_qmi_voice_info.pending_dtmf_req_id);
    qcril_qmi_voice_info_unlock();

  } while ( FALSE );

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, req->pub.t, req->pub.request, ril_err);
  }

  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_dtmf

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  char * in_data_ptr;
  qcril_reqlist_public_type reqlist_entry;
  voice_start_cont_dtmf_req_msg_v02 start_cont_dtmf_req_msg;
  ims_Dtmf *ims_in_data_ptr = NULL;
  RIL_Errno ril_err = RIL_E_SUCCESS;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/
  QCRIL_LOG_FUNC_ENTRY();

  do
  {
        if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
        {
            ril_err = RIL_E_INVALID_ARGUMENTS;
            break;
        }

        /* Assuming CM will do DTMF digit range check */

        // fill in the req msg fields
        memset(&start_cont_dtmf_req_msg,0, sizeof(start_cont_dtmf_req_msg));
        /* Modem determines the active call */
        start_cont_dtmf_req_msg.cont_dtmf_info.call_id = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;

        if ( QCRIL_EVT_RIL_REQUEST_DTMF == params_ptr->event_id )
        {
            in_data_ptr = (char *)params_ptr->data;
            QCRIL_LOG_INFO("Cont dtmf request with digit %c is being sent",in_data_ptr[ 0 ]);
            start_cont_dtmf_req_msg.cont_dtmf_info.digit = in_data_ptr[ 0 ];
        }
        else
        {
            ims_in_data_ptr = (ims_Dtmf *)params_ptr->data;
            if (NULL != ims_in_data_ptr->dtmf.arg)
            {
               QCRIL_LOG_INFO("Cont dtmf request with digit %c is being sent",
                       ((char*)ims_in_data_ptr->dtmf.arg)[0]);
               start_cont_dtmf_req_msg.cont_dtmf_info.digit = ((char*)ims_in_data_ptr->dtmf.arg)[0];
            }
            else
            {
               QCRIL_LOG_ERROR("no dtmf digit in the request");
               ril_err = RIL_E_INVALID_ARGUMENTS;
               break;
            }
        }

        /* Add entry to ReqList */
        /* For GW system, we sent start_cont_dtmf followed by stop_cont_dtmf to simulate burst_dtmf */
        qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_QMI_VOICE_BURST_START_CONT_DTMF, NULL, &reqlist_entry );
        qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
        qcril_qmi_voice_set_dtmf_concurrency_requirement(&concurency_requirement);
        qcril_reqlist_buf_type *req_buf;

        IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                                &reqlist_entry,
                                                                                &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                                &concurency_requirement,
                                                                                sizeof(concurency_requirement),
                                                                                &qcril_qmi_voice_send_start_cont_dtmf_request,
                                                                                &start_cont_dtmf_req_msg,
                                                                                sizeof(start_cont_dtmf_req_msg),
                                                                                &req_buf );
        if ( E_SUCCESS == new_req_result )
        {
          qcril_qmi_voice_send_start_cont_dtmf_request( instance_id, req_buf, &start_cont_dtmf_req_msg, sizeof(start_cont_dtmf_req_msg) );
        }
        else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
        {
          QCRIL_LOG_INFO("new request is blocked.");
        }
        else
        {
          QCRIL_LOG_INFO("new request is rejected.");
          break;
        }
  } while ( FALSE );
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
  }
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_dtmf() */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_dtmf_start

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF_START.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_dtmf_start
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  char *in_data_ptr;
  qcril_reqlist_public_type reqlist_entry;
  voice_start_cont_dtmf_req_msg_v02 start_cont_dtmf_req_msg;
  ims_Dtmf *ims_in_data_ptr = NULL;
  RIL_Errno ril_err = RIL_E_SUCCESS;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    // fill in the req msg fields
    memset(&start_cont_dtmf_req_msg,0, sizeof(start_cont_dtmf_req_msg));
    /* QMI on Modem determines the active/alerting call */
    start_cont_dtmf_req_msg.cont_dtmf_info.call_id = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;

    if ( QCRIL_EVT_RIL_REQUEST_DTMF_START == params_ptr->event_id )
    {
      in_data_ptr = (char *)params_ptr->data;
      QCRIL_LOG_INFO("Cont dtmf request with digit %c is being sent",in_data_ptr[ 0 ]);
      start_cont_dtmf_req_msg.cont_dtmf_info.digit = in_data_ptr[ 0 ];
    }
    else
    {
      ims_in_data_ptr = (ims_Dtmf *)params_ptr->data;
      if (NULL != ims_in_data_ptr->dtmf.arg)
      {
         QCRIL_LOG_INFO("Cont dtmf request with digit %c is being sent",
                 ((char*)ims_in_data_ptr->dtmf.arg)[0]);
         start_cont_dtmf_req_msg.cont_dtmf_info.digit = ((char*)ims_in_data_ptr->dtmf.arg)[0];
      }
      else
      {
         QCRIL_LOG_ERROR("no dtmf digit in the request");
         ril_err = RIL_E_INVALID_ARGUMENTS;
         break;
      }
    }

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
    qcril_qmi_voice_set_dtmf_concurrency_requirement(&concurency_requirement);
    qcril_reqlist_buf_type *req_buf;

    IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                            &reqlist_entry,
                                                                            &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                            &concurency_requirement,
                                                                            sizeof(concurency_requirement),
                                                                            &qcril_qmi_voice_send_start_cont_dtmf_request,
                                                                            &start_cont_dtmf_req_msg,
                                                                            sizeof(start_cont_dtmf_req_msg),
                                                                            &req_buf );
    if ( E_SUCCESS == new_req_result )
    {
      qcril_qmi_voice_send_start_cont_dtmf_request( instance_id, req_buf, &start_cont_dtmf_req_msg, sizeof(start_cont_dtmf_req_msg) );
    }
    else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
    {
      QCRIL_LOG_INFO("new request is blocked.");
    }
    else
    {
      QCRIL_LOG_INFO("new request is rejected.");
    }
  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err);
  }
} /* qcril_qmi_voice_request_dtmf_start() */

static void qcril_qmi_voice_send_stop_cont_dtmf_request
(
  qcril_instance_id_e_type instance_id,
  struct qcril_reqlist_buf_tag *req,
  void *data,
  size_t datalen
)
{
  uint32 user_data;
  voice_stop_cont_dtmf_req_msg_v02 *stop_cont_dtmf_req_msg_ptr =
            (voice_stop_cont_dtmf_req_msg_v02*)data;
  RIL_Errno ril_err = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(datalen);

  do
  {
    if( NULL == stop_cont_dtmf_req_msg_ptr )
    {
      ril_err = RIL_E_INTERNAL_ERR;
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, req->pub.req_id );

    qcril_qmi_voice_info_lock();
    qcril_qmi_voice_info.pending_dtmf_req_id = req->pub.req_id;
    qcril_qmi_voice_info_unlock();

    /* Send QMI VOICE START CONT DTMF REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_STOP_CONT_DTMF_REQ_V02,
                                 stop_cont_dtmf_req_msg_ptr,
                                 sizeof(voice_stop_cont_dtmf_req_msg_v02),
                                 sizeof(voice_stop_cont_dtmf_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if (qmi_client_error != QMI_NO_ERR) {
      qcril_qmi_voice_info_lock();
      qcril_qmi_voice_info.pending_dtmf_req_id = QMI_RIL_ZERO;
      qcril_qmi_voice_info_unlock();

      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }

    qcril_qmi_voice_info_lock();
    QCRIL_LOG_DEBUG("dtmf req id %d", qcril_qmi_voice_info.pending_dtmf_req_id);
    qcril_qmi_voice_info_unlock();

  } while ( FALSE );
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, req->pub.t, req->pub.request, ril_err );
  }
  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_dtmf_stop

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF_STOP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_dtmf_stop
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_reqlist_public_type reqlist_entry;
  voice_stop_cont_dtmf_req_msg_v02 stop_cont_dtmf_req_msg;

  QCRIL_LOG_FUNC_ENTRY();

  /*-----------------------------------------------------------------------*/

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    // fill in the req msg fields
    memset(&stop_cont_dtmf_req_msg,0, sizeof(stop_cont_dtmf_req_msg));
    /* QMI on Modem determines the active/alerting call */
    stop_cont_dtmf_req_msg.call_id = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
    qcril_qmi_voice_set_dtmf_concurrency_requirement(&concurency_requirement);
    qcril_reqlist_buf_type *req_buf;

    IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                            &reqlist_entry,
                                                                            &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                            &concurency_requirement,
                                                                            sizeof(concurency_requirement),
                                                                            &qcril_qmi_voice_send_stop_cont_dtmf_request,
                                                                            &stop_cont_dtmf_req_msg,
                                                                            sizeof(stop_cont_dtmf_req_msg),
                                                                            &req_buf );
    if ( E_SUCCESS == new_req_result )
    {
      qcril_qmi_voice_send_stop_cont_dtmf_request( instance_id, req_buf, &stop_cont_dtmf_req_msg, sizeof(stop_cont_dtmf_req_msg) );
    }
    else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
    {
      QCRIL_LOG_INFO("new request is blocked.");
    }
    else
    {
      QCRIL_LOG_INFO("new request is rejected.");
    }
  }while(0);
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_dtmf_stop() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_cdma_burst_dtmf

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_BURST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_cdma_burst_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  uint32 user_data;
  char *dtmf_ptr;
  char *onlength_ptr = NULL;
  char *offlength_ptr = NULL;
  dtmf_onlength_enum_v02 on_length = DTMF_ONLENGTH_150MS_V02;
  dtmf_offlength_enum_v02 off_length = DTMF_OFFLENGTH_150MS_V02;
  long ret_val;
  char *end_ptr;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_burst_dtmf_req_msg_v02 cdma_burst_dtmf_req_msg;
  int dtmf_str_len = 0;

  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;


  /*-----------------------------------------------------------------------*/

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
  /* Verify the parameters are valid */
    if ( params_ptr->datalen == 0 || params_ptr->data == NULL)
    {
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    dtmf_ptr =  ((char **)params_ptr->data)[ 0 ];
    onlength_ptr = ((char **)params_ptr->data)[ 1 ];
    offlength_ptr = ((char **)params_ptr->data)[ 2 ];
    if( dtmf_ptr == NULL || onlength_ptr == NULL || offlength_ptr == NULL )
    {
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    dtmf_str_len = strlen(dtmf_ptr);

    if( dtmf_str_len > QMI_VOICE_DIGIT_BUFFER_MAX_V02)
    {
      QCRIL_LOG_ERROR("Length of Dtmf string received:%d, maximum length supported:%d",dtmf_str_len,QMI_VOICE_DIGIT_BUFFER_MAX_V02);
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    /* Convert DTMF ON length string to DTMF ON duration */
    ret_val = strtol( onlength_ptr, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ( ret_val == LONG_MAX ) || ( ret_val == LONG_MIN ) ) )
    {
      QCRIL_LOG_ERROR( "Fail to convert DTMF ON length str = %s, default to: DTMF_ONLENGTH_SMS \n", onlength_ptr );
    }

    switch ( ret_val )
    {
    case 95 :
      on_length = DTMF_ONLENGTH_95MS_V02;
      break;
    /* As per the Ril interface - 0 maps to default value */
    case 0   :
    case 150 :
      on_length = DTMF_ONLENGTH_150MS_V02;
      break;
    case 200 :
      on_length = DTMF_ONLENGTH_200MS_V02;
      break;
    case 250 :
      on_length = DTMF_ONLENGTH_250MS_V02;
      break;
    case 300 :
      on_length = DTMF_ONLENGTH_300MS_V02;
      break;
    case 350 :
      on_length = DTMF_ONLENGTH_350MS_V02;
      break;
    default :
      on_length = DTMF_ONLENGTH_SMS_V02;
      break;
    }
    QCRIL_LOG_DEBUG( "DTMF ON length ret_val = %p, on_length_val = %d", onlength_ptr , on_length );

    /* Convert DTMF OFF length string to DTMF OFF duration */
    ret_val = strtol( offlength_ptr, &end_ptr, 0 );
    if ( ( errno == ERANGE ) && ( ( ret_val == LONG_MAX ) || ( ret_val == LONG_MIN ) ) )
    {
      QCRIL_LOG_ERROR( "Fail to convert DTMF OFF length %s, default to: DTMF_OFFLENGTH_150MS (150msecs)", offlength_ptr );
    }

    switch ( ret_val )
    {
    case 60 :
      off_length = DTMF_OFFLENGTH_60MS_V02;
      break;
    case 100 :
      off_length = DTMF_OFFLENGTH_100MS_V02;
      break;
    case 150 :
      off_length = DTMF_OFFLENGTH_150MS_V02;
      break;
    case 200 :
      off_length = DTMF_OFFLENGTH_200MS_V02;
      break;
    default :
      off_length = DTMF_OFFLENGTH_150MS_V02;
      break;
    }
    QCRIL_LOG_DEBUG( "DTMF OFF length ret_val = %p, Off_length_val = %d", offlength_ptr , off_length );

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK, QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    memset(&cdma_burst_dtmf_req_msg,0, sizeof(cdma_burst_dtmf_req_msg));
    QCRIL_LOG_INFO("CDMA Burst dtmf request with string %s is being sent",dtmf_ptr);
    /* Modem determines the active call */
    cdma_burst_dtmf_req_msg.burst_dtmf_info.call_id = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;
    cdma_burst_dtmf_req_msg.burst_dtmf_info.digit_buffer_len = (dtmf_str_len < QMI_VOICE_DIGIT_BUFFER_MAX_V02)?dtmf_str_len:QMI_VOICE_DIGIT_BUFFER_MAX_V02;
    memcpy(cdma_burst_dtmf_req_msg.burst_dtmf_info.digit_buffer, dtmf_ptr, cdma_burst_dtmf_req_msg.burst_dtmf_info.digit_buffer_len);

    cdma_burst_dtmf_req_msg.dtmf_lengths_valid = TRUE;
    cdma_burst_dtmf_req_msg.dtmf_lengths.dtmf_offlength = off_length;
    cdma_burst_dtmf_req_msg.dtmf_lengths.dtmf_onlength = on_length;

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE BURST DTMF REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_BURST_DTMF_REQ_V02,
                                 &cdma_burst_dtmf_req_msg,
                                 sizeof(voice_burst_dtmf_req_msg_v02),
                                 sizeof(voice_burst_dtmf_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if (qmi_client_error != QMI_NO_ERR) {
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  } while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
} /* qcril_qmi_voice_request_cdma_burst_dtmf */

//===========================================================================
// qcril_qmi_voice_parse_call_modify_param
//===========================================================================
boolean qcril_qmi_voice_parse_call_modify_param
(
 qcril_evt_e_type event_id,
 const void *data_ptr,
 int *callIndex,
 RIL_Call_Details **callDetails
)
{
  boolean ret = 0;

  if (NULL != data_ptr && NULL != callIndex && NULL != callDetails)
  {
    if (QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_INITIATE == event_id ||
        QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_CONFIRM == event_id)
    {
       const ims_CallModify *ims_modify_input_ptr = (const ims_CallModify *)data_ptr;
       *callIndex = ims_modify_input_ptr->callIndex;
       *callDetails = (RIL_Call_Details*)qcril_malloc(sizeof(RIL_Call_Details));
       if (NULL != *callDetails && ims_modify_input_ptr->has_callDetails)
       {
         qcril_qmi_ims_translate_ims_calldetails_to_ril_calldetails(
             &ims_modify_input_ptr->callDetails, *callDetails);
       }
       else
       {
          QCRIL_LOG_ERROR("callDetails malloc failed");
          ret = 1;
       }
    }
    else
    {
       QCRIL_LOG_ERROR("wrong request %d for parsing", event_id);
       ret = 1;
    }
  }
  else
  {
    ret = 1;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int)ret);
  return ret;
} // qcril_qmi_voice_parse_call_modify_param

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_modify_call_initiate

===========================================================================*/
/*!
    @brief
    Handles MODIFY_CALL_INITIATE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_modify_call_initiate
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
   RIL_Errno result = RIL_E_SUCCESS;
   int callIndex = VOICE_INVALID_CALL_ID;
   RIL_Call_Details *callDetails = NULL;
   voice_manage_ip_calls_req_msg_v02   modify_req;
   uint32 user_data;
   qcril_reqlist_public_type                   reqlist_entry;
   qcril_qmi_voice_voip_call_info_entry_type  *call_info = NULL;
   boolean is_emergency_ip = FALSE;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   if (params_ptr->data == NULL || params_ptr->datalen <= 0)
   {
      result = RIL_E_GENERIC_FAILURE;
   }
   else
   {
      ims_CallModify *modifyRequest = (ims_CallModify *)params_ptr->data;
      if (qcril_qmi_voice_parse_call_modify_param(params_ptr->event_id, params_ptr->data, &callIndex, &callDetails))
      {
         result = RIL_E_GENERIC_FAILURE;
      }

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_QMI_REQUEST_MODIFY_INITIATE,
                                   NULL,
                                   &reqlist_entry );

      if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR("Failed to Add into Req list");
        result = RIL_E_GENERIC_FAILURE;
      }

      if (callIndex >= VOICE_LOWEST_CALL_ID && callIndex <= VOICE_HIGHEST_CALL_ID)
      {
        call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id( (uint8_t)callIndex );
      }
      else {
        QCRIL_LOG_ERROR("Invalid callIndex %d", callIndex);
      }

      if( call_info == NULL )
      {
         QCRIL_LOG_DEBUG( "android call-id = %d not found, rejecting modify initiate request", callIndex );
         result = RIL_E_GENERIC_FAILURE;
      }

      if( result == RIL_E_SUCCESS )
      {
         if (call_info->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_IP_V02 ||
                 call_info->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_VT_V02)
         {
            is_emergency_ip =  TRUE;
         }
         memset(&modify_req, 0, sizeof(modify_req));
         if (qcril_qmi_voice_get_modem_call_type_info( (ims_CallType)callDetails->callType,
                                                       (ims_CallDomain)callDetails->callDomain,
                                             is_emergency_ip,
                                             &modify_req.call_type,
                                             &modify_req.audio_attrib_valid,
                                             &modify_req.audio_attrib,
                                             &modify_req.video_attrib_valid,
                                             &modify_req.video_attrib) )
         {
            modify_req.call_type_valid = TRUE;
            modify_req.call_id_valid = TRUE;
            modify_req.call_id = call_info->qmi_call_id;
            modify_req.sups_type = VOIP_SUPS_TYPE_MODIFY_CALL_V02;
            if(modifyRequest->callDetails.has_rttMode)
            {
                modify_req.rtt_mode_valid =  qcril_qmi_ims_map_ims_rtt_mode_to_qcril(
                                              modifyRequest->callDetails.rttMode,
                                              &modify_req.rtt_mode);
            }
            user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

            qmi_client_error_type client_error = qmi_client_voice_send_async(
                                           QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                           &modify_req,
                                           sizeof(voice_manage_ip_calls_req_msg_v02),
                                           sizeof(voice_manage_ip_calls_resp_msg_v02),
                                           qcril_qmi_voice_command_cb,
                                           (void*)(uintptr_t)user_data);
            QCRIL_LOG_INFO(".. qmi send async res %d", (int) client_error );
            result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( client_error, NULL );
         }
         else
         {
            QCRIL_LOG_DEBUG("qcril_qmi_voice_get_modem_call_type_info() returns error");
            result = RIL_E_GENERIC_FAILURE;
         }
      }

      if (QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_INITIATE == params_ptr->event_id && NULL != callDetails)
      {
         qcril_free(callDetails);
      }
   }

   QCRIL_LOG_INFO("result is %d", result);
   if( result != RIL_E_SUCCESS )
   {
      qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE );
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_request_modify_call_initiate

/*===========================================================================
  FUNCTION:  qcril_qmi_voice_request_cancel_modify_call
===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_CANCEL_MODIFY_CALL

    @return:
    None
*/
/*=========================================================================*/
void qcril_qmi_voice_request_cancel_modify_call
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_evt_e_type event = params_ptr->event_id;
  qcril_reqlist_public_type reqlist_entry;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  ims_CancelModifyCall *ims_cancel_modify_ptr = NULL;
  voip_cancel_type_enum_v02 cancel_type;
  uint8_t call_id;
  qcril_qmi_voice_voip_call_info_entry_type *call_info = NULL;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_REQ_AWAITING_CALLBACK,
                               QCRIL_EVT_NONE,
                               NULL,
                               &reqlist_entry );
  do
  {
  if (qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS)
  {
    // Fail to add entry to ReqList
    QCRIL_LOG_ERROR(".. failed to Add into Req list");
    ril_req_res = RIL_E_GENERIC_FAILURE;
    break;
  }

  if (QCRIL_EVT_IMS_SOCKET_REQ_CANCEL_MODIFY_CALL == event)
  {
    ims_cancel_modify_ptr = (ims_CancelModifyCall *)params_ptr->data;
    cancel_type = VOIP_CANCEL_TYPE_CANCEL_CALL_UPGRADE_V02;

    if (ims_cancel_modify_ptr)
    {
      QCRIL_LOG_DEBUG("Has callid? %d, callId: %d", ims_cancel_modify_ptr->has_callId,
          ims_cancel_modify_ptr->callId);
      if (TRUE == ims_cancel_modify_ptr->has_callId)
      {
        call_id = ims_cancel_modify_ptr->callId;
        call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(call_id);
      }
      else
      {
        //Call id is mandatory
        QCRIL_LOG_ERROR("Invalid call id");
      }
      if (!call_info)
      {
        QCRIL_LOG_ERROR("Do not have any voip active calls or invalid call id in request");
      }
    }
    else
    {
      QCRIL_LOG_ERROR("CancelModifyCall request data is NULL");
    }
  }

  if (call_info)
  {
    voice_ims_call_cancel_req_msg_v02   cancel_modify_call_req;

    qmi_client_error_type qmi_client_error = QMI_NO_ERR;
    uint32                user_data;

    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         reqlist_entry.req_id );

    memset( &cancel_modify_call_req, 0, sizeof(cancel_modify_call_req) );
    cancel_modify_call_req.cancel_type = cancel_type;
    cancel_modify_call_req.call_id = call_info->qmi_call_id;
    QCRIL_LOG_DEBUG("qmi call id: %d", call_info->qmi_call_id);

    qmi_client_error = qmi_client_voice_send_async(QMI_VOICE_IMS_CALL_CANCEL_REQ_V02,
                                                         &cancel_modify_call_req,
                                                         sizeof( cancel_modify_call_req ),
                                                         sizeof( voice_ims_call_cancel_resp_msg_v02 ),
                                                         qcril_qmi_voice_command_cb,
                                                         (void*)(uintptr_t)user_data );

    QCRIL_LOG_INFO(".. qmi send async res %d", (int) qmi_client_error );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error,
                                                                           NULL );
  }
  }while(0);

  QCRIL_LOG_INFO("result is %d", ril_req_res);
  if ( RIL_E_SUCCESS != ril_req_res )
  { // Failure
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t,
                                               params_ptr->event_id, ril_req_res );
  }

  QCRIL_LOG_FUNC_RETURN();
 } // qcril_qmi_voice_request_cancel_modify_call

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_modify_call_confirm

===========================================================================*/
/*!
    @brief
    Handles MODIFY_CALL_CONFIRM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_modify_call_confirm
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
   RIL_Errno result = RIL_E_SUCCESS;
   int callIndex = VOICE_INVALID_CALL_ID;
   RIL_Call_Details *callDetails = NULL;
   voice_manage_ip_calls_req_msg_v02 modify_confirm_req;
   uint32 user_data;
   qcril_reqlist_public_type                   reqlist_entry;
   qcril_qmi_voice_voip_call_info_entry_type  *call_info = NULL;
   boolean is_audio_attrib_valid, is_video_attrib_valid, accept;
   boolean is_emergency_ip = FALSE;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   ims_CallModify *modifyRequest = NULL;

   if (params_ptr->data == NULL || params_ptr->datalen <= 0)
   {
      result = RIL_E_GENERIC_FAILURE;
   }
   else
   {
      if (qcril_qmi_voice_parse_call_modify_param(params_ptr->event_id, params_ptr->data, &callIndex, &callDetails))
      {
         result = RIL_E_GENERIC_FAILURE;
      }
      modifyRequest = (ims_CallModify *) params_ptr->data;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_QMI_REQUEST_MODIFY_CONFIRM,
                                   NULL,
                                   &reqlist_entry );

      if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR("Failed to Add into Req list");
        result = RIL_E_GENERIC_FAILURE;
      }

      if (callIndex >= VOICE_LOWEST_CALL_ID && callIndex <= VOICE_HIGHEST_CALL_ID)
      {
        call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id( (uint8_t)callIndex );
      }
      else {
        QCRIL_LOG_ERROR("Invalid callIndex %d", callIndex);
      }

      if( call_info == NULL )
      {
         QCRIL_LOG_DEBUG("call-id not found, rejecting  modify confirm request");
         result = RIL_E_GENERIC_FAILURE;
      }

      if( result == RIL_E_SUCCESS )
      {
         if (call_info->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_IP_V02 ||
                 call_info->voice_scv_info.call_type == CALL_TYPE_EMERGENCY_VT_V02)
         {
            is_emergency_ip = TRUE;
         }
         memset(&modify_confirm_req, 0, sizeof(modify_confirm_req));
         if (qcril_qmi_voice_get_modem_call_type_info( (ims_CallType)callDetails->callType,
                                                       (ims_CallDomain)callDetails->callDomain,
                                             is_emergency_ip,
                                             &modify_confirm_req.call_type,
                                             &modify_confirm_req.audio_attrib_valid,
                                             &modify_confirm_req.audio_attrib,
                                             &modify_confirm_req.video_attrib_valid,
                                             &modify_confirm_req.video_attrib )
             )
         {

            is_audio_attrib_valid = (call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUDIO_ATTR_VALID) ? TRUE : FALSE;
            is_video_attrib_valid = (call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VIDEO_ATTR_VALID) ? TRUE : FALSE;

            if(modifyRequest->callDetails.has_rttMode)
            {
                modify_confirm_req.rtt_mode_valid = qcril_qmi_ims_map_ims_rtt_mode_to_qcril(
                                                    modifyRequest->callDetails.rttMode,
                                                    &modify_confirm_req.rtt_mode);
            }

            accept = !qcril_qmi_voice_match_modem_call_type(modify_confirm_req.call_type,
                                                            modify_confirm_req.audio_attrib_valid,
                                                            modify_confirm_req.audio_attrib,
                                                            modify_confirm_req.video_attrib_valid,
                                                            modify_confirm_req.video_attrib,
                                                            modify_confirm_req.rtt_mode_valid,
                                                            modify_confirm_req.rtt_mode,
                                                            call_info->voice_scv_info.call_type,
                                                            is_audio_attrib_valid,
                                                            call_info->voice_audio_attrib.call_attributes,
                                                            is_video_attrib_valid,
                                                            call_info->voice_video_attrib.call_attributes,
                                                            call_info->rtt_mode_valid,
                                                            call_info->rtt_mode.rtt_mode);

            modify_confirm_req.call_type_valid = TRUE;
            modify_confirm_req.call_id_valid = TRUE;
            modify_confirm_req.call_id = call_info->qmi_call_id;

            if( accept )
            {
               modify_confirm_req.sups_type = VOIP_SUPS_TYPE_MODIFY_ACCEPT_V02;
            }
            else
            {
               modify_confirm_req.sups_type = VOIP_SUPS_TYPE_MODIFY_REJECT_V02;
            }

            user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );


            qmi_client_error_type client_error = qmi_client_voice_send_async(
                                         QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                         &modify_confirm_req,
                                         sizeof(voice_manage_ip_calls_req_msg_v02),
                                         sizeof(voice_manage_ip_calls_resp_msg_v02),
                                         qcril_qmi_voice_command_cb,
                                         (void*)(uintptr_t)user_data);
            QCRIL_LOG_INFO(".. qmi send async res %d", (int) client_error );
            result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( client_error, NULL );

            if ( RIL_E_SUCCESS == result && QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_CONFIRM == params_ptr->event_id)
            {
              call_info->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_MODIFY_CONFIRM_PENDING;
            }
         }
         else
         {
            QCRIL_LOG_DEBUG("qcril_qmi_voice_get_modem_call_type_info() returns error");
            result = RIL_E_GENERIC_FAILURE;
         }
      } // if result == RIL_E_SUCCESS

      if ( QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_CONFIRM == params_ptr->event_id && NULL != callDetails )
      {
         qcril_free(callDetails);
      }
   }

   QCRIL_LOG_INFO("result is %d", result);
   if( result != RIL_E_SUCCESS )
   {
      qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE );
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_request_modify_call_confirm

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_cdma_flash

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_FLASH.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_cdma_flash
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  char *flash_ptr;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_send_flash_req_msg_v02  send_flash_req_msg;
  int flash_str_len = 0;

  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;


  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  flash_ptr = ( char * )params_ptr->data;
  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  /* Lookup as_id */

  do
  {
    if(flash_ptr != NULL)
    {
      flash_str_len = strlen(flash_ptr);
      if(flash_str_len > QMI_VOICE_FLASH_PAYLOAD_MAX_V02)
      {
        QCRIL_LOG_ERROR("Length of flash string received:%d, maximum length supported:%d",flash_str_len,QMI_VOICE_FLASH_PAYLOAD_MAX_V02);
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
      }
    }

    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK, QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    memset(&send_flash_req_msg, 0, sizeof(send_flash_req_msg));
    send_flash_req_msg.call_id = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;
    /* Flash with no info */
    if ( flash_ptr != NULL )
    {
      memcpy(send_flash_req_msg.flash_payload, flash_ptr, flash_str_len);
      send_flash_req_msg.flash_payload_valid = TRUE;
    }
    /* Command CM to send FLASH */
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE BURST DTMF REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_SEND_FLASH_REQ_V02,
                                 &send_flash_req_msg,
                                 sizeof(voice_send_flash_req_msg_v02),
                                 sizeof(voice_send_flash_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if (qmi_client_error != QMI_NO_ERR) {
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  } while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
} /* qcril_qmi_voice_request_cdma_flash() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_preferred_voice_privacy_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE.

    @return
    None.
*/
/*=========================================================================*/

void qcril_qmi_voice_request_set_preferred_voice_privacy_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  int *in_data_ptr;
  qcril_request_resp_params_type resp;
  voice_set_preferred_privacy_req_msg_v02 set_preferred_privacy_req_msg;
  voice_set_preferred_privacy_resp_msg_v02 set_preferred_privacy_resp_msg;

  RIL_Errno ril_err = RIL_E_SUCCESS;


  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  in_data_ptr = (int *)params_ptr->data;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
  {
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
  }

  memset(&set_preferred_privacy_req_msg, 0, sizeof(set_preferred_privacy_req_msg));
  switch(*in_data_ptr)
  {
      case 0:
          set_preferred_privacy_req_msg.privacy_pref = VOICE_PRIVACY_STANDARD_V02;
          break;
      case 1:
          set_preferred_privacy_req_msg.privacy_pref = VOICE_PRIVACY_ENHANCED_V02;
          break;
      default:
          set_preferred_privacy_req_msg.privacy_pref = VOICE_PRIVACY_STANDARD_V02;
  }
  QCRIL_LOG_INFO("voice privacy mode preference set %d",set_preferred_privacy_req_msg.privacy_pref);

  memset(&set_preferred_privacy_resp_msg, 0, sizeof(set_preferred_privacy_resp_msg));
  /* Send QMI VOICE SET PREFERRED PRIVACY REQ */
  if (get_voice_modem_endpoint()->sendRawSync(QMI_VOICE_SET_PREFERRED_PRIVACY_REQ_V02,
                                  &set_preferred_privacy_req_msg,
                                  sizeof(set_preferred_privacy_req_msg),
                                  &set_preferred_privacy_resp_msg,
                                  sizeof(set_preferred_privacy_resp_msg)) != QMI_NO_ERR )
  {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
  }
  else
  {
      if(set_preferred_privacy_resp_msg.resp.result == QMI_RESULT_FAILURE_V01)
      {
          QCRIL_LOG_INFO("voice privacy mode preference set error %d",set_preferred_privacy_resp_msg.resp.error);
          ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(set_preferred_privacy_resp_msg.resp.error);
          if(ril_err == RIL_E_MODEM_ERR && set_preferred_privacy_resp_msg.resp.error == QMI_ERR_INVALID_ID_V01)
          {
            ril_err = RIL_E_INVALID_CALL_ID;
          }
          break;
      }
      else
      {
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
      }
  }
  }while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }
} /* qcril_qmi_voice_request_set_preferred_voice_privacy_mode() */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_query_preferred_privacy_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE.

    @return
    None.
*/
/*=========================================================================*/

void qcril_qmi_voice_request_query_preferred_voice_privacy_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;
  int privacy_preference=0;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  voice_get_config_req_msg_v02 qmi_request;
  voice_get_config_resp_msg_v02 qmi_response;

  /*-----------------------------------------------------------------------*/

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  memset( &qmi_request, 0, sizeof( qmi_request ) );
  memset( &qmi_response, 0, sizeof(qmi_response) );
  qmi_request.voice_privacy_valid= TRUE;
  qmi_request.voice_privacy= 0x01; // as per QMI Voice - 0x01

  qmi_client_error_type transp_err = get_voice_modem_endpoint()->sendRawSync(
                              QMI_VOICE_GET_CONFIG_REQ_V02,
                              (void*)&qmi_request,
                              sizeof( qmi_request ),
                              (void*) &qmi_response,
                              sizeof( qmi_response ));
  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                              transp_err, (qmi_response_type_v01*)(&qmi_response));

  if( ril_req_res == RIL_E_SUCCESS && qmi_response.current_voice_privacy_pref_valid )
  {
    privacy_preference = qmi_response.current_voice_privacy_pref;
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = &privacy_preference;
    resp.resp_len = sizeof(privacy_preference);
    QCRIL_LOG_DEBUG("privacy_preferece = %d", privacy_preference);
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  }

  qcril_send_request_response( &resp );
} /* qcril_qmi_voice_request_query_preferred_privacy_mode() */

static void qcril_qmi_voice_set_management_call_concurrency_requirement(qcril_reqlist_generic_concurency_requests_requirement_type *req_ptr)
{
  static qcril_evt_e_type req_ids[7];
  req_ids[0] = QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND;
  req_ids[1] = QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND;
  req_ids[2] = QCRIL_EVT_RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE;
  req_ids[3] = QCRIL_EVT_RIL_REQUEST_CONFERENCE;
  req_ids[4] = QCRIL_EVT_RIL_REQUEST_EXPLICIT_CALL_TRANSFER;
  req_ids[5] = QCRIL_EVT_RIL_REQUEST_SEPARATE_CONNECTION;
  req_ids[6] = QCRIL_EVT_RIL_REQUEST_UDUB;

  req_ptr->max_concurrency = 1;
  req_ptr->max_pending = 1024;
  req_ptr->req_ids_num = sizeof(req_ids)/sizeof(req_ids[0]);
  req_ptr->req_ids = req_ids;
}

static void qcril_qmi_voice_send_management_call_request
(
  qcril_instance_id_e_type instance_id,
  struct qcril_reqlist_buf_tag *req,
  void *data,
  size_t datalen
)
{
  uint32 user_data;
  voice_manage_calls_req_msg_v02* mng_call_req_msg_ptr =
        (voice_manage_calls_req_msg_v02*)data;
  RIL_Errno ril_err = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(datalen);

  do
  {
    if( NULL == mng_call_req_msg_ptr )
    {
      QCRIL_LOG_DEBUG("mng_call_req_msg_ptr is null");
      ril_err = RIL_E_INTERNAL_ERR;
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, req->pub.req_id );

    /* Send QMI VOICE MANAGE CALLS REQ */
    qmi_client_error_type transp_err = qmi_client_voice_send_async(
                                      QMI_VOICE_MANAGE_CALLS_REQ_V02,
                                      mng_call_req_msg_ptr,
                                      sizeof(*mng_call_req_msg_ptr),
                                      sizeof(voice_manage_calls_resp_msg_v02),
                                      qcril_qmi_voice_command_cb,
                                      (void*)(uintptr_t)user_data);
    QCRIL_LOG_DEBUG("send_msg_async completed with error code: %d", transp_err);
    if ( QMI_NO_ERR != transp_err )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
    else
    {
      // update call obj state
      if ( SUPS_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD_V02 == mng_call_req_msg_ptr->sups_type )
      {
        qcril_qmi_voice_voip_unmark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
      }
      else if ( SUPS_TYPE_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING_V02 == mng_call_req_msg_ptr->sups_type )
      {
        qcril_qmi_voice_voip_mark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_CONVERSATION_V02);
        qcril_qmi_voice_voip_unmark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
      }
      else if ( SUPS_TYPE_RELEASE_HELD_OR_WAITING_V02 == mng_call_req_msg_ptr->sups_type )
      {
        qcril_qmi_voice_voip_mark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_WAITING_V02);
        qcril_qmi_voice_voip_unmark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_WAITING_V02);
        qcril_qmi_voice_voip_mark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_INCOMING_V02);
        qcril_qmi_voice_voip_unmark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, CALL_STATE_INCOMING_V02);
        qcril_qmi_voice_voip_mark_with_specified_call_state(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_BY_USER, CALL_STATE_HOLD_V02);
      }
    }
  } while ( FALSE );

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, req->pub.t, req->pub.request, ril_err );
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND
//===========================================================================
void qcril_qmi_voice_request_manage_calls_hangup_waiting_or_background
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
    qcril_reqlist_public_type reqlist_entry;
    voice_manage_calls_req_msg_v02  manage_calls_req;
    uint32 user_data;
    qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
    voice_end_call_req_msg_v02           call_end_req_msg;
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
    qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
    qcril_qmi_voice_voip_call_info_entry_type* call_info_iter = NULL;
    qcril_qmi_voice_voip_current_call_summary_type calls_summary;
    qmi_ril_voice_ims_command_exec_oversight_type*                      command_oversight;
    qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type   oversight_cmd_params;
    IxErrnoType reqlist_status;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_voice_voip_lock_overview();
    do
    {
      // find call info
      qcril_qmi_voice_voip_generate_summary( &calls_summary );
      call_info_entry = calls_summary.active_or_single_call;
      if ( NULL == call_info_entry )
      {
        QCRIL_LOG_ERROR( ".. call info not found" );
        ril_err = RIL_E_INVALID_STATE;
        break;
      }

      // DOCOMO
      if (TRUE == reject_cause_21_supported)
      {
        qcril_qmi_voice_voip_call_info_entry_type* incoming_call =
          qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
            QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, TRUE);
        if (incoming_call &&
            !(incoming_call->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL))
        {
          ril_err = qcril_qmi_voice_send_request_answer(params_ptr, TRUE);
          break;
        }
      }

      if (QMI_RIL_ZERO == calls_summary.nof_voip_calls && calls_summary.nof_3gpp2_calls)
      { // CDMA forever
        // More than one CDMA calls - possibly Dialing and Incoming states
        // Need to disconnect Incoming call
        if (calls_summary.nof_3gpp2_calls > 1)
        {
          call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
                                QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, TRUE );
          if( NULL == call_info_entry )
          {
            QCRIL_LOG_ERROR( ".. 3gpp2 incoming call not found" );
            ril_err = RIL_E_INVALID_STATE;
            break;
          }
        }

        memset( &call_end_req_msg, 0, sizeof(call_end_req_msg) );

        // add entry to ReqList
        qcril_reqlist_default_entry( params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_NONE,
                                     NULL,
                                     &reqlist_entry );
        if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
        {
            // Fail to add entry to ReqList
            QCRIL_LOG_ERROR(".. failed to Add into Req list");
            ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
            break;
        }

        // preparation
        user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

        call_end_req_msg.call_id = call_info_entry->qmi_call_id;
        qmi_client_error_type transp_err = qmi_client_voice_send_async(
                                    QMI_VOICE_END_CALL_REQ_V02,
                                    &call_end_req_msg,
                                    sizeof(call_end_req_msg),
                                    sizeof(voice_end_call_resp_msg_v02),
                                    qcril_qmi_voice_command_cb,
                                    (void*)(uintptr_t)user_data );
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                    transp_err, nullptr);
        if ( RIL_E_SUCCESS != ril_err )
        {
          break;
        }
      }
      else
      { // 3gpp or voip
        // for 3gpp we do not need call ID as QMI Voice does not requitre that for this particular operation
        // would be voip if we see any VOIP calls in held or waiting
        call_info_entry = NULL;
        call_info_iter = qcril_qmi_voice_voip_call_info_entries_enum_first();
        while (NULL != call_info_iter)
        {
          // skip shadow calls from CM space
          if (VOICE_INVALID_CALL_ID != call_info_iter->android_call_id)
          {
            if ((CALL_STATE_WAITING_V02 == call_info_iter->voice_scv_info.call_state ||
                 CALL_STATE_INCOMING_V02 == call_info_iter->voice_scv_info.call_state))
            {
              call_info_entry = call_info_iter;
              break;
            }
            if (CALL_STATE_HOLD_V02 == call_info_iter->voice_scv_info.call_state)
            {
              call_info_entry = call_info_iter;
            }
            if ((call_info_iter->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN) &&
                (CALL_STATE_HOLD_V02 == call_info_iter->voice_scv_info.call_state ||
                 CALL_STATE_WAITING_V02 == call_info_iter->voice_scv_info.call_state))
            {
              call_info_entry = call_info_iter;
            }
          }
          call_info_iter = qcril_qmi_voice_voip_call_info_entries_enum_next();
        }
        if ( NULL != call_info_entry )
        {
          if ( ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN ) )
          { // voip
            // add entry to ReqList
            qcril_reqlist_default_entry( params_ptr->t,
                                         params_ptr->event_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         QCRIL_REQ_AWAITING_CALLBACK,
                                         QCRIL_EVT_NONE,
                                         NULL,
                                         &reqlist_entry );
            if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
            {
                // Fail to add entry to ReqList
                QCRIL_LOG_ERROR(".. failed to Add into Req list");
                ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
                break;
            }

            ril_err = qcril_qmi_voice_post_manage_voip_calls_request( VOIP_SUPS_TYPE_RELEASE_HELD_OR_WAITING_V02, reqlist_entry.req_id  );
          }
          else
          { // 3gpp
            memset(&manage_calls_req, 0, sizeof(manage_calls_req));
            manage_calls_req.sups_type = SUPS_TYPE_RELEASE_HELD_OR_WAITING_V02;
            manage_calls_req.call_id_valid = FALSE;

            qcril_reqlist_default_entry( params_ptr->t,
                                         params_ptr->event_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         QCRIL_REQ_AWAITING_CALLBACK,
                                         QCRIL_EVT_NONE, NULL, &reqlist_entry );
            qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
            qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
            qcril_reqlist_buf_type *req_buf;

            IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                                    &reqlist_entry,
                                                                                    &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                                    &concurency_requirement,
                                                                                    sizeof(concurency_requirement),
                                                                                    &qcril_qmi_voice_send_management_call_request,
                                                                                    &manage_calls_req,
                                                                                    sizeof(manage_calls_req),
                                                                                    &req_buf );
            if ( E_SUCCESS == new_req_result )
            {

              if ( QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND == params_ptr->event_id )
              {
                command_oversight = qmi_ril_voice_ims_create_command_oversight( params_ptr->t, QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, TRUE );
                if ( NULL != command_oversight )
                {
                  qmi_ril_voice_ims_command_oversight_add_call_link( command_oversight,
                                                                     QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID,
                                                                     QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE,
                                                                     call_info_entry->qmi_call_id,
                                                                     CALL_STATE_END_V02 );

                  memset( &oversight_cmd_params, 0, sizeof( oversight_cmd_params ) );
                  oversight_cmd_params.locator.command_oversight = command_oversight;

                  qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_COMMENCE_AWAIT_RESP_IND,
                                                                    QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                                                    &oversight_cmd_params );
                } // if ( NULL != command_oversight )

              } // if ( RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND == params_ptr->event_id )

              qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
              ril_err = RIL_E_SUCCESS;
            }
            else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
            {
              QCRIL_LOG_INFO("the new request is blocked");
              ril_err = RIL_E_SUCCESS;
            }
            else
            {
              QCRIL_LOG_INFO("the new request is rejected");
              ril_err = RIL_E_SUCCESS;
            }
          }
        }
        else // nothing to end
        {
          ril_err = RIL_E_INVALID_STATE;
          break;
        }
      }
    } while ( FALSE );

    qcril_qmi_voice_voip_unlock_overview();

    // respond
    if ( RIL_E_SUCCESS != ril_err )
    {
        qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_err );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_request_manage_calls_hangup_waiting_or_background

//===========================================================================
//RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND
//===========================================================================
void qcril_qmi_voice_request_manage_calls_hangup_foreground_resume_background
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    uint32 user_data;
    qcril_reqlist_public_type reqlist_entry;
    voice_manage_calls_req_msg_v02  manage_calls_req;
    voice_end_call_req_msg_v02           call_end_req_msg;
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
    qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
    qcril_qmi_voice_voip_current_call_summary_type calls_summary;
    qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
    IxErrnoType reqlist_status;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_voice_voip_lock_overview();

    do
    {
      // find call info
      qcril_qmi_voice_voip_generate_summary( &calls_summary );
      call_info_entry = calls_summary.active_or_single_call;
      if ( NULL == call_info_entry )
      {
        QCRIL_LOG_ERROR( ".. call info not found" );
        ril_err = RIL_E_INVALID_STATE;
        break;
      }

      // Use QMI_VOICE_END_CALL_REQ to hangup if there is only one call
      // and is not in held state.
      if (1 == calls_summary.nof_calls_overall &&
          call_info_entry->voice_scv_info.call_state != CALL_STATE_HOLD_V02)
      { // one call
        memset( &call_end_req_msg, 0, sizeof(call_end_req_msg) );

        // add entry to ReqList
        qcril_reqlist_default_entry( params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_NONE,
                                     NULL,
                                     &reqlist_entry );
        if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
        {
            // Fail to add entry to ReqList
            QCRIL_LOG_ERROR(".. failed to Add into Req list");
            ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
            break;
        }

        // preparation
        user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

        call_end_req_msg.call_id = call_info_entry->qmi_call_id;
        qmi_client_error_type transp_err = qmi_client_voice_send_async(
                                        QMI_VOICE_END_CALL_REQ_V02,
                                        &call_end_req_msg,
                                        sizeof(call_end_req_msg),
                                        sizeof(voice_end_call_resp_msg_v02),
                                        qcril_qmi_voice_command_cb,
                                        (void*)(uintptr_t)user_data );
        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                        transp_err, nullptr);
        if ( RIL_E_SUCCESS != ril_err )
          break;
      }
      else
      { // multiple
        if ( calls_summary.nof_voip_calls > QMI_RIL_ZERO )
        { // voip
          // add entry to ReqList
          qcril_reqlist_default_entry( params_ptr->t,
                                       params_ptr->event_id,
                                       QCRIL_DEFAULT_MODEM_ID,
                                       QCRIL_REQ_AWAITING_CALLBACK,
                                       QCRIL_EVT_NONE,
                                       NULL,
                                       &reqlist_entry );
          if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
          {
              // Fail to add entry to ReqList
              QCRIL_LOG_ERROR(".. failed to Add into Req list");
              ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
              break;
          }
          ril_err = qcril_qmi_voice_post_manage_voip_calls_request( VOIP_SUPS_TYPE_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING_V02, reqlist_entry.req_id  );
        }
        else
        { // voice
          memset(&manage_calls_req, 0, sizeof(manage_calls_req));
          manage_calls_req.sups_type = SUPS_TYPE_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING_V02;
          manage_calls_req.call_id_valid = FALSE;

          qcril_reqlist_default_entry( params_ptr->t,
                                       params_ptr->event_id,
                                       QCRIL_DEFAULT_MODEM_ID,
                                       QCRIL_REQ_AWAITING_CALLBACK,
                                       QCRIL_EVT_NONE, NULL, &reqlist_entry );
          qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
          qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
          qcril_reqlist_buf_type *req_buf;

          IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                                  &reqlist_entry,
                                                                                  &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                                  &concurency_requirement,
                                                                                  sizeof(concurency_requirement),
                                                                                  &qcril_qmi_voice_send_management_call_request,
                                                                                  &manage_calls_req,
                                                                                  sizeof(manage_calls_req),
                                                                                  &req_buf );
          if ( E_SUCCESS == new_req_result )
          {
            qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
            ril_err = RIL_E_SUCCESS;
          }
          else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
          {
            QCRIL_LOG_INFO("the new request is blocked");
            ril_err = RIL_E_SUCCESS;
          }
          else
          {
            QCRIL_LOG_INFO("the new request is rejected");
            ril_err = RIL_E_SUCCESS;
          }
        }
      }
    } while ( FALSE );

    qcril_qmi_voice_voip_unlock_overview();

    // respond
    if ( RIL_E_SUCCESS != ril_err )
    {
        qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_err );

    }
    else
    {
      qcril_qmi_voice_voip_mark_with_specified_call_state(
         QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE,
         CALL_STATE_WAITING_V02 );
      qcril_qmi_voice_voip_mark_with_specified_call_state(
         QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE,
         CALL_STATE_HOLD_V02 );
#ifndef QMI_RIL_UTF
      qcril_am_handle_event(QCRIL_AM_EVENT_SWITCH_CALL, NULL);
#endif
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_manage_calls_hangup_foreground_resume_background


//=========================================================================
//qcril_qmi_voice_post_manage_voip_calls_request
//===========================================================================
RIL_Errno qcril_qmi_voice_post_manage_voip_calls_request( voip_sups_type_enum_v02 request, uint16 req_id )
{
    RIL_Errno                             res = RIL_E_GENERIC_FAILURE;
    voice_manage_ip_calls_req_msg_v02     manage_voip_calls_req;
    uint32                                user_data;

    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, req_id );

    memset( &manage_voip_calls_req, 0, sizeof( manage_voip_calls_req ));
    manage_voip_calls_req.sups_type = request;

    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                    QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                    (void*) &manage_voip_calls_req,
                                    sizeof( manage_voip_calls_req ),
                                    sizeof( voice_manage_ip_calls_resp_msg_v02 ),
                                    qcril_qmi_voice_command_cb,
                                    (void*)(uintptr_t)user_data );
    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

    QCRIL_LOG_INFO("posted req %d, %d", (int) qmi_client_error, (int) res );

    return res;
} // qcril_qmi_voice_post_manage_voip_calls_request

//===========================================================================
// qcril_qmi_voice_voip_manage_ip_calls_resp_hdlr
//===========================================================================
void qcril_qmi_voice_voip_manage_ip_calls_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
    voice_manage_ip_calls_resp_msg_v02        *qmi_response = NULL;
    RIL_Errno                                  ril_req_res = RIL_E_GENERIC_FAILURE;
    unsigned int                               i = 0;
    char manage_ip_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
    int utf8_len = 0;
    if (params_ptr->data != NULL)
    {
        qmi_response = (voice_manage_ip_calls_resp_msg_v02 *) params_ptr->data;

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(QMI_NO_ERR,
                       &qmi_response->resp,
                       QCRIL_QMI_ERR_CTX_MNG_IP_TXN,
                       qmi_response);

        QCRIL_LOG_INFO(".. ril res %d, qmi res %d",
                       (int) ril_req_res, (int)qmi_response->resp.error);

        if (QCRIL_EVT_RIL_REQUEST_CONFERENCE == params_ptr->event_id ||
            QCRIL_EVT_IMS_SOCKET_REQ_CONFERENCE == params_ptr->event_id)
        {
           if (RIL_E_SUCCESS == ril_req_res)
           {
#ifndef QMI_RIL_UTF
             if (QCRIL_EVT_IMS_SOCKET_REQ_CONFERENCE == params_ptr->event_id)
             {
               qcril_qmi_voice_send_ims_unsol_call_state_changed();
             }
             else
             {
               qcril_qmi_voice_send_unsol_call_state_changed(QCRIL_DEFAULT_INSTANCE_ID);
             }
#endif
          }
        }

        if ((QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_INITIATE == params_ptr->event_id ||
              QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_CONFIRM == params_ptr->event_id)
            && (ril_req_res == RIL_E_SUCCESS))
        {
           /* wait for modify indication, update state to wait for more events */
           qcril_reqlist_update_state( QCRIL_DEFAULT_INSTANCE_ID,
                                       QCRIL_DEFAULT_MODEM_ID,
                                       params_ptr->t,
                                       QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS );
        }
        else if((QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_INITIATE == params_ptr->event_id)
                 && (qmi_response->failure_cause_valid == TRUE)
                 && (qmi_response->failure_cause == QMI_FAILURE_CAUSE_UPGRADE_DOWNGRADE_REJ_V02))
        {
              imsRadioSendMessage(params_ptr->t,
                                        ims_MsgType_RESPONSE,
                                        qcril_qmi_ims_map_event_to_request(params_ptr->event_id),
                                        ims_Error_E_REJECTED_BY_REMOTE,
                                        NULL,
                                        0);
        }
        else
        {
           if ((QCRIL_EVT_IMS_SOCKET_REQ_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ==
                 params_ptr->event_id) &&
               QMI_ERR_OP_NETWORK_UNSUPPORTED_V01 == qmi_response->resp.error)
           {
              imsRadioSendMessage(params_ptr->t,
                                        ims_MsgType_RESPONSE,
                                        qcril_qmi_ims_map_event_to_request(params_ptr->event_id),
                                        ims_Error_E_IMS_DEREGISTERED,
                                        NULL,
                                        0);
           }
           else if (QCRIL_EVT_IMS_SOCKET_REQ_HANGUP == params_ptr->event_id)
           {
              qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
                                                        params_ptr->t,
                                                        params_ptr->event_id,
                                                        ril_req_res );
           }
           else if (RIL_E_SUCCESS != ril_req_res &&
                    (qmi_response->sip_error_code_valid == TRUE ||
                     qmi_response->end_reason_text_valid == TRUE)&&
                    (QCRIL_EVT_IMS_SOCKET_REQ_CONFERENCE == params_ptr->event_id ||
                     QCRIL_EVT_IMS_SOCKET_REQ_HOLD == params_ptr->event_id ||
                     QCRIL_EVT_IMS_SOCKET_REQ_RESUME == params_ptr->event_id ||
                     QCRIL_EVT_IMS_SOCKET_REQ_ADD_PARTICIPANT == params_ptr->event_id))
           {
             ims_SipErrorInfo info;
             memset(&info, 0, sizeof(info));
             if (qmi_response->sip_error_code_valid == TRUE)
             {
               info.has_sipErrorCode = TRUE;
               info.sipErrorCode = qmi_response->sip_error_code;
               QCRIL_LOG_INFO("sip_error_code %d", info.sipErrorCode);
             }
             if (qmi_response->end_reason_text_valid == TRUE &&
                 qmi_response->end_reason_text_len > 0)
             {
               for (i = 0; i < qmi_response->end_reason_text_len; i++)
               {
                 if (qmi_response->end_reason_text[i].end_reason_text_len > 0)
                 {
                   memset(manage_ip_sip_err_utf8_str, 0x0, sizeof(manage_ip_sip_err_utf8_str));
                   utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
                                    (char *)qmi_response->end_reason_text[i].end_reason_text,
                                    qmi_response->end_reason_text[i].end_reason_text_len * 2,
                                    manage_ip_sip_err_utf8_str,
                                    sizeof(manage_ip_sip_err_utf8_str));
                   utf8_len = utf8_len + 1;
                   if ( utf8_len > ( QCRIL_QMI_VOICE_FAIL_CAUSE_STR_LEN ) )
                   {
                     QCRIL_LOG_ERROR ("Length exceeds maximum sip error size" );
                     utf8_len = (int) (QCRIL_QMI_VOICE_FAIL_CAUSE_STR_LEN);
                     manage_ip_sip_err_utf8_str[ utf8_len - 1] = '\0';
                   }
                   utf8_len = utf8_len + 1;
                   QCRIL_LOG_ERROR("QCRIL QMI VOICE MANAGE IP RESP len =%d,"
                                   "failure_description=%s", utf8_len,
                                   manage_ip_sip_err_utf8_str);
                   info.sipErrorString.arg = qcril_malloc(utf8_len);
                   if ( info.sipErrorString.arg )
                   {
                     strlcpy((char *)info.sipErrorString.arg, manage_ip_sip_err_utf8_str, utf8_len);
                     QCRIL_LOG_INFO("sip_error_string %s", info.sipErrorString.arg);
                   }
                   break;
                 }
               }
             }
             imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE,
                                       qcril_qmi_ims_map_event_to_request(params_ptr->event_id),
                                       ims_Error_E_GENERIC_FAILURE,
                                       (void *)&info, sizeof(info));
           }
           else
           {
              qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
                                                        params_ptr->t,
                                                        params_ptr->event_id,
                                                        ril_req_res );
           }
        }

        if (QCRIL_EVT_IMS_SOCKET_REQ_HANGUP_FOREGROUND_RESUME_BACKGROUND == params_ptr->event_id ||
            QCRIL_EVT_IMS_SOCKET_REQ_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE == params_ptr->event_id ||
            QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND == params_ptr->event_id ||
            QCRIL_EVT_RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE == params_ptr->event_id ||
            QCRIL_EVT_IMS_SOCKET_REQ_RESUME == params_ptr->event_id )
        {
            qcril_qmi_voice_voip_unmark_all_with(QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE);
            if (RIL_E_SUCCESS != ril_req_res)
            {
#ifndef QMI_RIL_UTF
                qcril_am_handle_event(QCRIL_AM_EVENT_SWITCH_CALL_FAIL, NULL);
#endif
            }
        }

        if (QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_INITIATE == params_ptr->event_id ||
                QCRIL_EVT_IMS_SOCKET_REQ_MODIFY_CALL_CONFIRM == params_ptr->event_id)
        {
            if (qmi_response->call_modified_cause_valid &&
                    qmi_response->call_id_valid)
            {
                qcril_qmi_voice_call_info_entry_set_call_modified_cause(
                        qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id(
                            qmi_response->call_id),
                        qmi_response->call_modified_cause);
            }
        }
    }
    else
    {
        qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
                                                  params_ptr->t,
                                                  params_ptr->event_id,
                                                  RIL_E_SYSTEM_ERR );
    }


    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_voip_manage_ip_calls_resp_hdlr


//=========================================================================
//RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE
//===========================================================================
void qcril_qmi_voice_request_manage_calls_switch_waiting_or_holding_and_active
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  voice_manage_calls_req_msg_v02  manage_calls_req;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  ims_SwitchWaitingOrHoldingAndActive *ims_in_data_ptr = NULL;
  IxErrnoType reqlist_status;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_voip_lock_overview();

  do
  {
    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_ERROR(".. nof voice %d, nof voip %d", call_summary.nof_voice_calls, call_summary.nof_voip_calls );
    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls + call_summary.nof_voice_calls )
    {
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }

    if ( call_summary.nof_voip_calls > QMI_RIL_ZERO )
    { // voip
      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE,
                                   NULL,
                                   &reqlist_entry );
      if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
      {
          // Fail to add entry to ReqList
          QCRIL_LOG_ERROR(".. failed to Add into Req list");
          ril_req_res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
          break;
      }

      ims_CallType call_type;
      qcril_qmi_voice_voip_call_info_entry_type *call_info = NULL;

      if ( QCRIL_EVT_IMS_SOCKET_REQ_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE == params_ptr->event_id )
      {
         ims_in_data_ptr = (ims_SwitchWaitingOrHoldingAndActive *)params_ptr->data;
         if (ims_in_data_ptr)
         {
            if (ims_in_data_ptr->has_call_type)
            {
               call_type = ims_in_data_ptr->call_type;
               call_info = qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state(RIL_CALL_WAITING);
               if ( !call_info )
               {
                  QCRIL_LOG_DEBUG(".. do not have waiting call while the call type is specified in IMS request");
               }
            }
         }
         else
         {
            QCRIL_LOG_DEBUG("ims_in_data_ptr is NULL");
         }
      }

      if ( call_info )
      {
         voice_manage_ip_calls_req_msg_v02   manage_voip_calls_req;

         qmi_client_error_type qmi_client_error = QMI_NO_ERR;
         uint32                user_data;

         // Cache the user specified call type in answer.
         call_info->answered_call_type_valid = TRUE;
         call_info->answered_call_type = call_type;

         user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

         memset( &manage_voip_calls_req, 0, sizeof(manage_voip_calls_req) );
         manage_voip_calls_req.sups_type = VOIP_SUPS_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD_V02;
         manage_voip_calls_req.call_id_valid = TRUE;
         manage_voip_calls_req.call_id = call_info->voice_scv_info.call_id;

         if ( ims_CallType_CALL_TYPE_VOICE == call_type )
         {
            manage_voip_calls_req.call_type_valid = TRUE;
            manage_voip_calls_req.call_type = CALL_TYPE_VOICE_IP_V02;
         }
         else if ( ims_CallType_CALL_TYPE_VT == call_type )
         {
            manage_voip_calls_req.call_type_valid = TRUE;
            manage_voip_calls_req.call_type = CALL_TYPE_VT_V02;
            manage_voip_calls_req.video_attrib_valid = TRUE;
            manage_voip_calls_req.video_attrib = VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
         }
         else if ( ims_CallType_CALL_TYPE_VT_TX == call_type )
         {
            manage_voip_calls_req.call_type_valid = TRUE;
            manage_voip_calls_req.call_type = CALL_TYPE_VT_V02;
            manage_voip_calls_req.video_attrib_valid = TRUE;
            manage_voip_calls_req.video_attrib = VOICE_CALL_ATTRIB_TX_V02;
         }
         else if ( ims_CallType_CALL_TYPE_VT_RX == call_type )
         {
            manage_voip_calls_req.call_type_valid = TRUE;
            manage_voip_calls_req.call_type = CALL_TYPE_VT_V02;
            manage_voip_calls_req.video_attrib_valid = TRUE;
            manage_voip_calls_req.video_attrib = VOICE_CALL_ATTRIB_RX_V02;
         }
         else
         {
            QCRIL_LOG_DEBUG("Received unexpected call type. Ignore the type specified.");
            manage_voip_calls_req.call_id_valid = FALSE;
            call_info->answered_call_type_valid = FALSE;
         }

         qmi_client_error = qmi_client_voice_send_async(
                                     QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                     (void*) &manage_voip_calls_req,
                                     sizeof( manage_voip_calls_req ),
                                     sizeof( voice_manage_ip_calls_resp_msg_v02 ),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data );

         ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );
      }
      else
      {
         ril_req_res = qcril_qmi_voice_post_manage_voip_calls_request( VOIP_SUPS_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD_V02 , reqlist_entry.req_id );
      }
    }
    else
    { // voice
      memset(&manage_calls_req, 0, sizeof(manage_calls_req));
      manage_calls_req.sups_type = SUPS_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD_V02;
      manage_calls_req.call_id_valid = FALSE;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
      qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
      qcril_reqlist_buf_type *req_buf;

      IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                              &reqlist_entry,
                                                                              &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                              &concurency_requirement,
                                                                              sizeof(concurency_requirement),
                                                                              &qcril_qmi_voice_send_management_call_request,
                                                                              &manage_calls_req,
                                                                              sizeof(manage_calls_req),
                                                                              &req_buf );
      if ( E_SUCCESS == new_req_result )
      {
        qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
        ril_req_res = RIL_E_SUCCESS;
      }
      else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
      {
        QCRIL_LOG_INFO("the new request is blocked");
        ril_req_res = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_INFO("the new request is rejected");
        ril_req_res = RIL_E_SUCCESS;
      }
    }

  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res );
  }
  else
  {
    qcril_qmi_voice_voip_mark_with_specified_call_state(
       QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE,
       CALL_STATE_WAITING_V02 );
    qcril_qmi_voice_voip_mark_with_specified_call_state(
       QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE,
       CALL_STATE_HOLD_V02 );
#ifndef QMI_RIL_UTF
    qcril_am_handle_event(QCRIL_AM_EVENT_SWITCH_CALL, NULL);
#endif
  }

  qcril_qmi_voice_voip_unlock_overview();

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_manage_calls_switch_waiting_or_holding_and_active

/*===========================================================================
  FUNCTION:  qcril_qmi_voice_request_manage_calls_hold_resume
===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_HOLD and
            QCRIL_EVT_IMS_SOCKET_REQ_RESUME.

    @return:
    None
*/
/*=========================================================================*/
void qcril_qmi_voice_request_manage_calls_hold_resume
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_evt_e_type event = (qcril_evt_e_type)params_ptr->event_id;
  qcril_reqlist_public_type reqlist_entry;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  ims_Hold *ims_in_data_ptr_hold = NULL;
  ims_Resume *ims_in_data_ptr_resume = NULL;
  voip_sups_type_enum_v02 supsType;
  uint8_t call_id;
  qcril_qmi_voice_voip_call_info_entry_type *call_info = NULL;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_voip_lock_overview();

  do
  {
    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_ESSENTIAL("Number of voip calls : %d", call_summary.nof_voip_calls );

    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls )
    {
      break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS )
    {
        // Fail to add entry to ReqList
        QCRIL_LOG_ERROR(".. failed to Add into Req list");
        break;
    }

    if ( QCRIL_EVT_IMS_SOCKET_REQ_HOLD == event )
    {
      ims_in_data_ptr_hold = (ims_Hold *)params_ptr->data;
      supsType = VOIP_SUPS_TYPE_CALL_HOLD_V02;

      if (ims_in_data_ptr_hold)
      {
        QCRIL_LOG_DEBUG("Has callid? %d, callId: %d", ims_in_data_ptr_hold->has_callId,
            ims_in_data_ptr_hold->callId);
        if (TRUE == ims_in_data_ptr_hold->has_callId)
        {
          call_id = ims_in_data_ptr_hold->callId;
          call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(call_id);
        }
        else
        {
          //Call id is mandatory
          QCRIL_LOG_ERROR("Invalid call id");
        }
        if ( !call_info )
        {
          QCRIL_LOG_ERROR("Do not have any voip active calls or invalid call id in request");
        }
      }
      else
      {
        QCRIL_LOG_ERROR("Hold request data is NULL");
      }
    }

    if ( QCRIL_EVT_IMS_SOCKET_REQ_RESUME == event )
    {
      ims_in_data_ptr_resume = (ims_Resume *)params_ptr->data;
      supsType = VOIP_SUPS_TYPE_CALL_RESUME_V02;

      if (ims_in_data_ptr_resume)
      {
        if (TRUE == ims_in_data_ptr_resume->has_callId)
        {
          call_id = ims_in_data_ptr_resume->callId;
          call_info = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(call_id);
        }
        else
        {
          QCRIL_LOG_ERROR("Invalid call id");
        }

        if ( !call_info )
        {
          QCRIL_LOG_ERROR("Do not have any voip held calls or invalid call id in request");
        }
      }
      else
      {
        QCRIL_LOG_ERROR("Resume request data is NULL");
      }
    }

    if ( call_info )
    {
      voice_manage_ip_calls_req_msg_v02   manage_voip_calls_req;

      qmi_client_error_type qmi_client_error = QMI_NO_ERR;
      uint32                user_data;

      user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID,
                                           QCRIL_DEFAULT_MODEM_ID,
                                           reqlist_entry.req_id );

      memset( &manage_voip_calls_req, 0, sizeof(manage_voip_calls_req) );
      manage_voip_calls_req.sups_type = supsType;
      manage_voip_calls_req.call_id_valid = TRUE;
      manage_voip_calls_req.call_id = call_info->voice_scv_info.call_id;

      qmi_client_error = qmi_client_voice_send_async(QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                                      &manage_voip_calls_req,
                                                      sizeof( manage_voip_calls_req ),
                                                      sizeof( voice_manage_ip_calls_resp_msg_v02 ),
                                                      qcril_qmi_voice_command_cb,
                                                      (void*)(uintptr_t)user_data );
      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error,
                                                                               NULL );
    }
  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // Failure
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t,
                                               params_ptr->event_id, ril_req_res );
  }
  else
  {
    if( QCRIL_EVT_IMS_SOCKET_REQ_RESUME == event )
    {
      call_info->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SWITCHING_CALL_TO_ACTIVE;

#ifndef QMI_RIL_UTF
      qcril_am_handle_event(QCRIL_AM_EVENT_SWITCH_CALL, NULL);
#endif
    }
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_manage_calls_request_hold_resume

//===========================================================================
// qcril_qmi_voice_request_add_participant
//===========================================================================
void qcril_qmi_voice_request_add_participant
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  ims_Dial *ims_in_data_ptr = (ims_Dial *)params_ptr->data;
  uint8 call_id = VOICE_INVALID_CALL_ID;
  qcril_qmi_voice_voip_current_call_summary_type calls_summary;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if (!ims_in_data_ptr || !ims_in_data_ptr->address.arg ||
           strlen((char*)ims_in_data_ptr->address.arg) > QMI_VOICE_SIP_URI_MAX_V02)
    {
      QCRIL_LOG_ERROR("invalid parameter");
      break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS )
    {
      // Fail to add entry to ReqList
      QCRIL_LOG_ERROR(".. failed to Add into Req list");
      break;
    }

    qcril_qmi_voice_voip_generate_summary(&calls_summary);
    QCRIL_LOG_DEBUG("number of calls = %d", calls_summary.nof_calls_overall);

    if (calls_summary.nof_calls_overall == 1)
    {
      call_info_entry = calls_summary.active_or_single_call;
    }
    else
    {
      // Get the call in conversation state if more than one call
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state(
                                CALL_STATE_CONVERSATION_V02);
    }

    QCRIL_LOG_INFO(".. call_info_entry %p", call_info_entry);

    if (!call_info_entry ||
            (VOICE_INVALID_CALL_ID == call_info_entry->qmi_call_id) ||
            !(CALL_STATE_CONVERSATION_V02 == call_info_entry->voice_scv_info.call_state ||
                CALL_STATE_HOLD_V02 == call_info_entry->voice_scv_info.call_state) ||
            !(CALL_TYPE_VOICE_IP_V02 == call_info_entry->voice_scv_info.call_type ||
                CALL_TYPE_VT_V02 == call_info_entry->voice_scv_info.call_type))
    {
      QCRIL_LOG_ERROR("No valid call info entry");
      qcril_qmi_voice_voip_call_info_dump(call_info_entry);
      break;
    }

    call_id = call_info_entry->voice_scv_info.call_id;

    voice_manage_ip_calls_req_msg_v02   manage_voip_calls_req;
    qmi_client_error_type qmi_client_error = QMI_NO_ERR;
    uint32                user_data;

    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    memset( &manage_voip_calls_req, 0, sizeof(manage_voip_calls_req) );
    manage_voip_calls_req.sups_type = VOIP_SUPS_TYPE_ADD_PARTICIPANT_V02;
    manage_voip_calls_req.call_id_valid = TRUE;
    manage_voip_calls_req.call_id = call_id;
    manage_voip_calls_req.sip_uri_valid = TRUE;
    memcpy(&manage_voip_calls_req.sip_uri, ims_in_data_ptr->address.arg,
           strlen((char*)ims_in_data_ptr->address.arg));

    qmi_client_error = qmi_client_voice_send_async(QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                                    (void*) &manage_voip_calls_req,
                                                    sizeof( manage_voip_calls_req ),
                                                    sizeof( voice_manage_ip_calls_resp_msg_v02 ),
                                                    qcril_qmi_voice_command_cb,
                                                    (void*)(uintptr_t)user_data );
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );
  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res );
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_add_participant

//=========================================================================
//RIL_REQUEST_CONFERENCE
//===========================================================================
void qcril_qmi_voice_request_manage_calls_conference
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  voice_manage_calls_req_msg_v02  manage_calls_req;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  IxErrnoType reqlist_status;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_voip_lock_overview();

  do
  {
    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_ERROR(".. nof voice %d, nof voip %d", call_summary.nof_voice_calls, call_summary.nof_voip_calls );
    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls + call_summary.nof_voice_calls )
    {
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }

    if ( call_summary.nof_voip_calls > QMI_RIL_ZERO )
    { // voip
      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE,
                                   NULL,
                                   &reqlist_entry );
      if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
      {
          // Fail to add entry to ReqList
          QCRIL_LOG_ERROR(".. failed to Add into Req list");
          ril_req_res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
          break;
      }
      ril_req_res = qcril_qmi_voice_post_manage_voip_calls_request( VOIP_SUPS_TYPE_MAKE_CONFERENCE_CALL_V02, reqlist_entry.req_id  );
    }
    else
    { // voice
      memset(&manage_calls_req, 0, sizeof(manage_calls_req));
      manage_calls_req.sups_type = SUPS_TYPE_MAKE_CONFERENCE_CALL_V02;
      manage_calls_req.call_id_valid = FALSE;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
      qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
      qcril_reqlist_buf_type *req_buf;

      IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                              &reqlist_entry,
                                                                              &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                              &concurency_requirement,
                                                                              sizeof(concurency_requirement),
                                                                              &qcril_qmi_voice_send_management_call_request,
                                                                              &manage_calls_req,
                                                                              sizeof(manage_calls_req),
                                                                              &req_buf );
      if ( E_SUCCESS == new_req_result )
      {
        qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
        ril_req_res = RIL_E_SUCCESS;
      }
      else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
      {
        QCRIL_LOG_INFO("the new request is blocked");
        ril_req_res = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_INFO("the new request is rejected");
        ril_req_res = RIL_E_SUCCESS;
      }
    }

  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res );
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_manage_calls_conference

//===========================================================================
//RIL_REQUEST_EXPLICIT_CALL_TRANSFER
//===========================================================================
void qcril_qmi_voice_request_manage_calls_explicit_call_transfer
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_manage_calls_req_msg_v02  manage_calls_req;
  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_voip_lock_overview();

  do
  {
    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_ERROR(".. nof voice %d, nof voip %d", call_summary.nof_voice_calls, call_summary.nof_voip_calls );
    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls + call_summary.nof_voice_calls )
    {
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }

    if ( call_summary.nof_voip_calls > QMI_RIL_ZERO )
    { // voip - not applicable
      QCRIL_LOG_ERROR(".. not supported for voip call");
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }
    else
    { // voice
      memset(&manage_calls_req, 0, sizeof(manage_calls_req));
      manage_calls_req.sups_type = SUPS_TYPE_EXPLICIT_CALL_TRANSFER_V02;
      manage_calls_req.call_id_valid = FALSE;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
      qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
      qcril_reqlist_buf_type *req_buf;

      IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                              &reqlist_entry,
                                                                              &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                              &concurency_requirement,
                                                                              sizeof(concurency_requirement),
                                                                              &qcril_qmi_voice_send_management_call_request,
                                                                              &manage_calls_req,
                                                                              sizeof(manage_calls_req),
                                                                              &req_buf );

      if ( E_SUCCESS == new_req_result )
      {
        qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
        ril_req_res = RIL_E_SUCCESS;
      }
      else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
      {
        QCRIL_LOG_INFO("the new request is blocked");
        ril_req_res = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_INFO("the new request is rejected");
        ril_req_res = RIL_E_SUCCESS;
      }
    }

  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();

}/*qcril_qmi_voice_request_manage_calls_explicit_call_transfer*/

//===========================================================================
//RIL_REQUEST_SEPARATE_CONNECTION
//===========================================================================
void qcril_qmi_voice_request_manage_calls_seperate_connection
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr //Output parameter
)
{
  qcril_reqlist_public_type                       reqlist_entry;
  qcril_request_resp_params_type                  resp;
  voice_manage_calls_req_msg_v02                  manage_calls_req;

  qcril_qmi_voice_voip_current_call_summary_type  call_summary;
  RIL_Errno                                       ril_req_res = RIL_E_GENERIC_FAILURE;
  int                                             must_responds_anyway = FALSE;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_qmi_voice_voip_call_info_entry_type *     call_info_entry = NULL;
  int *                                           param_call_id = NULL;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_voip_lock_overview();

  do
  {
    param_call_id = (int *) params_ptr->data; // Connection Index
    if ( NULL == param_call_id )
    {
      QCRIL_LOG_ERROR(".. invalid param");
      ril_req_res = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    QCRIL_LOG_INFO( ".. con idx param %d", (int)*param_call_id );
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id( *param_call_id );
    if ( NULL == call_info_entry )
    {
      QCRIL_LOG_ERROR(".. internal call record not found");
      ril_req_res = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_INFO( ".. nof voice %d, nof voip %d, nof 3gpp %d, nof 3gpp2 %d, nof active %d",
                    call_summary.nof_voice_calls, call_summary.nof_voip_calls,
                    call_summary.nof_3gpp_calls, call_summary.nof_3gpp2_calls,
                    call_summary.nof_active_calls );
    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls + call_summary.nof_voice_calls )
    {
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }

    if ( call_summary.nof_voip_calls > QMI_RIL_ZERO || call_summary.nof_3gpp2_calls > QMI_RIL_ZERO )
    { // voip - not applicable
      QCRIL_LOG_ERROR(".. not supported for voip or 3gpp2 call");
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }
    else if ( 1 == call_summary.nof_calls_overall )
    { // single call, return success
      ril_req_res = RIL_E_SUCCESS;
      must_responds_anyway = TRUE;
      break;
    }
    else if ( 1 == call_summary.nof_active_calls &&
              CALL_STATE_CONVERSATION_V02 == call_info_entry->voice_scv_info.call_state )
    { // the call_id passed in is the only active call, return success
      ril_req_res = RIL_E_SUCCESS;
      must_responds_anyway = TRUE;
      break;
    }
    else
    { // 3gpp conf call
      memset(&manage_calls_req, 0, sizeof(manage_calls_req));
      manage_calls_req.sups_type          = SUPS_TYPE_HOLD_ALL_EXCEPT_SPECIFIED_CALL_V02;
      manage_calls_req.call_id_valid      = TRUE;
      manage_calls_req.call_id            = call_info_entry->qmi_call_id;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
      qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
      qcril_reqlist_buf_type *req_buf;

      IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                              &reqlist_entry,
                                                                              &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                              &concurency_requirement,
                                                                              sizeof(concurency_requirement),
                                                                              &qcril_qmi_voice_send_management_call_request,
                                                                              &manage_calls_req,
                                                                              sizeof(manage_calls_req),
                                                                              &req_buf );
      if ( E_SUCCESS == new_req_result )
      {
        qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
        ril_req_res = RIL_E_SUCCESS;
      }
      else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
      {
        QCRIL_LOG_INFO("the new request is blocked");
        ril_req_res = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_INFO("the new request is rejected");
        ril_req_res = RIL_E_SUCCESS;
      }
    }
  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res || must_responds_anyway )
  { // failure
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_manage_calls_seperate_connection

//===========================================================================
//RIL_REQUEST_UDUB
//===========================================================================
void qcril_qmi_voice_request_manage_calls_udub
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_manage_calls_req_msg_v02  manage_calls_req;

  qcril_qmi_voice_voip_current_call_summary_type call_summary;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_voip_lock_overview();

  do
  {
    qcril_qmi_voice_voip_generate_summary( &call_summary );

    QCRIL_LOG_ERROR(".. nof voice %d, nof voip %d", call_summary.nof_voice_calls, call_summary.nof_voip_calls );
    if ( QMI_RIL_ZERO == call_summary.nof_voip_calls + call_summary.nof_voice_calls )
    {
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }

    if ( call_summary.nof_voip_calls > QMI_RIL_ZERO )
    { // voip - not applicable
      QCRIL_LOG_ERROR(".. not supported for voip call");
      ril_req_res = RIL_E_INVALID_STATE;
      break;
    }
    else
    { // voice
      memset(&manage_calls_req, 0, sizeof(manage_calls_req));
      manage_calls_req.sups_type = SUPS_TYPE_RELEASE_HELD_OR_WAITING_V02;
      manage_calls_req.call_id_valid = FALSE;

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE, NULL, &reqlist_entry );
      qcril_reqlist_generic_concurency_requests_requirement_type concurency_requirement;
      qcril_qmi_voice_set_management_call_concurrency_requirement(&concurency_requirement);
      qcril_reqlist_buf_type *req_buf;

      IxErrnoType new_req_result = qcril_reqlist_new_with_concurency_control( instance_id,
                                                                              &reqlist_entry,
                                                                              &qcril_reqlist_generic_check_concurrency_from_set_of_requests,
                                                                              &concurency_requirement,
                                                                              sizeof(concurency_requirement),
                                                                              &qcril_qmi_voice_send_management_call_request,
                                                                              &manage_calls_req,
                                                                              sizeof(manage_calls_req),
                                                                              &req_buf );
      if ( E_SUCCESS == new_req_result )
      {
        qcril_qmi_voice_send_management_call_request( instance_id, req_buf, &manage_calls_req, sizeof(manage_calls_req) );
        ril_req_res = RIL_E_SUCCESS;
      }
      else if ( E_BLOCKED_BY_OUTSTANDING_REQ == new_req_result )
      {
        QCRIL_LOG_INFO("the new request is blocked");
        ril_req_res = RIL_E_SUCCESS;
      }
      else
      {
        QCRIL_LOG_INFO("the new request is rejected");
        ril_req_res = RIL_E_SUCCESS;
      }
    }
  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }

  qcril_qmi_voice_voip_unlock_overview();
  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_voice_request_manage_calls_udub

/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_supp_svc_notification

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION.
    Enables/disables supplementary service related notifications from the network.
    Notifications are reported via RIL_UNSOL_SUPP_SVC_NOTIFICATION

    All the events required for notification are either registered or /de-registered
    based on the input.

    Input Paramerers:
    const int *
    ((const int *)data)[0] to enable or disable the notifications.

    @return:
    None
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_supp_svc_notification
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  int *in_data_ptr;
  ims_SuppSvcStatus *ims_in_data_ptr;
  uint32 user_data;
  int supps_notification;
  qcril_reqlist_public_type reqlist_entry;
  voice_indication_register_req_msg_v02  indication_req;
  RIL_Errno res = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  if (NULL == params_ptr || NULL == params_ptr->data)
  {
    QCRIL_LOG_INFO("params_ptr or params_ptr is NULL");
    return;
  }

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  if ( QCRIL_EVT_RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION == params_ptr->event_id )
  {
    in_data_ptr = (int *)params_ptr->data;
    supps_notification = in_data_ptr[0];
  }
  else
  {
    ims_in_data_ptr = (ims_SuppSvcStatus *)params_ptr->data;
    supps_notification = (int)ims_in_data_ptr->status;
  }
  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
        res = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    QCRIL_LOG_DEBUG("Supps notification status : %s",
     ((supps_notification == (int)QCRIL_QMI_VOICE_SS_ENABLE_NOTIFICATION) ?  "Enable" : "Disable"));

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    memset(&indication_req, 0, sizeof(indication_req));
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    if ( supps_notification == (int) QCRIL_QMI_VOICE_SS_ENABLE_NOTIFICATION ) {
      /* Register for Call events */
      /* Send QMI VOICE INDICATION REQ */
      indication_req.supps_notification_events_valid = TRUE;
      indication_req.supps_notification_events = 0x01;
    } else if ( supps_notification == (int) QCRIL_QMI_VOICE_SS_DISABLE_NOTIFICATION ) {
      indication_req.supps_notification_events_valid = TRUE;
      indication_req.supps_notification_events = 0x00;
    } else {
      res = RIL_E_INVALID_ARGUMENTS;
      QCRIL_LOG_ERROR("Received invalid params");
      break;
    }

    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_INDICATION_REGISTER_REQ_V02,
                                 &indication_req,
                                 sizeof(voice_indication_register_req_msg_v02),
                                 sizeof(voice_indication_register_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)user_data);
    if (qmi_client_error != QMI_NO_ERR) {
      /* In case of modem reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      res = RIL_E_SYSTEM_ERR;
      QCRIL_LOG_ERROR( "Failed to register Call events for sups notifications, error %d", res );
      break;
    }
  }while(0);

  if( res != RIL_E_SUCCESS )
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, res );
  }

} /* qcril_cm_supsvc_request_set_supp_svc_notification */

//===========================================================================
// qcril_qmi_voice_request_last_call_fail_cause / RIL_REQUEST_LAST_CALL_FAIL_CAUSE
//===========================================================================
void qcril_qmi_voice_request_last_call_fail_cause
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type reqlist_entry;
  IxErrnoType reqlist_status;

  QCRIL_NOTUSED( ret_ptr );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_NONE, NULL, &reqlist_entry );
  if ( (reqlist_status = qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry )) != E_SUCCESS )
  {
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                               params_ptr->t, params_ptr->event_id,
                                               qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status));
  }
  else
  {
    qcril_qmi_voice_set_last_call_fail_request_timeout();

    qcril_qmi_voice_voip_lock_overview();
    qcril_qmi_voice_respond_ril_last_call_failure_request();
    qcril_qmi_voice_voip_unlock_overview();
  }
} // qcril_qmi_voice_request_last_call_fail_cause


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_call_forward

===========================================================================*/
/*!
    @brief
    Handles Set call forwaring Requests.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_call_forward
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{

  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  qcril_qmi_voice_callforwd_info_param_u_type *in_data_ptr;
  ims_CallForwardInfoList *ims_in_data_ptr;
  qcril_reqlist_public_type reqlist_entry;
  voice_set_sups_service_req_msg_v02 set_sups_cfw_req;
  int cf_num_len=0,return_back=0;
  int  status;
  int  reason;
  int  service_class;
  int  toa;
  char *number;
  int  no_reply_timer;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    if (QCRIL_EVT_RIL_REQUEST_SET_CALL_FORWARD == params_ptr->event_id)
    {
        in_data_ptr = (qcril_qmi_voice_callforwd_info_param_u_type *)params_ptr->data;
        status = in_data_ptr->status;
        reason = in_data_ptr->reason;
        service_class = in_data_ptr->service_class;
        toa = in_data_ptr->toa;
        number = in_data_ptr->number;
        no_reply_timer = in_data_ptr->no_reply_timer;
    }
    else
    {
        ims_in_data_ptr = (ims_CallForwardInfoList *)params_ptr->data;
        if(( NULL == ims_in_data_ptr->info.arg ) ||
                NULL == ((ims_CallForwardInfoList_CallForwardInfo**)ims_in_data_ptr->info.arg)[0])
        {
           ril_err = RIL_E_INVALID_ARGUMENTS;
           break;
        }
        ims_CallForwardInfoList_CallForwardInfo *cfi = ((ims_CallForwardInfoList_CallForwardInfo**)
                                                         ims_in_data_ptr->info.arg)[0];

        status = cfi->status;
        reason = cfi->reason;
        service_class = cfi->service_class;
        toa = cfi->toa;
        number = (char*)cfi->number.arg;
        no_reply_timer = cfi->time_seconds;
    }

    QCRIL_LOG_DEBUG( "SET_CALL_FORWARD status = %d, reason = %d, serviceClass = %d",
                     status, reason, service_class );


    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    memset(&set_sups_cfw_req, 0, sizeof(set_sups_cfw_req));

    return_back = 0;
    switch(status)
    {
      case QCRIL_QMI_VOICE_MODE_DISABLE :
        set_sups_cfw_req.supplementary_service_info.voice_service = VOICE_SERVICE_DEACTIVATE_V02;
        break;

      case QCRIL_QMI_VOICE_MODE_ENABLE :
        set_sups_cfw_req.supplementary_service_info.voice_service = VOICE_SERVICE_ACTIVATE_V02;
        break;

      case QCRIL_QMI_VOICE_MODE_REG :
        set_sups_cfw_req.supplementary_service_info.voice_service = VOICE_SERVICE_REGISTER_V02;
        break;

      case QCRIL_QMI_VOICE_MODE_ERASURE:
        set_sups_cfw_req.supplementary_service_info.voice_service = VOICE_SERVICE_ERASE_V02;
        break;

      default:
        /* Fail to add entry to ReqList */
        QCRIL_LOG_ERROR("Invalid status req: %d", status);
        ril_err = RIL_E_INVALID_ARGUMENTS;
        return_back = 1;
    }
    if( return_back == 1 )
    {
      break;
    }

    set_sups_cfw_req.supplementary_service_info.reason =
      qcril_qmi_voice_map_ril_reason_to_qmi_cfw_reason(reason);

    if(service_class > 0)
    {
      set_sups_cfw_req.service_class =  service_class;
      set_sups_cfw_req.service_class_valid = TRUE;
    }
    else
    {
      set_sups_cfw_req.service_class_valid = FALSE;
    }
    set_sups_cfw_req.password_valid = FALSE;

    if(number != NULL)
    {
      cf_num_len = strlen(number);
    }

    if ( (number != NULL) &&
         (cf_num_len > 0) && (cf_num_len <= QMI_VOICE_NUMBER_MAX_V02) &&
         (status == (int) QCRIL_QMI_VOICE_MODE_REG) )
    {
      set_sups_cfw_req.number_valid = TRUE;

      QCRIL_LOG_DEBUG("toa=%d, cf number=%s, len=%d", toa, number, cf_num_len);
      if((toa == 145) && (number[0] != '+'))
      {
        set_sups_cfw_req.number[0] = '+';
        memcpy(&set_sups_cfw_req.number[1],number,cf_num_len);
      }
      else if((toa == 145) && (number[0] == '+'))
      {
        set_sups_cfw_req.number[0] = '+';
        memcpy(&set_sups_cfw_req.number[1],&(number[1]),cf_num_len-1);
      }
      else if((toa == 129) && (number[0] != '+'))
      {
        memcpy(set_sups_cfw_req.number,number,cf_num_len);
      }
      else
      {
        memcpy(set_sups_cfw_req.number,(number),cf_num_len);
      }
    }

    if ( ( ( reason == (int) QCRIL_QMI_VOICE_CCFC_REASON_NOREPLY ) ||
           ( reason == (int) QCRIL_QMI_VOICE_CCFC_REASON_ALLCALL ) ||
           ( reason == (int) QCRIL_QMI_VOICE_CCFC_REASON_ALLCOND ) ) &&
         ( status == (int) QCRIL_QMI_VOICE_MODE_REG ) &&
         ( no_reply_timer != 0 ) )
    {
      set_sups_cfw_req.timer_value_valid = TRUE;
      set_sups_cfw_req.timer_value = no_reply_timer;
    }
    else
    {
      set_sups_cfw_req.timer_value_valid = FALSE;
    }

    if ((params_ptr->event_id == QCRIL_EVT_IMS_SOCKET_REQ_SET_CALL_FORWARD_STATUS) &&
         (reason == (int) QCRIL_QMI_VOICE_CCFC_REASON_UNCOND))
    {
      ims_CallForwardInfoList_CallForwardInfo *cfi = ((ims_CallForwardInfoList_CallForwardInfo **)
                                                       ims_in_data_ptr->info.arg)[0];
      if (cfi->has_callFwdTimerStart)
      {
        QCRIL_LOG_DEBUG("Valid callFwdTimerStart");
        set_sups_cfw_req.call_fwd_start_time_valid = TRUE;
        qcril_qmi_ims_translate_ims_callfwdtimerinfo_to_voice_time_type(
                &cfi->callFwdTimerStart,
                &(set_sups_cfw_req.call_fwd_start_time));
      }

      if (cfi->has_callFwdTimerEnd)
      {
        QCRIL_LOG_DEBUG("Valid callFwdTimerEnd");
        set_sups_cfw_req.call_fwd_end_time_valid = TRUE;
        qcril_qmi_ims_translate_ims_callfwdtimerinfo_to_voice_time_type(
                &cfi->callFwdTimerEnd,
                &(set_sups_cfw_req.call_fwd_end_time));
      }
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE SET SUPS SERVICE REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_SET_SUPS_SERVICE_REQ_V02,
                                     &set_sups_cfw_req,
                                     sizeof(set_sups_cfw_req),
                                     sizeof(voice_set_sups_service_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }

  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err);
  }
} /* qcril_qmi_voice_request_set_call_forward() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_supp_svc

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS with Activate/Deactivate
    for CLIP, COLP, CALL Barring facilities.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_voice_request_set_supp_svc
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  int facility = 0;
  int operation = 0;
  voice_set_sups_service_req_msg_v02 set_sups_cb_req;
  qcril_reqlist_public_type reqlist_entry;
  boolean is_error = FALSE;

  /* IMS SuppSvcRequest message pointer */
  ims_SuppSvcRequest *ims_in_data_ptr = NULL;

  /*-----------------------------------------------------------------------*/

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    memset(&set_sups_cb_req, 0, sizeof(set_sups_cb_req));

    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
      qcril_send_empty_payload_request_response( instance_id,
                                                 params_ptr->t,
                                                 params_ptr->event_id,
                                                 RIL_E_GENERIC_FAILURE );
      break;
    }

    ims_in_data_ptr = ( ims_SuppSvcRequest * )params_ptr->data;

    facility = (int)qcril_qmi_voice_convert_ims_to_ril_facility_type(
        (ims_SuppSvcFacilityType)ims_in_data_ptr->facilityType);

    set_sups_cb_req.supplementary_service_info.reason = (voice_reason_enum_v02)facility;

    operation = ( int )ims_in_data_ptr->operationType;

    switch( operation )
    {
      case ims_SuppSvcOperationType_DEACTIVATE :
        set_sups_cb_req.supplementary_service_info.voice_service =
          VOICE_SERVICE_DEACTIVATE_V02;
        break;

      case ims_SuppSvcOperationType_ACTIVATE :
        set_sups_cb_req.supplementary_service_info.voice_service =
          VOICE_SERVICE_ACTIVATE_V02;
        break;

      case ims_SuppSvcOperationType_REGISTER :
        set_sups_cb_req.supplementary_service_info.voice_service =
          VOICE_SERVICE_REGISTER_V02;
        break;

      case ims_SuppSvcOperationType_ERASURE :
        set_sups_cb_req.supplementary_service_info.voice_service =
          VOICE_SERVICE_ERASE_V02;
        break;

      default:
        /* Fail to add entry to ReqList */
        QCRIL_LOG_ERROR( "Invalid Mode req : %d", operation );

        qcril_send_empty_payload_request_response( instance_id,
                                                   params_ptr->t,
                                                   params_ptr->event_id,
                                                   RIL_E_GENERIC_FAILURE );
        break;
    }

    if (is_error)
    {
      break;
    }

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         reqlist_entry.req_id );

    if (ims_in_data_ptr->has_cbNumListType)
    {
      if (ims_in_data_ptr->cbNumListType.has_serviceClass &&
          ims_in_data_ptr->cbNumListType.serviceClass.has_service_Class)
      {
        set_sups_cb_req.service_class_valid = TRUE;
        set_sups_cb_req.service_class = ims_in_data_ptr->cbNumListType.serviceClass.service_Class;
        if (set_sups_cb_req.service_class <= 0)
        {
          set_sups_cb_req.service_class_valid = FALSE;
        }
      }

      if (ims_SuppSvcFacilityType_FACILITY_BS_MT == ims_in_data_ptr->facilityType)
      {
        size_t i;
        ims_CbNumList **cbn = (ims_CbNumList **)ims_in_data_ptr->cbNumListType.cb_num_list.arg;
        if (cbn != NULL)
        {
          set_sups_cb_req.call_barring_numbers_list_valid = TRUE;
          for (i=0; i<QMI_VOICE_MAX_BARRED_NUMBERS_LIST_V02 && cbn[i]; i++)
          {
            strlcpy( set_sups_cb_req.call_barring_numbers_list[i].barred_number,
                (char*)cbn[i]->number.arg,
                sizeof(set_sups_cb_req.call_barring_numbers_list[i].barred_number) );
            set_sups_cb_req.call_barring_numbers_list_len++;
          }
        }
      }
    }
    QCRIL_LOG_DEBUG("service_class (%s): %d",
        set_sups_cb_req.service_class_valid ? "valid" : "not valid",
        set_sups_cb_req.service_class);

    /* Send QMI VOICE SET SUPS SERVICE REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_SET_SUPS_SERVICE_REQ_V02,
                                     &set_sups_cb_req,
                                     sizeof(set_sups_cb_req),
                                     sizeof(voice_set_sups_service_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of modem reset, the command callback will never be executed. So, need to
      delete the entry from the ReqList, and call OnRequestComplete() */
      QCRIL_LOG_ERROR( "Send msg async error " );
      qcril_send_empty_payload_request_response( instance_id,
                                                 params_ptr->t,
                                                 params_ptr->event_id,
                                                 RIL_E_GENERIC_FAILURE );
    }
  }while(0);

  QCRIL_LOG_FUNC_RETURN();

} /* qcril_qmi_voice_request_set_supp_svc */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_facility_lock

===========================================================================*/
/*!
    @brief
    Handles Set call barring request.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_facility_lock
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  const char **in_data = (const char **)params_ptr->data;
  const char *facility_string = NULL;
  const char *facility_status = NULL;
  const char *facility_password = NULL;
  const char *facility_class = NULL;
  int facility, status, service_class,return_back = 0;
  char facility_name[ 3 ];
  voice_set_sups_service_req_msg_v02 set_sups_cb_req;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;


  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    memset(&set_sups_cb_req, 0, sizeof(set_sups_cb_req));

    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    facility_string = in_data[ 0 ];
    facility_status = in_data[ 1 ];
    facility_password = in_data[ 2 ];
    facility_class = in_data [ 3 ];
    if ( facility_string == NULL || facility_status == NULL)
    {
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    facility = qcril_qmi_voice_get_facility_value(facility_string, &facility_name[0]);

    QCRIL_LOG_DEBUG("Facility %s, %s, Facility type = %02x, Facility pw %s", facility_name,
                    ((*facility_status == '0') ? "unlock" : "lock"), facility,
                    (facility_password ? facility_password : "<not set>"));

    if (facility == (int)QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED) {
      /* Call event handler of QCRIL_MMGSDI which will take care of handling and
         sending the response back to RIL */
      QCRIL_LOG_ERROR( "TODO Unsupported facility in set facility lock = %s", facility_name );
      ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

  if ( facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_SC ||
          facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_FD )
  {
    SetFacilityLockCallback cb(instance_id, params_ptr->t, params_ptr->event_id, "voiceSetFacilityLock");
    UimSetFacilityLockRequestMsg::facility_lock_type type =
          (facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_SC) ?
          UimSetFacilityLockRequestMsg::PIN1 : UimSetFacilityLockRequestMsg::FDN;
    auto msg = std::make_shared<UimSetFacilityLockRequestMsg>((char**)params_ptr->data, type, &cb);
    if (msg == nullptr)
    {
      ril_err = RIL_E_NO_MEMORY;
    }
    else
    {
      Dispatcher::getInstance().dispatch(msg);
    }
    break;
  }

  set_sups_cb_req.supplementary_service_info.reason = (voice_reason_enum_v02)facility;

  if( facility_class != NULL )
  {
    QCRIL_LOG_DEBUG( "class = %s facility = %d", facility_class, facility );
  }

  status = ( ( *facility_status == '0') ? FALSE: ( *facility_status == '1' ) ? TRUE : 2 );

    return_back = 0;
  switch(status)
  {
    case QCRIL_QMI_VOICE_MODE_DISABLE :
      set_sups_cb_req.supplementary_service_info.voice_service = VOICE_SERVICE_DEACTIVATE_V02;
      break;

    case QCRIL_QMI_VOICE_MODE_ENABLE :
      set_sups_cb_req.supplementary_service_info.voice_service = VOICE_SERVICE_ACTIVATE_V02;
      break;

    default:
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Invalid Mode req : %d",status);
      ril_err = RIL_E_INVALID_ARGUMENTS;
        return_back = 1;
  }
    if( return_back == 1 )
    {
      break;
    }

  service_class = 0;
  if( facility_class != NULL )
  {
    service_class = atoi( facility_class );
  }

  if(service_class > 0)
  {
  set_sups_cb_req.service_class =  service_class;
  set_sups_cb_req.service_class_valid = TRUE;
  }
  else
  {
    set_sups_cb_req.service_class_valid = FALSE;
  }
  if ( facility_password != NULL )
  {
    set_sups_cb_req.password_valid = TRUE;
    memcpy( set_sups_cb_req.password, facility_password, strlen(facility_password) );
  }

  set_sups_cb_req.timer_value_valid = FALSE;
  set_sups_cb_req.number_valid = FALSE;


  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                               QCRIL_EVT_NONE, NULL, &reqlist_entry );
  if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    QCRIL_LOG_ERROR("Failed to Add into Req list");
    ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

  /* Send QMI VOICE SET SUPS SERVICE REQ */
  if (qmi_client_voice_send_async(QMI_VOICE_SET_SUPS_SERVICE_REQ_V02,
                                   &set_sups_cb_req,
                                   sizeof(set_sups_cb_req),
                                   sizeof(voice_set_sups_service_resp_msg_v02),
                                   qcril_qmi_voice_command_cb,
                                   (void*)(uintptr_t)user_data) != QMI_NO_ERR )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
     delete the entry from the ReqList, and call OnRequestComplete() */
    ril_err = RIL_E_SYSTEM_ERR;
    break;
  }
} while(0);

 if(ril_err != RIL_E_SUCCESS)
 {
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
  qcril_send_request_response( &resp );
 }

} /* qcril_qmi_voice_request_set_facility_lock() */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_call_waiting

===========================================================================*/
/*!
    @brief
    Handles Set call waiting request.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_call_waiting
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  int *in_data_ptr;
  ims_CallWaitingInfo *ims_in_data_ptr;
  unsigned int in_data_len;
  int  status, service_class, return_back = 0;
  qcril_reqlist_public_type reqlist_entry;
  voice_set_sups_service_req_msg_v02 set_sups_cw_req;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  in_data_len = params_ptr->datalen;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    if (QCRIL_EVT_RIL_REQUEST_SET_CALL_WAITING == params_ptr->event_id)
    {
      in_data_ptr = (int *)params_ptr->data;
      status = in_data_ptr[0];
      service_class = in_data_ptr[ 1 ];
      QCRIL_LOG_INFO( "RIL_REQUEST_SET_CALL_WAITING status = %d, service_class = %d", status, service_class );
    }
    else
    {
      ims_in_data_ptr = (ims_CallWaitingInfo *)params_ptr->data;
      status = ims_in_data_ptr->service_status;
      if (ims_in_data_ptr->has_service_class && ims_in_data_ptr->service_class.has_service_Class)
      {
        service_class = ims_in_data_ptr->service_class.service_Class;
      }
      else
      {
        QCRIL_LOG_DEBUG("no service class in request");
        service_class = 0;
      }
      QCRIL_LOG_INFO( "IMS_REQUEST_SET_CALL_WAITING status = %d, service_class = %d", status, service_class );
    }

    memset(&set_sups_cw_req, 0, sizeof(set_sups_cw_req));

    return_back = 0;
    switch(status)
    {
      case QCRIL_QMI_VOICE_MODE_DISABLE :
        set_sups_cw_req.supplementary_service_info.voice_service = VOICE_SERVICE_DEACTIVATE_V02;
        break;

      case QCRIL_QMI_VOICE_MODE_ENABLE :
        set_sups_cw_req.supplementary_service_info.voice_service = VOICE_SERVICE_ACTIVATE_V02;
        break;

      default:
        /* Fail to add entry to ReqList */
        QCRIL_LOG_ERROR("Invalid Mode req : %d",status);
        ril_err = RIL_E_INVALID_ARGUMENTS;
        return_back = 1;
    }
    if( return_back == 1 )
    {
      break;
    }

    set_sups_cw_req.supplementary_service_info.reason = VOICE_REASON_CALLWAITING_V02;
    if(service_class > 0)
    {
      set_sups_cw_req.service_class =  service_class;
      set_sups_cw_req.service_class_valid = TRUE;
    }
    else
    {
      set_sups_cw_req.service_class_valid = FALSE;
    }
    set_sups_cw_req.number_valid = FALSE;
    set_sups_cw_req.password_valid = FALSE;
    set_sups_cw_req.timer_value_valid = FALSE;

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE SET SUPS SERVICE REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_SET_SUPS_SERVICE_REQ_V02,
                                     &set_sups_cw_req,
                                     sizeof(set_sups_cw_req),
                                     sizeof(voice_set_sups_service_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
    }
  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
  }
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_set_call_waiting() */

/*===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CLIP.
    Queries for the status of the calling line identity presentation
    supplimentary services present with the network(for MMI code "*#30#").

    Input Paramerers:
    NULL

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of CLIP i.e whether it is active or not )
*/
/*=========================================================================*/
void qcril_qmi_voice_request_query_clip
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE GET_CLIP REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_GET_CLIP_REQ_V02,
                                     NULL,
                                     0,
                                     sizeof(voice_get_clip_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  }while(0);
  QCRIL_LOG_FUNC_RETURN();

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err);
  }
} /* qcril_qmi_voice_request_query_clip() */


/*===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS for COLP.
    Queries for the status of the Connected Line Identification Presentation.

    Input Paramerers:
    NULL

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of COLP i.e whether it is active or not )
*/
/*=========================================================================*/
static void qcril_qmi_voice_request_query_colp
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         reqlist_entry.req_id );

    /* Send QMI VOICE GET_COLP REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_GET_COLP_REQ_V02,
                                     NULL,
                                     0,
                                     sizeof(voice_get_colp_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR)
    {
      /* In case of modem reset, command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_send_empty_payload_request_response( instance_id,
                                                 params_ptr->t,
                                                 params_ptr->event_id,
                                                 RIL_E_GENERIC_FAILURE );
    }
  }while(0);
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_query_colp() */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_get_clir

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_CLIR.
    Queries for the status of the calling line identity restriction.

    Input Paramerers:
    NULL

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of CLIR i.e whether it is active or not )
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_get_clir
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE DIAL CALL REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_GET_CLIR_REQ_V02,
                                     NULL,
                                     0,
                                     sizeof(voice_get_clir_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
          delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err);
  }
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_get_clir() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_query_call_waiting

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CALL_WAITING.
    Queries for the status of the call waiting supplimentary services present
    with the network.

    Input Paramerers:
    const int *
    ((const int *)data)[0] is the TS 27.007 service class to query

    though service class is provided as input, it is not required for this SS.

    @return:
    None ( after receiving the appropriate response from AMSS,
           returns the basic service groups list for which call waiting is active )

*/
/*=========================================================================*/
void qcril_qmi_voice_request_query_call_waiting
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  int service_class;
  ims_ServiceClass *ims_data_ptr;
  qcril_reqlist_public_type reqlist_entry;
  voice_get_call_waiting_req_msg_v02 get_cw_req;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if (QCRIL_EVT_RIL_REQUEST_QUERY_CALL_WAITING == params_ptr->event_id)
    {
      service_class = ((int *) params_ptr->data)[ 0 ];
    }
    else
    {
      ims_data_ptr = (ims_ServiceClass*) params_ptr->data;
      service_class = ims_data_ptr->service_Class;
    }
    /* Though we are checking for service class it is ignored in case of invalid
       class here as service class is not required for interrogation, only if
       status is received in resonse then we use service class */
    QCRIL_LOG_DEBUG( "Received service class = %d", service_class );

    memset(&get_cw_req,0,sizeof(get_cw_req));

    if(service_class > 0)
    {
      get_cw_req.service_class =  service_class;
      get_cw_req.service_class_valid = TRUE;
    }
    else
    {
      get_cw_req.service_class_valid = FALSE;
    }

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE DIAL CALL REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_GET_CALL_WAITING_REQ_V02,
                                     &get_cw_req,
                                     sizeof(get_cw_req),
                                     sizeof(voice_get_call_waiting_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
    }
  }while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err);
  }
} /* qcril_qmi_voice_request_query_call_waiting() */


/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_change_barring_password

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CHANGE_BARRING_PASSWORD.
    changes the call barrring password which is registered with the network
    and which is required for activation or deactivation of call barring SS

    input Paramerers:

    const char **
    ((const char **)data)[0] = facility  string code from TS 27.007 7.4
    ((const char **)data)[1] = old password
    ((const char **)data)[1] = new password

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_change_barring_password
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  const char **in_data = (const char **)params_ptr->data;
  unsigned int in_data_len = params_ptr->datalen;
  int facility;
  char facility_name[3] = "";
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_set_call_barring_password_req_msg_v02 change_cb_pwd_req;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL || in_data[0] == NULL || in_data[1] == NULL || in_data[2] == NULL)
    {
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

  memset(&change_cb_pwd_req,0,sizeof(change_cb_pwd_req));
  facility = qcril_qmi_voice_get_facility_value( in_data[ 0 ], &facility_name[ 0 ] );

  QCRIL_LOG_DEBUG( "RIL_REQUEST_CHANGE_BARRING_PASSWORD Facility %s (%d), old_pw %s, new_pw %s",
                   facility_name, facility, in_data[1], in_data[2] );

  if ( (facility == QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED ) || (in_data_len == 0))
  {
    QCRIL_LOG_ERROR( "received invalid parameters in RIL_REQUEST_CHANGE_BARRING_PASSWORD");
    ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
  }
  else
  {
    change_cb_pwd_req.call_barring_password_info.reason = (voice_reason_enum_v02)facility;
    /* filling the password information as accepted by QMI_VOICE svc*/
    memcpy(change_cb_pwd_req.call_barring_password_info.old_password,
           in_data[1],
           sizeof(char)* strlen(in_data[1]));

    memcpy(change_cb_pwd_req.call_barring_password_info.new_password,
           in_data[2],
           sizeof(char)* strlen(in_data[2]));

    memcpy(change_cb_pwd_req.call_barring_password_info.new_password_again,
           in_data[2],
           sizeof(char)* strlen(in_data[2]));

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE, NULL, &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
        break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

    /* Send QMI VOICE DIAL CALL REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_SET_CALL_BARRING_PASSWORD_REQ_V02,
                                     &change_cb_pwd_req,
                                     sizeof(change_cb_pwd_req),
                                     sizeof(voice_set_call_barring_password_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
          delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }

  }
  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_qmi_voice_request_change_barring_password() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_query_facility_lock

===========================================================================*/
/*!
    @brief
    Handles
      1.  RIL_REQUEST_QUERY_FACILITY_LOCK
      2.  QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS for
          ims_SuppSvcOperationType_QUERY operation with
          Call Barring facility types.

    Queries for the status of the call barring supplimentary services present
    with the network.

    Input Paramerers:
    When RIL_REQUEST_QUERY_FACILITY_LOCK:
       const char **
        ((const char **)data)[0] is the facility string code from TS 27.007 7.4.
        ((const char **)data)[1] is the password.
        ((const char **)data)[2] is the TS 27.007 service class bit vector of services to query
          ((const char **)data)[3] is the AID (applies only in case of FDN, or "" otherwise)

    When QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS:
       (ims_SuppSvcRequest *)params_ptr->data

    though service class is provided as input, it is not required for call barring SS.

    Result:
    None ( after receiving the appropriate response from AMSS,
              returns the basic service groups list for which call waiting is active )

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_query_facility_lock
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  const char **in_data = (const char **) params_ptr->data;
  const char *facility_string = NULL;
  const char *facility_password = NULL;
  const char *facility_class = NULL;
  int facility = (int) QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED;
  int service_class = 0;
  unsigned int in_data_len = params_ptr->datalen;
  char facility_name[ 3 ] = {0};
  qcril_reqlist_public_type reqlist_entry;
  voice_get_call_barring_req_msg_v02 get_cb_req;

  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /* IMS SUppSvcRequest message pointer */
  ims_SuppSvcRequest *ims_in_data_ptr = NULL;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
      QCRIL_LOG_ERROR("data is null");
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    memset(&get_cb_req,0,sizeof(get_cb_req));

    if ( QCRIL_EVT_RIL_REQUEST_QUERY_FACILITY_LOCK == params_ptr->event_id )
    {
      facility_string = in_data[ 0 ];
      facility_password = in_data[ 1 ];
      facility_class = in_data [ 2 ];
      if ( facility_string == NULL)
      {
        QCRIL_LOG_ERROR("string is null");
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
      }
      facility = qcril_qmi_voice_get_facility_value( facility_string, &facility_name[ 0 ] );
    }
    else /* QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS */
    {
      ims_in_data_ptr = (ims_SuppSvcRequest *)params_ptr->data;
      facility = (int)qcril_qmi_voice_convert_ims_to_ril_facility_type(
          (ims_SuppSvcFacilityType)ims_in_data_ptr->facilityType);
    }

    service_class = 0;
    if( facility_class != NULL )
    {
      service_class = atoi( facility_class );
    }
    else if ( ims_in_data_ptr &&
              ims_in_data_ptr->has_cbNumListType &&
              ims_in_data_ptr->cbNumListType.has_serviceClass &&
              ims_in_data_ptr->cbNumListType.serviceClass.has_service_Class &&
              ims_in_data_ptr->cbNumListType.serviceClass.service_Class )
    {
      service_class = ims_in_data_ptr->cbNumListType.serviceClass.service_Class;
    }

    QCRIL_LOG_DEBUG("Facility %s, service_class %d, Facility type = %02x, Facility pw %s",
                    facility_name, service_class, facility,
                    (facility_password ? facility_password : "<not set>"));

    if ((facility == QCRIL_QMI_VOICE_FACILITY_UNSUPPORTED) || (in_data_len == 0))
    {
      QCRIL_LOG_ERROR("Received invalid parameters");
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    if ( facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_SC ||
            facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_FD )
    {
      GetFacilityLockCallback cb(instance_id, params_ptr->t, params_ptr->event_id, "voiceGetFacilityLock");
      UimGetFacilityLockRequestMsg::facility_lock_type type =
            (facility == (int) QCRIL_QMI_VOICE_FACILITY_LOCK_SC) ?
            UimGetFacilityLockRequestMsg::PIN1 : UimGetFacilityLockRequestMsg::FDN;
      auto msg = std::make_shared<UimGetFacilityLockRequestMsg>((char**)params_ptr->data, type, &cb);
      if (msg == nullptr)
      {
        ril_err = RIL_E_NO_MEMORY;
      }
      else
      {
        Dispatcher::getInstance().dispatch(msg);
      }
      break;
    }

    get_cb_req.reason = (voice_reason_enum_v02)facility;

    if ( service_class == 0 )
    {
      get_cb_req.service_class_valid = FALSE;
    }
    else
    {
      get_cb_req.service_class = service_class;
      get_cb_req.service_class_valid = TRUE;
    }

    /* Add entry to ReqList */
    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );
    if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR( "Failed to Add into Req list" );
      ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         reqlist_entry.req_id );

    /* Send QMI VOICE GET CALL BARRING REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_GET_CALL_BARRING_REQ_V02,
                                     &get_cb_req,
                                     sizeof(get_cb_req),
                                     sizeof(voice_get_call_barring_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  }while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
  }
} /* qcril_qmi_voice_request_query_facility_lock() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_set_clir

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_CLIR.

    Sets the default CLIR value (i_ptr->clir) as per the received input(n value).

    If RIL_REQUEST_DIAL does not specify valid CLIR parameter, use the default
    clir value.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_clir
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  int *in_data_ptr;
  ims_Clir *ims_in_data_ptr;
  uint8  clir_n_param;
  char args[ PROPERTY_VALUE_MAX ];
  char property_name[ PROPERTY_NAME_MAX ];
  RIL_Errno ril_err = RIL_E_SUCCESS;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }

    if (QCRIL_EVT_RIL_REQUEST_SET_CLIR == params_ptr->event_id)
    {
      in_data_ptr = (int *)params_ptr->data;
      clir_n_param = (uint8) in_data_ptr[0]; /* 27.007, section 7.8 */
    }
    else
    {
      ims_in_data_ptr = (ims_Clir *)params_ptr->data;
      clir_n_param = (uint8) ims_in_data_ptr->param_n; /* 27.007, section 7.8 */
    }

    QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_CLIR input = %d", clir_n_param);

    if ( ( clir_n_param == (uint8) QCRIL_QMI_VOICE_SS_CLIR_PRESENTATION_INDICATOR ) ||
         ( clir_n_param == (uint8) QCRIL_QMI_VOICE_SS_CLIR_INVOCATION_OPTION ) ||
         ( clir_n_param == (uint8) QCRIL_QMI_VOICE_SS_CLIR_SUPPRESSION_OPTION ) )
    {
      qcril_qmi_voice_info.clir = clir_n_param;

      /* Save CLIR setting to system property */
      QCRIL_SNPRINTF( args, sizeof(args), "%d", (int) qcril_qmi_voice_info.clir );

      QCRIL_SNPRINTF( property_name, sizeof(property_name), "%s%d",
                      QCRIL_QMI_VOICE_CLIR, qmi_ril_get_process_instance_id() );
      if ( property_set( property_name, args ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Fail to save %s to system property", property_name );
      }
      QCRIL_LOG_DEBUG( "SET CLIR=%d", qcril_qmi_voice_info.clir );

      /* sending confirmation as we just need to store the request,
         and use it only when call is initiated */
      qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS );
    }
    else
    {
      QCRIL_LOG_ERROR("received invalid params in RIL_REQUEST_SET_CLIR");
      ril_err = RIL_E_INVALID_ARGUMENTS;
    }
  }while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
  }
  QCRIL_LOG_FUNC_RETURN();

} /* qcril_qmi_voice_request_set_clir() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_query_call_forward_status

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CALL_FORWARD_STATUS.

    Queries for the status of the calling forwarding supplimentary services
    present with the network.

    Input Paramerers:
    int *.
    ((int *)data)[0] is "reason" from TS 27.007 7.11

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of call forwarding supplimentary services )
*/
/*=========================================================================*/
void qcril_qmi_voice_request_query_call_forward_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  RIL_CallForwardInfo *info = NULL;
  ims_CallForwardInfoList* ims_info = NULL;
  int reason;
  int service_class;
  qcril_reqlist_public_type reqlist_entry;
  voice_get_call_forwarding_req_msg_v02 query_cf_req;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/
  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );
  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
      if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
      {
          ril_err = RIL_E_INVALID_ARGUMENTS;
          break;
      }

      if (QCRIL_EVT_RIL_REQUEST_QUERY_CALL_FORWARD_STATUS == params_ptr->event_id)
      {
         info = ( RIL_CallForwardInfo * )( params_ptr->data );
         reason = info->reason;
         service_class = info->serviceClass;
      }
      else
      {
         // translate
         ims_info = (ims_CallForwardInfoList*)( params_ptr->data );
         if( ( NULL == ims_info->info.arg ) ||
             ( NULL == ((ims_CallForwardInfoList_CallForwardInfo**)ims_info->info.arg)[0] ))
         {
           ril_err = RIL_E_INVALID_ARGUMENTS;
           break;
         }
         reason = ((ims_CallForwardInfoList_CallForwardInfo**)ims_info->info.arg)[0]->reason;
         service_class = ((ims_CallForwardInfoList_CallForwardInfo**)
                 ims_info->info.arg)[0]->service_class;
      }

      memset(&query_cf_req,0,sizeof(query_cf_req));

      if ( !( ( reason >= (int) QCRIL_QMI_VOICE_CCFC_REASON_UNCOND ) && ( reason < (int) QCRIL_QMI_VOICE_CCFC_REASON_MAX ) ) )
      {
        QCRIL_LOG_ERROR( "received invalid reason in RIL_REQUEST_QUERY_CALL_FORWARD_STATUS" );
        ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
      }

      query_cf_req.reason = qcril_qmi_voice_map_ril_reason_to_qmi_cfw_reason(reason);

      if ( service_class <= 0 )
      {
        query_cf_req.service_class_valid = FALSE;
      }
      else
      {
        query_cf_req.service_class = service_class;
        query_cf_req.service_class_valid = TRUE;
      }

      /* Add entry to ReqList */
      qcril_reqlist_default_entry(params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID,
          QCRIL_REQ_AWAITING_CALLBACK, QCRIL_EVT_NONE, NULL, &reqlist_entry );
      reqlist_entry.req_datalen = sizeof (reason);
      reqlist_entry.req_data = (void *)&reason;
      if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
      {
        /* Fail to add entry to ReqList */
        QCRIL_LOG_ERROR("Failed to Add into Req list");
        ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
        break;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

      /* Send QMI VOICE DIAL CALL REQ */
      if (qmi_client_voice_send_async(QMI_VOICE_GET_CALL_FORWARDING_REQ_V02,
                                       &query_cf_req,
                                       sizeof(query_cf_req),
                                       sizeof(voice_get_call_forwarding_resp_msg_v02),
                                       qcril_qmi_voice_command_cb,
                                       (void*)(uintptr_t)user_data) != QMI_NO_ERR )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
        ril_err = RIL_E_SYSTEM_ERR;
      }
  } while ( FALSE );
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_err );
  }
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_query_call_forward_status() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_send_ussd

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SEND_USSD.
    Used to send MO USSD request or send response for MT USSD request

    Input:
    const char * containing the USSD request in UTF-8 format

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_supsvc_request_send_ussd
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  uint32 user_data;
  const char * rcvd_ussd_str = (const char *) params_ptr->data; /* received ussd string */
  char ussd_str[ QCRIL_QMI_VOICE_MAX_USS_CHAR ];
  int ussd_str_len = 0;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_answer_ussd_req_msg_v02 answer_ussd_req;
  voice_orig_ussd_req_msg_v02 orig_ussd_req;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
    if ( ( params_ptr->data == NULL ) || ( params_ptr->datalen == 0 ) )
    {
      QCRIL_LOG_ERROR( "received RIL_REQUEST_SEND_USSD with USSD message set to NULL" );
      ril_err = RIL_E_INVALID_ARGUMENTS;
      break;
    }

  QCRIL_LOG_DEBUG( "RIL_REQUEST_SEND_USSD input = Request Recived");

  memset(&orig_ussd_req,0,sizeof(orig_ussd_req));
  memset(&answer_ussd_req,0,sizeof(answer_ussd_req));


  memset( ussd_str, 0, QCRIL_QMI_VOICE_MAX_USS_CHAR );

  QCRIL_LOG_DEBUG( "USSD string in UTF8 format = %s length = %d\n", rcvd_ussd_str, strlen( rcvd_ussd_str ) );

  if ( qcril_cm_ss_UssdStringIsAscii( rcvd_ussd_str ) )
  {
    ussd_str_len = strlen( rcvd_ussd_str );
    QCRIL_LOG_DEBUG( "Recieved USSD string is in ASCII format = %s",rcvd_ussd_str );
    if ( ussd_str_len > QCRIL_QMI_VOICE_MAX_USS_CHAR )
    {
      QCRIL_LOG_DEBUG( "Received USSD charecters exceed maximum length" );
      ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }
    memcpy(ussd_str,rcvd_ussd_str,ussd_str_len);
    orig_ussd_req.uss_info.uss_dcs = USS_DCS_ASCII_V02;
    answer_ussd_req.uss_info.uss_dcs = USS_DCS_ASCII_V02;
  }
  else
  {
    QCRIL_LOG_DEBUG( "Recieved USSD string is not in Ascii format = %s",rcvd_ussd_str );
    ussd_str_len = qcril_cm_ss_convert_utf8_to_ucs2( rcvd_ussd_str,
            strlen(rcvd_ussd_str),
            ussd_str,
            sizeof(ussd_str) );
    if ( ussd_str_len == 0 || ussd_str_len > QCRIL_QMI_VOICE_MAX_USS_CHAR )
    {
      QCRIL_LOG_DEBUG( "Illegal UTF8 characters received, length = %d", ussd_str_len );
      ril_err = RIL_E_INVALID_ARGUMENTS;
        break;
    }
    orig_ussd_req.uss_info.uss_dcs = USS_DCS_UCS2_V02;
    answer_ussd_req.uss_info.uss_dcs = USS_DCS_UCS2_V02;
  }

  orig_ussd_req.uss_info.uss_data_len = ussd_str_len;
  answer_ussd_req.uss_info.uss_data_len = ussd_str_len;
  memcpy(orig_ussd_req.uss_info.uss_data,ussd_str,ussd_str_len);
  memcpy(answer_ussd_req.uss_info.uss_data,ussd_str,ussd_str_len);

  QCRIL_LOG_DEBUG( "USSD string after conversion = %s length = %d", rcvd_ussd_str, strlen( rcvd_ussd_str ) );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                               QCRIL_EVT_NONE, NULL, &reqlist_entry );
  if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    QCRIL_LOG_ERROR("Failed to Add into Req list");
    ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

  /* case where RIL is responding for MT USSD request */
  QCRIL_LOG_INFO("USSD User Action Required = %d",qcril_qmi_voice_info.ussd_user_action_required);
  if ( qcril_qmi_voice_info.ussd_user_action_required == FALSE )
  {
    /* Send QMI VOICE ORIG USSD REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_ORIG_USSD_REQ_V02,
                                     &orig_ussd_req,
                                     sizeof(orig_ussd_req),
                                     sizeof(voice_orig_ussd_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      break;
    }
  }
  else /* case where RIL is initiating an MO USSD request */
  {
    /* Send QMI VOICE ANSWER USSD REQ */
    if (qmi_client_voice_send_async(QMI_VOICE_ANSWER_USSD_REQ_V02,
                                     &answer_ussd_req,
                                     sizeof(answer_ussd_req),
                                     sizeof(voice_answer_ussd_resp_msg_v02),
                                     qcril_qmi_voice_command_cb,
                                     (void*)(uintptr_t)user_data) != QMI_NO_ERR )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
      ril_err = RIL_E_SYSTEM_ERR;
      qcril_qmi_voice_info.ussd_user_action_required = FALSE;
    }
  }
  }while(0);
  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t,
                          params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_qmi_voice_supsvc_request_send_ussd() */

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_supsvc_request_cancel_ussd

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CANCEL_USSD.
    Used for cancelling/releasing the ongoing USSD session

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_supsvc_request_cancel_ussd
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;
  qcril_reqlist_public_type reqlist_entry;
  uint32 user_data;
  RIL_Errno ril_err = RIL_E_SUCCESS;
  IxErrnoType reqlist_status;

  /*-----------------------------------------------------------------------*/


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  /*-----------------------------------------------------------------------*/

  do
  {
  QCRIL_LOG_DEBUG( "RIL_REQUEST_CANCEL_USSD input = Request Recived");


  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_AWAITING_CALLBACK,
                               QCRIL_EVT_NONE, NULL, &reqlist_entry );
  if ( (reqlist_status = qcril_reqlist_new( instance_id, &reqlist_entry )) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    QCRIL_LOG_ERROR("Failed to Add into Req list");
    ril_err = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
      break;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

  /* Send QMI VOICE CANCEL USSD REQ */
  if (qmi_client_voice_send_async(QMI_VOICE_CANCEL_USSD_REQ_V02,
                                   NULL,
                                   0,
                                   sizeof(voice_cancel_ussd_resp_msg_v02),
                                   qcril_qmi_voice_command_cb,
                                   (void*)(uintptr_t)user_data) != QMI_NO_ERR )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
     delete the entry from the ReqList, and call OnRequestComplete() */
    ril_err = RIL_E_SYSTEM_ERR;
    break;
  }
  }while(0);

  if(ril_err != RIL_E_SUCCESS)
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_qmi_voice_supsvc_request_cancel_ussd() */

//===========================================================================
// ****************************** STK CC ***********************************
//===========================================================================

//===========================================================================
// qcril_qmi_voice_is_stk_cc_in_progress
//===========================================================================
int qcril_qmi_voice_is_stk_cc_in_progress(void)
{
  return ( QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE == stk_cc_info.modification ) ? FALSE : TRUE;
} // qcril_qmi_voice_is_stk_cc_in_progress

//===========================================================================
// qcril_qmi_voice_is_stk_cc_in_progress
//===========================================================================
void qcril_qmi_voice_reset_stk_cc(void)
{
  stk_cc_info.modification = QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE;
  stk_cc_info.is_alpha_relayed = FALSE;
  stk_cc_info.is_ims_request = FALSE;
  stk_cc_info.call_id_info = QCRIL_QMI_VOICE_UNKNOWN_ACTIVE_CONN_ID;
} // qcril_qmi_voice_reset_stk_cc

//===========================================================================
// qcril_qmi_voice_stk_cc_relay_alpha_if_necessary
//===========================================================================
void qcril_qmi_voice_stk_cc_relay_alpha_if_necessary(qcril_instance_id_e_type instance_id, boolean send_unsol_unconditional)
{
  char buf_str[QMI_VOICE_ALPHA_TEXT_MAX_V02 + 2];
  qcril_unsol_resp_params_type unsol_resp;

  memset(buf_str, 0 , QMI_VOICE_ALPHA_TEXT_MAX_V02 + 2);

  QCRIL_LOG_DEBUG("instance_id = %d, send unsol unconditional = %d", instance_id, send_unsol_unconditional);

  if ( ( qcril_qmi_voice_is_stk_cc_in_progress() && !stk_cc_info.is_alpha_relayed ) ||
       ( send_unsol_unconditional ) )
  {
    if ( stk_cc_info.alpha_ident.alpha_text_len > 0 )
    {
      switch ( stk_cc_info.alpha_ident.alpha_dcs )
      {
        case ALPHA_DCS_GSM_V02:
           if(stk_cc_info.alpha_ident.alpha_text_len < QMI_VOICE_ALPHA_TEXT_MAX_V02)
               qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (char*) stk_cc_info.alpha_ident.alpha_text,
                                                                stk_cc_info.alpha_ident.alpha_text_len,
                                                                buf_str,
                                                                sizeof(buf_str));
          break;

        case ALPHA_DCS_UCS2_V02:
          qcril_cm_ss_convert_ucs2_to_utf8( (char *) stk_cc_info.alpha_ident.alpha_text,
                                                            stk_cc_info.alpha_ident.alpha_text_len * 2,
                                                            buf_str,
                                                            sizeof(buf_str));
          break;

        default:
          buf_str[0] = 0;
          break;
      }

      if ( *buf_str )
      {
        qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_STK_CC_ALPHA_NOTIFY, &unsol_resp );
        unsol_resp.resp_pkt    = (void*)buf_str;
        unsol_resp.resp_len    = sizeof( char* );

        qcril_send_unsol_response( &unsol_resp );
      }

      // RIL_UNSOL_STK_CC_ALPHA_NOTIFY
      stk_cc_info.is_alpha_relayed = TRUE;
    }
  }
} // qcril_qmi_voice_stk_cc_relay_alpha_if_necessary

//===========================================================================
// qcril_qmi_voice_map_qmi_ss_service_type_to_ril_ss_request_type
//===========================================================================
boolean qcril_qmi_voice_map_qmi_ss_service_type_to_ril_ss_request_type
(
 service_type_enum_v02 qmi_type,
 RIL_SsRequestType *ril_type
)
{
  boolean result = FALSE;

  if (ril_type)
  {
    result = TRUE;
    switch (qmi_type)
    {
      case VOICE_CC_SUPS_RESULT_SERVICE_TYPE_ACTIVATE_V02:
        *ril_type = SS_ACTIVATION;
        break;

      case VOICE_CC_SUPS_RESULT_SERVICE_TYPE_DEACTIVATE_V02:
        *ril_type = SS_DEACTIVATION;
        break;

      case VOICE_CC_SUPS_RESULT_SERVICE_TYPE_REGISTER_V02:
        *ril_type = SS_REGISTRATION;
        break;

      case VOICE_CC_SUPS_RESULT_SERVICE_TYPE_ERASE_V02:
        *ril_type = SS_ERASURE;
        break;

      case VOICE_CC_SUPS_RESULT_SERVICE_TYPE_INTERROGATE_V02:
        *ril_type = SS_INTERROGATION;
        break;

        // qmi_todo: why VOICE_CC_SUPS_RESULT_SERVICE_TYPE_REGISTER_PASSWORD_V02 ??
      default:
        result = FALSE;
        *ril_type = SS_ERASURE; // some default value as we may refer to this value for logging
        break;
    }
  }
  return result;
}

//===========================================================================
// qcril_qmi_voice_map_qmi_ss_reason_to_ril_ss_service_type
//===========================================================================
boolean qcril_qmi_voice_map_qmi_ss_reason_to_ril_ss_service_type
(
 voice_sups_ind_reason_enum_v02 qmi_reason,
 int *ril_type
)
{
  boolean result = FALSE;

  if (ril_type)
  {
    result = TRUE;
    switch (qmi_reason)
    {
      case VOICE_SUPS_IND_REASON_FWD_UNCONDITIONAL_V02:
        *ril_type = SS_CFU;
        break;

      case VOICE_SUPS_IND_REASON_FWD_MOBILEBUSY_V02:
        *ril_type = SS_CF_BUSY;
        break;

      case VOICE_SUPS_IND_REASON_FWD_NOREPLY_V02:
        *ril_type = SS_CF_NO_REPLY;
        break;

      case VOICE_SUPS_IND_REASON_FWD_UNREACHABLE_V02:
        *ril_type = SS_CF_NOT_REACHABLE;
        break;

      case VOICE_SUPS_IND_REASON_FWD_ALLFORWARDING_V02:
        *ril_type = SS_CF_ALL;
        break;

      case VOICE_SUPS_IND_REASON_FWD_ALLCONDITIONAL_V02:
        *ril_type = SS_CF_ALL_CONDITIONAL;
        break;

      case VOICE_SUPS_IND_REASON_BARR_ALLOUTGOING_V02:
        *ril_type = SS_BAOC;
        break;

      case VOICE_SUPS_IND_REASON_BARR_OUTGOINGINT_V02:
        *ril_type = SS_BAOIC;
        break;

      case VOICE_SUPS_IND_REASON_BARR_OUTGOINGINTEXTOHOME_V02:
        *ril_type = SS_BAOIC_EXC_HOME;
        break;

      case VOICE_SUPS_IND_REASON_BARR_ALLINCOMING_V02:
        *ril_type = SS_BAIC;
        break;

      case VOICE_SUPS_IND_REASON_BARR_INCOMINGROAMING_V02:
        *ril_type = SS_BAIC_ROAMING;
        break;

      case VOICE_SUPS_IND_REASON_BARR_ALLBARRING_V02:
        *ril_type = SS_ALL_BARRING;
        break;

      case VOICE_SUPS_IND_REASON_BARR_ALLOUTGOINGBARRING_V02:
        *ril_type = SS_OUTGOING_BARRING;
        break;

      case VOICE_SUPS_IND_REASON_BARR_ALLINCOMINGBARRING_V02:
        *ril_type = SS_INCOMING_BARRING;
        break;

      case VOICE_SUPS_IND_REASON_CALLWAITING_V02:
        *ril_type = SS_WAIT;
        break;

      case VOICE_SUPS_IND_REASON_CLIP_V02:
        *ril_type = SS_CLIP;
        break;

      case VOICE_SUPS_IND_REASON_CLIR_V02:
        *ril_type = SS_CLIR;
        break;

      case VOICE_SUPS_IND_REASON_COLP_V02:
        *ril_type = SS_COLP;
        break;

      case VOICE_SUPS_IND_REASON_COLR_V02:
        *ril_type = SS_COLR;
        break;

      case VOICE_SUPS_IND_REASON_BARR_INCOMINGNUMBER_V02:
        *ril_type = QCRIL_SS_INCOMING_BARRING_DN;
        break;

      case VOICE_SUPS_IND_REASON_BARR_INCOMINGANONYMOUS_V02:
        *ril_type = QCRIL_SS_INCOMING_BARRING_ANONYMOUS;
        break;

      default:
        result = FALSE;
        *ril_type = SS_CFU; // some default value as we may refer to this value for logging
        break;
    }
  }

  return result;
}

//===========================================================================
// qcril_qmi_voice_stk_cc_convert_qmi_svc_class_to_ril_teleservice
//===========================================================================
RIL_SsTeleserviceType qcril_qmi_voice_stk_cc_convert_qmi_svc_class_to_ril_teleservice( uint8_t service_class )
{
  RIL_SsTeleserviceType ss_teleservice_type;

  switch ( service_class )
  {
    case QCRIL_QMI_VOICE_TELESEFRVICE_ALL:
      ss_teleservice_type = SS_ALL_TELESEVICES;
      break;

    case QCRIL_QMI_VOICE_TELESEFRVICE_TELEPHONY:
      ss_teleservice_type = SS_TELEPHONY;
      break;

    case QCRIL_QMI_VOICE_TELESEFRVICE_ALL_DATA:
      ss_teleservice_type = SS_ALL_DATA_TELESERVICES;
      break;

    case QCRIL_QMI_VOICE_TELESEFRVICE_SMS:
      ss_teleservice_type = SS_SMS_SERVICES;
      break;

    case QCRIL_QMI_VOICE_TELESEFRVICE_ALL_EXCEPT_SMS:
      ss_teleservice_type = SS_ALL_TELESERVICES_EXCEPT_SMS;
      break;

    case QCRIL_QMI_VOICE_TELESEFRVICE_ALL_BEARER_SVC:
       ss_teleservice_type = SS_ALL_TELE_AND_BEARER_SERVICES;
       break;

    default: // something that we do not support
      ss_teleservice_type = SS_ALL_TELE_AND_BEARER_SERVICES;
      break;
  }

  return ss_teleservice_type;
} // qcril_qmi_voice_stk_cc_convert_qmi_svc_class_to_ril_teleservice

//===========================================================================
// qcril_qmi_voice_convert_sups_ind_call_forwarding_info_to_ril_cfdata
//===========================================================================
boolean qcril_qmi_voice_convert_sups_ind_call_forwarding_info_to_ril_cfdata
(
 voice_sups_ind_reason_enum_v02 reason,
 voice_get_call_forwarding_info_type_v02 *qmi_cf_info,
 int qmi_cf_info_len,
 RIL_CfData *cf_data
)
{
  boolean result = FALSE;
  int     idx;
  int     ril_cf_reason = qcril_qmi_voice_map_qmi_cfw_reason_to_ril_reason(reason);

  if (cf_data != NULL)
  {
    for (idx = 0; idx < qmi_cf_info_len; idx++)
    {
      cf_data->cfInfo[idx].status =
        (qmi_cf_info[idx].service_status == QCRIL_QMI_VOICE_SERVICE_STATUS_ACTIVE) ?
        QCRIL_QMI_VOICE_RIL_CF_STATUS_ACTIVE : QCRIL_QMI_VOICE_RIL_CF_STATUS_NOT_ACTIVE;

      cf_data->cfInfo[idx].reason = ril_cf_reason;

      cf_data->cfInfo[idx].serviceClass = qmi_cf_info[idx].service_class;

      cf_data->cfInfo[idx].number = qmi_cf_info[idx].number; // 1st is char*, 2nd is char[]

      cf_data->cfInfo[idx].toa =
        (QCRIl_QMI_VOICE_SS_TA_INTER_PREFIX == *qmi_cf_info[idx].number) ?
        QCRIL_QMI_VOICE_SS_TA_INTERNATIONAL : QCRIL_QMI_VOICE_SS_TA_UNKNOWN;

      cf_data->cfInfo[idx].timeSeconds = qmi_cf_info[idx].no_reply_timer;
    }
    cf_data->numValidIndexes = qmi_cf_info_len;
    result = TRUE;
  }
  return result;
}

//===========================================================================
// qcril_qmi_voice_stk_cc_notify_unsol_on_ussd_from_sups_ind
//===========================================================================
void qcril_qmi_voice_stk_cc_notify_unsol_on_ussd_from_sups_ind
(
 voice_sups_ind_msg_v02 *sups_ind_msg
)
{
  qcril_unsol_resp_params_type unsol_resp;
  uint8   uss_dcs  = QCRIL_QMI_VOICE_USSD_DCS_UNSPECIFIED;
  boolean success  = FALSE;
  int     utf8_len = 0;
  char    ussd_utf8_str[QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2];
  char    type_code[2];
  char   *response_buff[2];

  QCRIL_LOG_FUNC_ENTRY();

  if (sups_ind_msg != NULL)
  {
    QCRIL_LOG_INFO("..sups_ind uss_info_valid: %d, uss_info_utf16_valid: %d",
        sups_ind_msg->uss_info_valid, sups_ind_msg->uss_info_utf16_valid);

    memset(ussd_utf8_str, '\0', sizeof(ussd_utf8_str));
    memset(type_code, '\0', sizeof(type_code));
    memset(response_buff, 0, sizeof(response_buff));

    // uss_info_utf16 has high priority.
    if (sups_ind_msg->uss_info_utf16_valid)
    {
      utf8_len = qcril_cm_ss_convert_ucs2_to_utf8((char *)sups_ind_msg->uss_info_utf16,
          sups_ind_msg->uss_info_utf16_len * 2, ussd_utf8_str, sizeof(ussd_utf8_str));

      if (utf8_len > (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2))
      {
        QCRIL_LOG_ERROR("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
        utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
        ussd_utf8_str[utf8_len - 1] = '\0';
      }
      success = TRUE;
    }
    else if (sups_ind_msg->uss_info_valid)
    {
      QCRIL_LOG_INFO("..sups_ind uss_dcs %d", (int) sups_ind_msg->uss_info.uss_dcs);
      switch (sups_ind_msg->uss_info.uss_dcs)
      {
        case USS_DCS_ASCII_V02 :
          utf8_len = qcril_cm_ss_ascii_to_utf8((unsigned char *)sups_ind_msg->uss_info.uss_data,
              sups_ind_msg->uss_info.uss_data_len, ussd_utf8_str, sizeof(ussd_utf8_str));
          success = TRUE;
          break;

        case USS_DCS_8BIT_V02 :
          uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_8_BIT;
          utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8(uss_dcs,
              sups_ind_msg->uss_info.uss_data, sups_ind_msg->uss_info.uss_data_len,
              ussd_utf8_str, sizeof(ussd_utf8_str));
          if (utf8_len > (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2))
          {
            QCRIL_LOG_ERROR("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
            utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
            ussd_utf8_str[utf8_len - 1] = '\0';
          }
          success = TRUE;
          break;

        case USS_DCS_UCS2_V02 :
          uss_dcs = QCRIL_QMI_VOICE_USSD_DCS_UCS2;
          utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8(uss_dcs,
              sups_ind_msg->uss_info.uss_data, sups_ind_msg->uss_info.uss_data_len,
              ussd_utf8_str, sizeof(ussd_utf8_str));
          if (utf8_len > (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR * 2))
          {
            QCRIL_LOG_ERROR("ascii_len exceeds QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR");
            utf8_len = (int) (QCRIL_QMI_VOICE_MAX_MT_USSD_CHAR*2);
            ussd_utf8_str[utf8_len - 1] = '\0';
          }
          success = TRUE;
          break;

        default :
          QCRIL_LOG_ERROR("Invalid USSD dcs : %d", sups_ind_msg->uss_info.uss_dcs);
          break;
      }
    }

    if (success)
    {
      type_code[0] = '0';  // QCRIL_CM_SS_CUSD_RESULT_DONE
      type_code[1] = '\0';
      response_buff[0] = type_code;

      if (sups_ind_msg->uss_info.uss_data_len > 0)
      {
        response_buff[1] = ussd_utf8_str;
      }
      else
      {
        response_buff[1] = NULL;
      }

      // Sending the response received from the network for the USSD request
      QCRIL_LOG_DEBUG("USSD Conf Success, data_len : %d", sups_ind_msg->uss_info.uss_data_len);
      QCRIL_LOG_DEBUG("USSD : type_code=%s",type_code);
      if (NULL != response_buff[1])
      {
        QCRIL_LOG_DEBUG("USSD : response_buff[1]=%s",response_buff[1]);
        QCRIL_LOG_DEBUG("USSD : strlen=%d",strlen(response_buff[1]));
      }
      else
      {
        QCRIL_LOG_DEBUG("USSD : response_buff[1] is NULL");
      }
    }
    else
    {
      // sending the unsol indication so that RIL can close the USSD session
      if ((sups_ind_msg->failure_cause_valid == TRUE) &&
          (sups_ind_msg->failure_cause == QMI_FAILURE_CAUSE_FACILITY_NOT_SUPPORTED_V02))
      {
        type_code[0] = '4';  // QCRIL_CM_SS_CUSD_RESULT_NOSUP
        type_code[1] = '\0';
      }
      else
      {
        type_code[0] = '2';  // QCRIL_CM_SS_CUSD_RESULT_ABORT
        type_code[1] = '\0';
      }
      response_buff[0] = type_code;
      response_buff[1] = NULL;
      QCRIL_LOG_DEBUG("STK CC USSD Failure: type_code=%s",type_code);
    }

    QCRIL_LOG_INFO(".. sending RIL_UNSOL_ON_USSD");
    qcril_default_unsol_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
        (int) RIL_UNSOL_ON_USSD, &unsol_resp);
    unsol_resp.resp_pkt = (void *) response_buff;
    unsol_resp.resp_len = sizeof(response_buff);
    qcril_send_unsol_response(&unsol_resp);
    QCRIL_LOG_INFO(".. sending RIL_UNSOL_ON_USSD done");
  }

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_stk_cc_notify_unsol_on_ss_from_sups_ind
//===========================================================================
void qcril_qmi_voice_stk_cc_notify_unsol_on_ss_from_sups_ind
(
 voice_sups_ind_msg_v02 *sups_ind_msg
)
{
  qcril_unsol_resp_params_type unsol_resp;
  boolean           success = FALSE;
  boolean           ss_service_type_available = FALSE;
  int               ss_service_type = SS_CFU;
  boolean           ss_request_type_available = FALSE;
  RIL_SsRequestType ss_request_type = SS_ERASURE;
  boolean           ss_service_class_available = FALSE;
  int               ss_service_class = 0;
  RIL_StkCcUnsolSsResponse  ril_ss_response;
  int               cb_num_list_len = 0;
  ims_CbNumList    *cb_num_list = NULL;
  boolean           is_ims_indication = stk_cc_info.is_ims_request;

  QCRIL_LOG_FUNC_ENTRY();

  if(sups_ind_msg != NULL)
  {
    QCRIL_LOG_INFO(".. ss reason %d, %d", (int) sups_ind_msg->reason_valid,
        (int) sups_ind_msg->reason);
    QCRIL_LOG_INFO(".. ss service class %d, %d", (int) sups_ind_msg->service_class_valid,
        (int) sups_ind_msg->service_class);

    // service type
    ss_request_type_available = qcril_qmi_voice_map_qmi_ss_service_type_to_ril_ss_request_type(
        sups_ind_msg->supplementary_service_info.service_type, &ss_request_type);

    QCRIL_LOG_INFO(".. ss_request_type %d, %d", (int) ss_request_type_available,
        (int) ss_request_type);

    // request type
    if (sups_ind_msg->reason_valid)
    {
      ss_service_type_available = qcril_qmi_voice_map_qmi_ss_reason_to_ril_ss_service_type(
          sups_ind_msg->reason, &ss_service_type);
    }
    QCRIL_LOG_INFO(".. ss_service_type %d, %d", (int) ss_service_type_available,
        (int) ss_service_type);

    // teleservice type
    if (sups_ind_msg->service_class_valid)
    {
      ss_service_class_available = TRUE;
      ss_service_class = sups_ind_msg->service_class;
    }
    else
    {
      ss_service_class_available = FALSE;
      ss_service_class           = 0; // per ril.h - 0 means user doesn't input class
    }
    QCRIL_LOG_INFO(".. ss_service_class %d, %d", (int) ss_service_class_available,
        (int) ss_service_class );

    // Video service class (CLASS_DATACIRCUITSYNC & CLASS_PACKETACCESS)
    if (ss_service_class & 0x50)
    {
      is_ims_indication = TRUE;
    }

    // build response
    memset(&ril_ss_response, 0, sizeof(ril_ss_response));
    ril_ss_response.serviceType = (RIL_SsServiceType)ss_service_type;
    ril_ss_response.requestType = ss_request_type;
    ril_ss_response.serviceClass = ss_service_class;

    if (ss_request_type_available && ss_service_type_available)
    {
      switch ( ss_request_type )
      {
        case SS_ACTIVATION:
        case SS_DEACTIVATION:
        case SS_REGISTRATION:
        case SS_ERASURE:
          // -- ALL SS request types except INTERROGATION -- start
          // -- ALL SS request types except INTERROGATION -- end
          switch (ss_service_type)
          {
            case SS_CFU:
            case SS_CF_BUSY:
            case SS_CF_NO_REPLY:
            case SS_CF_NOT_REACHABLE:
            case SS_CF_ALL:
            case SS_CF_ALL_CONDITIONAL:
            case SS_CLIP:
            case SS_CLIR:
            case SS_COLP:
            case SS_COLR:
            case SS_WAIT:
            case SS_BAOC:
            case SS_BAOIC:
            case SS_BAOIC_EXC_HOME:
            case SS_BAIC:
            case SS_BAIC_ROAMING:
            case SS_ALL_BARRING:
            case SS_OUTGOING_BARRING:
            case SS_INCOMING_BARRING:
              break;
            default:
              // failure case
              break;
          }
          break;

        case SS_INTERROGATION:
          switch (ss_service_type)
          {
            case SS_CLIP:
              if (sups_ind_msg->clip_status_valid)
              {
                success = TRUE;
                ril_ss_response.ssInfo[0] = sups_ind_msg->clip_status.provision_status;
                if ((sups_ind_msg->clip_status.active_status == 0) &&
                    (sups_ind_msg->clip_status.provision_status == 0))
                {
                  ril_ss_response.ssInfo[0] = QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
                }
              }
              QCRIL_LOG_INFO(".. ss_clip %d, %d", (int)success, (int)ril_ss_response.ssInfo[0]);
              break;

            case SS_CLIR:
              if (sups_ind_msg->clir_status_valid)
              {
                if (sups_ind_msg->failure_cause_valid)
                {
                  ril_ss_response.ssInfo[1] = (int)QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
                  ril_ss_response.ssInfo[0] = QCRIL_QMI_VOICE_SS_CLIR_PRESENTATION_INDICATOR;
                }
                else
                {
                  ril_ss_response.ssInfo[0] = qcril_qmi_voice_info.clir;
                  success = qcril_qmi_voice_map_qmi_to_ril_provision_status(
                      sups_ind_msg->clir_status.provision_status, &ril_ss_response.ssInfo[1]);
                }
              }
              break;

            case SS_COLP:
              if (sups_ind_msg->colp_status_valid)
              {
                success = TRUE;
                ril_ss_response.ssInfo[0] = sups_ind_msg->colp_status.provision_status;
                if ((sups_ind_msg->colp_status.active_status == 0) &&
                    (sups_ind_msg->colp_status.provision_status == 0))
                {
                  ril_ss_response.ssInfo[0] = QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
                }
              }
              QCRIL_LOG_INFO(".. ss_colp %d, %d", (int)success, (int)ril_ss_response.ssInfo[0]);
              break;

            case SS_COLR:
              if (sups_ind_msg->colr_status_valid)
              {
                success = TRUE;
                ril_ss_response.ssInfo[0] = sups_ind_msg->colr_status.provision_status;
                if ((sups_ind_msg->colr_status.active_status == 0) &&
                    (sups_ind_msg->colr_status.provision_status == 0))
                {
                  ril_ss_response.ssInfo[0] = QCRIL_QMI_VOICE_CLIR_SRV_NO_NETWORK;
                }
              }
              QCRIL_LOG_INFO(".. ss_colr %d, %d", (int)success, (int)ril_ss_response.ssInfo[0]);
              break;

            case SS_WAIT:
              if (sups_ind_msg->service_class_valid )
              {
                if (sups_ind_msg->service_class == 0x00) // we love magic numbers
                {
                  ril_ss_response.ssInfo[0] = FALSE;
                }
                else
                {
                  ril_ss_response.ssInfo[0] = TRUE;
                }
                ril_ss_response.ssInfo[1] = sups_ind_msg->service_class;
              }
              else
              {
                success = FALSE;
              }
              break;

            case SS_BAOC:
            case SS_BAOIC:
            case SS_BAOIC_EXC_HOME:
            case SS_BAIC:
            case SS_BAIC_ROAMING:
            case SS_ALL_BARRING:
            case SS_OUTGOING_BARRING:
            case SS_INCOMING_BARRING:
              if (sups_ind_msg->service_class_valid)
              {
                ril_ss_response.ssInfo[0] = sups_ind_msg->service_class;
              }
              break;

            case QCRIL_SS_INCOMING_BARRING_DN:
            case QCRIL_SS_INCOMING_BARRING_ANONYMOUS:
              if (sups_ind_msg->barred_numbers_list_valid &&
                  sups_ind_msg->barred_numbers_list_len > 0)
              {
                cb_num_list_len = sups_ind_msg->barred_numbers_list_len;
                cb_num_list = (ims_CbNumList *)qcril_malloc(sizeof(ims_CbNumList) *
                    sups_ind_msg->barred_numbers_list_len);
                if(cb_num_list)
                {
                  for (uint32_t i = 0; i < sups_ind_msg->barred_numbers_list_len; i++)
                  {
                    if (sups_ind_msg->service_class_valid)
                    {
                      cb_num_list[i].has_status = TRUE;
                      cb_num_list[i].status = sups_ind_msg->service_class ?
                        ims_ServiceClassStatus_ENABLED : ims_ServiceClassStatus_DISABLED;
                      cb_num_list[i].number.arg = qmi_ril_util_str_clone(
                          sups_ind_msg->barred_numbers_list[i].barred_number);
                    }
                  }
                }
                is_ims_indication = TRUE;
              }
              break;

            case SS_CFU:
            case SS_CF_BUSY:
            case SS_CF_NO_REPLY:
            case SS_CF_NOT_REACHABLE:
            case SS_CF_ALL:
            case SS_CF_ALL_CONDITIONAL:
            default:
              // Call Forward cases
              if ( sups_ind_msg->call_forwarding_info_valid &&
                  sups_ind_msg->call_forwarding_info_len > 0 &&
                  sups_ind_msg->call_forwarding_info_len < NUM_SERVICE_CLASSES)
              {
                success = qcril_qmi_voice_convert_sups_ind_call_forwarding_info_to_ril_cfdata(
                    sups_ind_msg->reason,
                    sups_ind_msg->call_forwarding_info,
                    sups_ind_msg->call_forwarding_info_len,
                    &ril_ss_response.cfData);
              }
              break;
          }
          // -- INTERROGATION - end
          break;

        default:
          break;
      }

      if (is_ims_indication)
      {
        ims_ril_ss_ind_type ims_ril_ss_ind;
        memset(&ims_ril_ss_ind, 0, sizeof(ims_ril_ss_ind));
        ims_ril_ss_ind.ril_ss_response = &ril_ss_response;
        ims_ril_ss_ind.cb_num_list_len = cb_num_list_len;
        ims_ril_ss_ind.cb_num_list     = cb_num_list;
        imsRadioSendMessage(0, ims_MsgType_UNSOL_RESPONSE, ims_MsgId_UNSOL_ON_SS,
            ims_Error_E_SUCCESS, &ims_ril_ss_ind, sizeof(ims_ril_ss_ind));
      }
      else
      {
        qcril_default_unsol_resp_params(QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_ON_SS,
            &unsol_resp);
        unsol_resp.resp_pkt = (void *) &ril_ss_response;
        unsol_resp.resp_len = sizeof(ril_ss_response);
        qcril_send_unsol_response(&unsol_resp);
      }
    }
    else
    {  // unknown request type
      QCRIL_LOG_ERROR("ss_request_type / ss_service_type not available");
    }
  }

  qcril_free(cb_num_list);

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_stk_cc_handle_voice_sups_ind
//===========================================================================
void qcril_qmi_voice_stk_cc_handle_voice_sups_ind(voice_sups_ind_msg_v02* sups_ind_msg)
{
  int is_stk_cc_in_progress = qcril_qmi_voice_is_stk_cc_in_progress();
  voice_cc_sups_result_service_type_enum_v02 service_type = stk_cc_info.ss_ussd_info.service_type;

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_voice_stk_cc_dump();

  if (sups_ind_msg != NULL)
  {
    QCRIL_LOG_INFO("..is_stk_cc_in_progress = %d", is_stk_cc_in_progress);
    QCRIL_LOG_INFO("..sups_ind call_id %d, %d",
        (int) sups_ind_msg->call_id_valid, (int) sups_ind_msg->call_id);
    QCRIL_LOG_INFO("..sups_ind data_source %d, %d",
        (int) sups_ind_msg->data_source_valid, (int) sups_ind_msg->data_source);
    QCRIL_LOG_INFO(".. service type, cc_mod %d, %d",
        (int) sups_ind_msg->supplementary_service_info.service_type,
        (int) sups_ind_msg->supplementary_service_info.is_modified_by_call_control);

    if (!is_stk_cc_in_progress)
    {
      // For proactive cases, we should just use the service type in the qmi message
      service_type = (voice_cc_sups_result_service_type_enum_v02)
        sups_ind_msg->supplementary_service_info.service_type;
    }
    QCRIL_LOG_INFO( "..sups_ind service_type %d", (int) service_type);

    if ((sups_ind_msg->data_source_valid &&
          // response from network
          (sups_ind_msg->data_source == VOICE_SUPS_DATA_SOURCE_NETWORK_V02)) &&
        !(sups_ind_msg->alpha_ident_valid &&
          (QCRIL_QMI_VOICE_ALPHA_LENGTH_IN_NULL_CASE == sups_ind_msg->alpha_ident.alpha_text_len)))
    {
      if (((!is_stk_cc_in_progress &&
              sups_ind_msg->supplementary_service_info.service_type == SERVICE_TYPE_USSD_V02 &&
              qcril_qmi_voice_info.process_sups_ind) ||  // for proactive cases
            (is_stk_cc_in_progress &&
             ((sups_ind_msg->call_id_valid && sups_ind_msg->call_id == stk_cc_info.call_id_info) ||
              (sups_ind_msg->supplementary_service_info.is_modified_by_call_control)))))
      {
        if (VOICE_CC_SUPS_RESULT_SERVICE_TYPE_USSD_V02 == service_type)
        {
          qcril_qmi_voice_stk_cc_notify_unsol_on_ussd_from_sups_ind(sups_ind_msg);
        }
        else
        {
          qcril_qmi_voice_stk_cc_notify_unsol_on_ss_from_sups_ind(sups_ind_msg);
        }
      }
    }

    if (((sups_ind_msg->data_source_valid &&
            sups_ind_msg->data_source == VOICE_SUPS_DATA_SOURCE_MS_V02) ||
          !sups_ind_msg->data_source_valid) &&
        sups_ind_msg->alpha_ident_valid)
    {
      /* this should cover the following scenarios.
         1) User initiated requests modified by STK CC.
         2) STK initiated requests modified by STK CC. */
      if (ALPHA_DCS_UCS2_V02 == sups_ind_msg->alpha_ident.alpha_dcs)
      {
        qcril_qmi_voice_transfer_sim_ucs2_alpha_to_std_ucs2_alpha(&sups_ind_msg->alpha_ident,
            &stk_cc_info.alpha_ident);
      }
      else
      {
        stk_cc_info.alpha_ident = sups_ind_msg->alpha_ident;
      }
      qcril_qmi_voice_stk_cc_relay_alpha_if_necessary(QCRIL_DEFAULT_INSTANCE_ID, TRUE);
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_stk_cc_handle_voice_sups_ind

//===========================================================================
// qcril_qmi_voice_transfer_sim_alpha_to_std_alpha
//===========================================================================
void qcril_qmi_voice_transfer_sim_ucs2_alpha_to_std_ucs2_alpha(const voice_alpha_ident_type_v02 *sim_alpha, voice_alpha_ident_type_v02 *std_alpha)
{
  uint8 idx;
  uint8 coding_scheme;
  uint8 num_of_char;
  uint16 base_val;
  uint16 ucs2_val;

  QCRIL_LOG_FUNC_ENTRY();

  memset(std_alpha, 0, sizeof(*std_alpha));

  do
  {
    if ( sim_alpha->alpha_text_len > 0)
    {
      coding_scheme = sim_alpha->alpha_text[0];
    }
    else
    {
      QCRIL_LOG_ERROR("alpha_text_len is 0");
      break;
    }
    QCRIL_LOG_INFO("coding scheme %x", (int)coding_scheme);

    idx = 1;
    switch (coding_scheme)
    {
      case 0x80:
        while ( (uint32)(idx+1) < sim_alpha->alpha_text_len )
        {
          std_alpha->alpha_text[idx-1] = sim_alpha->alpha_text[idx+1];
          std_alpha->alpha_text[idx] = sim_alpha->alpha_text[idx];
          idx += 2;
        }

        if ( (uint32)(idx+1) == sim_alpha->alpha_text_len && 0 != sim_alpha->alpha_text[idx] )
        {
          QCRIL_LOG_ERROR("an unexpected extra non-zero byte in source alpha buffer");
        }

        std_alpha->alpha_dcs = ALPHA_DCS_UCS2_V02;
        std_alpha->alpha_text_len = idx-1;
        break;

      case 0x81:
        if ( sim_alpha->alpha_text_len < 3 )
        {
          QCRIL_LOG_ERROR("sim_alpha->alpha_text_len (%d) less than 3", sim_alpha->alpha_text_len);
        }
        else
        {
          num_of_char = sim_alpha->alpha_text[1];
          base_val = sim_alpha->alpha_text[2];
          base_val <<= 7;
          idx = 3;

          if ( idx + num_of_char > sim_alpha->alpha_text_len )
          {
            QCRIL_LOG_DEBUG("num_of_char > sim_alpha->alpha_text_len - 3");
            num_of_char = sim_alpha->alpha_text_len - idx;
          }

          if (num_of_char * 2 > QMI_VOICE_ALPHA_TEXT_MAX_V02)
          {
            QCRIL_LOG_DEBUG("num_of_char * 2 > QMI_VOICE_ALPHA_TEXT_MAX_V02");
            num_of_char = QMI_VOICE_ALPHA_TEXT_MAX_V02 / 2;
          }

          int i;
          for ( i = 0; i< num_of_char && i < (QMI_VOICE_ALPHA_TEXT_MAX_V02 / 2); i++, idx++ )
          {
            ucs2_val = sim_alpha->alpha_text[idx];

            if ( ucs2_val >= 0x80 )
            {
              ucs2_val &= 0x7F;
              ucs2_val |= base_val;
            }

            std_alpha->alpha_text[2*i]   = (uint8) (ucs2_val);
            std_alpha->alpha_text[2*i+1] = (uint8) (ucs2_val >> 8);
          }
          std_alpha->alpha_dcs = ALPHA_DCS_UCS2_V02;
          std_alpha->alpha_text_len = num_of_char * 2;
        }

        break;

      case 0x82:
        if ( sim_alpha->alpha_text_len < 4 )
        {
          QCRIL_LOG_DEBUG("sim_alpha->alpha_text_len (%d) less than 4", sim_alpha->alpha_text_len);
        }
        else
        {
          num_of_char = sim_alpha->alpha_text[1];
          base_val = sim_alpha->alpha_text[2];
          base_val <<= 8;
          base_val += sim_alpha->alpha_text[3];
          idx = 4;

          if ( idx + num_of_char > sim_alpha->alpha_text_len )
          {
            QCRIL_LOG_DEBUG("num_of_char > sim_alpha->alpha_text_len - 4");
            num_of_char = sim_alpha->alpha_text_len - idx;
          }

          if (num_of_char * 2 > QMI_VOICE_ALPHA_TEXT_MAX_V02)
          {
            QCRIL_LOG_DEBUG("num_of_char * 2 > QMI_VOICE_ALPHA_TEXT_MAX_V02");
            num_of_char = QMI_VOICE_ALPHA_TEXT_MAX_V02 / 2;
          }

          int i;
          for ( i = 0; i< num_of_char && i < (QMI_VOICE_ALPHA_TEXT_MAX_V02 / 2); i++, idx++ )
          {
            ucs2_val = sim_alpha->alpha_text[idx];

            if ( ucs2_val >= 0x80 )
            {
              ucs2_val &= 0x7F;
              ucs2_val += base_val;
            }

            std_alpha->alpha_text[2*i]   = (uint8) (ucs2_val);
            std_alpha->alpha_text[2*i+1] = (uint8) (ucs2_val >> 8);
          }
          std_alpha->alpha_dcs = ALPHA_DCS_UCS2_V02;
          std_alpha->alpha_text_len = num_of_char * 2;
        }

        break;

      default:
        QCRIL_LOG_ERROR("unknown SIM coding scheme");
    }

  } while ( FALSE );

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_transfer_sim_alpha_to_std_alpha

//===========================================================================
// qcril_qmi_voice_stk_cc_dump
//===========================================================================
void qcril_qmi_voice_stk_cc_dump(void)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_INFO("... modification %d, call_id %d, is_ims_request %d ",
      (int) stk_cc_info.modification, (int) stk_cc_info.call_id_info,
      (int) stk_cc_info.is_ims_request);
  QCRIL_LOG_INFO("... ss svc type %d, ss reason %d ", (int) stk_cc_info.ss_ussd_info.service_type,
      (int) stk_cc_info.ss_ussd_info.reason);
  QCRIL_LOG_INFO("... is_alpha_relayed %d ", (int) stk_cc_info.is_alpha_relayed);
} // qcril_qmi_voice_stk_cc_dump

//===========================================================================
// qcril_qmi_voice_stk_ss_resp_handle
//===========================================================================
int qcril_qmi_voice_stk_ss_resp_handle( const qcril_request_params_type *const params_ptr,
                                        qcril_instance_id_e_type instance_id,
                                        qmi_response_type_v01* resp,
                                        void* extra_info,
                                        uint8_t alpha_ident_valid,
                                        voice_alpha_ident_type_v02* alpha_ident,
                                        uint8_t call_id_valid,
                                        uint8_t call_id,
                                        uint8_t cc_sups_result_valid,
                                        voice_cc_sups_result_type_v02* cc_sups_result,
                                        uint8_t cc_result_type_valid,
                                        voice_cc_result_type_enum_v02* cc_result_type)
{
  int res = FALSE;
  RIL_Errno ril_err;

  qcril_qmi_voice_stk_cc_modification_e_type stk_cc_modification;

  qcril_request_resp_params_type ril_response;

  qmi_ril_err_ctx_ss_resp_data_type ss_op_info;

  QCRIL_LOG_INFO( "cidv %d, ccrv %d, ccr %p", (int)call_id_valid, (int)cc_sups_result_valid, cc_sups_result );
  QCRIL_NOTUSED(extra_info);

  memset( &ss_op_info, 0, sizeof( ss_op_info ));
  ss_op_info.cc_sups_result_valid = cc_sups_result_valid;
  ss_op_info.cc_sups_result       = cc_sups_result;
  ss_op_info.cc_result_type_valid = cc_result_type_valid;
  ss_op_info.cc_result_type       = cc_result_type;

  ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( QMI_NO_ERR,
                                                                        resp,
                                                                        QCRIL_QMI_ERR_CTX_SEND_SS_TXN,
                                                                        (void*)&ss_op_info ); // we disregard extra_info param now
  QCRIL_LOG_INFO("STK SS RESP : ril_err=%d, result=%d, error=%d", ril_err,resp->result, resp->error);


  stk_cc_modification = qcril_qmi_voice_map_ril_error_to_stk_cc_modification_type((int)ril_err);

  if ( QCRIL_QMI_VOICE_STK_CC_MODIFICATION_NONE != stk_cc_modification )
  { // STK CC session started
    qcril_qmi_voice_reset_stk_cc();

    stk_cc_info.modification                      = stk_cc_modification;
    stk_cc_info.is_alpha_relayed                  = FALSE;

    if ( call_id_valid )
    {
      stk_cc_info.call_id_info = call_id;
    }

    if ( cc_sups_result_valid )
    {
      stk_cc_info.ss_ussd_info = *cc_sups_result;
    }

    if ( alpha_ident_valid )
    {
      stk_cc_info.alpha_ident = *alpha_ident;
    }
    else
    {
      memset( &stk_cc_info.alpha_ident, 0, sizeof( stk_cc_info.alpha_ident ) );
    }

    if (params_ptr->event_id > QCRIL_EVT_IMS_SOCKET_REQ_BASE &&
        params_ptr->event_id < QCRIL_EVT_IMS_SOCKET_REQ_MAX)
    {
      stk_cc_info.is_ims_request = TRUE;
    }

    res = TRUE;

    QCRIL_LOG_INFO( "org req altered ril_err %d, call_id %d ", (int)ril_err, (int)call_id );

    qcril_qmi_voice_stk_cc_dump();

    if (qcril_is_event_in_group(params_ptr->event_id, &QCRIL_GRP_IMS))
    {
      imsRadioSendMessage(params_ptr->t,
                          ims_MsgType_RESPONSE,
                          qcril_qmi_ims_map_event_to_request(params_ptr->event_id),
                          qcril_qmi_ims_map_ril_error_to_ims_error(ril_err),
                          NULL, 0);
    }
    else
    {
      qcril_default_request_resp_params(instance_id, params_ptr->t,
                                        params_ptr->event_id, ril_err,
                                        &ril_response);
      qcril_send_request_response(&ril_response);
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

  return res;
} // qcril_qmi_voice_stk_ss_resp_handle

//===========================================================================
// qmi_ril_voice_is_under_any_voice_calls
//===========================================================================
int qmi_ril_voice_is_under_any_voice_calls(void)
{
  int                                         res;
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  res = FALSE;

  qcril_qmi_voice_voip_lock_overview();

  call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
  while ( NULL != call_info_entry && !res )
  {
    if ( VOICE_INVALID_CALL_ID != call_info_entry->android_call_id &&
         ( CALL_TYPE_VOICE_V02 == call_info_entry->voice_scv_info.call_type ||
           CALL_TYPE_EMERGENCY_V02 == call_info_entry->voice_scv_info.call_type )
       )
    {
      res = TRUE;
    }
    else
    {
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
    }
  }

  qcril_qmi_voice_voip_unlock_overview();

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

  return res;
} // qmi_ril_voice_is_under_any_voice_calls

//===========================================================================
// RIL_REQUEST_SET_TTY_MODE
//===========================================================================
void qcril_qmi_voice_request_set_tty_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int *tty_mode_ptr = NULL;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  tty_mode_enum_v02 qmi_tty_val;

  voice_set_config_req_msg_v02  qmi_request;
  voice_set_config_resp_msg_v02 qmi_response;

  ims_TtyNotify *ims_tty_notify = NULL;
  uint8_t outcome_valid = 0;
  uint8_t outcome = 0;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  do
  {
    if ( params_ptr->datalen <= 0 || params_ptr->data == NULL )
    {
      QCRIL_LOG_INFO("Invalid data received\n");
      ril_req_res = RIL_E_INVALID_ARGUMENTS;
      break;
    }

    memset(&qmi_response, 0, sizeof(qmi_response));
    memset( &qmi_request, 0, sizeof( qmi_request ) );

    if ( QCRIL_EVT_RIL_REQUEST_SET_TTY_MODE == params_ptr->event_id )
    {
      tty_mode_ptr = ( int * )params_ptr->data;
      if ((*tty_mode_ptr) < QCRIL_CM_TTY_MODE_MIN || (*tty_mode_ptr) > QCRIL_CM_TTY_MODE_MAX )
      {
        QCRIL_LOG_INFO("Invalid tty mode (%d) received\n", *tty_mode_ptr);
        ril_req_res = RIL_E_INVALID_ARGUMENTS;
        break;
      }
      switch ( *tty_mode_ptr )
      {
        case QCRIL_CM_TTY_MODE_FULL:
          qmi_tty_val = TTY_MODE_FULL_V02;
          break;

        case QCRIL_CM_TTY_MODE_HCO:
          qmi_tty_val = TTY_MODE_HCO_V02;
          break;

        case QCRIL_CM_TTY_MODE_VCO:
          qmi_tty_val = TTY_MODE_VCO_V02;
          break;

        case QCRIL_CM_TTY_MODE_OFF:   // fallthrough
        default:
          qmi_tty_val = TTY_MODE_OFF_V02;
          break;
      }
      QCRIL_LOG_INFO(".. tty val  %d", (int)qmi_tty_val);

      qmi_request.tty_mode_valid = TRUE;
      qmi_request.tty_mode = qmi_tty_val;
    }
    else
    {
      ims_tty_notify = (ims_TtyNotify *)params_ptr->data;
      if (!qcril_qmi_ims_translate_ims_ttymodetype_to_qmi_tty_mode(ims_tty_notify->mode,
                  &qmi_tty_val))
      {
        QCRIL_LOG_INFO("Invalid ui tty mode(%d) received\n", ims_tty_notify->mode);
        ril_req_res = RIL_E_INVALID_ARGUMENTS;
         break;
      }
      QCRIL_LOG_INFO(".. tty setting  %d", (int)qmi_tty_val);
      qmi_request.ui_tty_setting_valid = TRUE;
      qmi_request.ui_tty_setting = qmi_tty_val;
    }

    // TODO: better to move to a common function
    qmi_client_error_type transp_err = get_voice_modem_endpoint()->sendRawSync(
                                QMI_VOICE_SET_CONFIG_REQ_V02,
                                (void*)(&qmi_request),
                                sizeof(voice_set_config_req_msg_v02),
                                (void*)(&qmi_response),
                                sizeof(voice_set_config_resp_msg_v02));
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                transp_err, (qmi_response_type_v01*)(&qmi_response));

    QCRIL_LOG_INFO(".. qmi req got  %d", (int)ril_req_res );

    if ( RIL_E_SUCCESS == ril_req_res )
    {
      if ( qmi_request.tty_mode_valid )
      {
        outcome_valid = qmi_response.tty_mode_outcome_valid;
        outcome = qmi_response.tty_mode_outcome;
      }
      else if ( qmi_request.ui_tty_setting_valid )
      {
        outcome_valid = qmi_response.ui_tty_setting_outcome_valid;
        outcome = qmi_response.ui_tty_setting_outcome;
      }
      QCRIL_LOG_INFO(".. outcome  %d, %d", (int)outcome_valid, (int)outcome );
      if ( outcome_valid && 0x00 != outcome )// 0x00: Information written successfully per QMI Voice
      {
        ril_req_res = RIL_E_MODEM_ERR;
      }
    }
  } while (FALSE);

  qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t,
          params_ptr->event_id, ril_req_res);

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);

} // qcril_qmi_voice_request_set_tty_mode

//===========================================================================
// RIL_REQUEST_QUERY_TTY_MODE
//===========================================================================
void qcril_voice_query_tty_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type resp;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int ril_response = 0;

  voice_get_config_req_msg_v02 qmi_request;
  voice_get_config_resp_msg_v02 qmi_response;

  QCRIL_LOG_FUNC_ENTRY();


  QCRIL_NOTUSED( ret_ptr );

  memset( &qmi_request, 0, sizeof( qmi_request ) );
  qmi_request.tty_mode_valid = TRUE;
  qmi_request.tty_mode = 0x01; // as per QMI Voice - 0x01: Include tty configurations status information in response message

  memset( &qmi_response, 0, sizeof( qmi_response ) );

  qmi_client_error_type transp_err = get_voice_modem_endpoint()->sendRawSync(
                                       QMI_VOICE_GET_CONFIG_REQ_V02,
                                       &qmi_request,
                                       sizeof( qmi_request ),
                                       (void*) &qmi_response,
                                       sizeof( qmi_response ));
  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                            transp_err, (qmi_response_type_v01*)(&qmi_response));

  QCRIL_LOG_INFO( ".. qmi req %d", (int)ril_req_res );

  if ( RIL_E_SUCCESS == ril_req_res )
  {
    if ( qmi_response.current_tty_mode_valid )
    {
      switch ( qmi_response.current_tty_mode )
      {
        case TTY_MODE_FULL_V02:
          ril_response = QCRIL_CM_TTY_MODE_FULL;
          break;

        case TTY_MODE_VCO_V02:
          ril_response = QCRIL_CM_TTY_MODE_VCO;
          break;

        case TTY_MODE_HCO_V02:
          ril_response = QCRIL_CM_TTY_MODE_HCO;
          break;

        case TTY_MODE_OFF_V02:  // fallthrough
          ril_response = QCRIL_CM_TTY_MODE_OFF;
        default:
          break;
      }
    }
    else
    {
      ril_req_res = RIL_E_MODEM_ERR;
    }
  }

  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res  )
  {
    resp.resp_pkt = (void *) &ril_response;
    resp.resp_len = sizeof( ril_response );
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);

} // qcril_voice_query_tty_mode

//===========================================================================
// qcril_qmi_voice_waiting_call_handler
//===========================================================================
void qcril_qmi_voice_waiting_call_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );
  if (qmi_ril_is_feature_supported(QMI_RIL_FEATURE_KDDI_HOLD_ANSWER))
  {
    // send flash for Hold Answer feature
    voice_send_flash_req_msg_v02  send_flash_req_msg;
    voice_send_flash_resp_msg_v02 send_flash_resp_msg;
    memset(&send_flash_req_msg,0,sizeof(send_flash_req_msg));
    send_flash_req_msg.call_id = *((uint8_t*) (params_ptr->data));
    send_flash_req_msg.flash_type_valid = TRUE;
    send_flash_req_msg.flash_type = QMI_VOICE_FLASH_TYPE_ACT_ANSWER_HOLD_V02;

    qmi_client_error_type transp_err = get_voice_modem_endpoint()->sendRawSync(
                                           QMI_VOICE_SEND_FLASH_REQ_V02,
                                           &send_flash_req_msg,
                                           sizeof(send_flash_req_msg),
                                           &send_flash_resp_msg,
                                           sizeof(send_flash_resp_msg));
    QCRIL_LOG_INFO("Send flash result: %d, %d", transp_err, send_flash_resp_msg.resp);
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_waiting_call_handler

// ---------------------------------------------- VOIP utilities -------------------------------------------------------------------
//===========================================================================
// qcril_qmi_voice_voip_create_call_info_entry
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_create_call_info_entry(
        uint8_t call_qmi_id,
        int32_t call_media_id,
        int need_allocate_call_android_id,
        qcril_qmi_voice_voip_call_info_elaboration_type initial_elaboration,
        RIL_Errno *ril_err )
{
  uint8_t call_android_id = VOICE_INVALID_CALL_ID;
  qcril_qmi_voice_voip_call_info_entry_type* res =
        (qcril_qmi_voice_voip_call_info_entry_type*)qcril_malloc( sizeof( *res ) );
  RIL_Errno id_alloc_res = RIL_E_SUCCESS;
  int   finalized_ok;

  if ( res )
  {
    finalized_ok = FALSE;
    memset( res, 0, sizeof( *res ) );

    do
    {
      res->elaboration = initial_elaboration;

      if ( need_allocate_call_android_id )
      {
        id_alloc_res = qcril_qmi_voice_voip_allocate_call_android_id ( &call_android_id );
        if ( RIL_E_SUCCESS != id_alloc_res )
            break;
      }

      res->android_call_id = call_android_id;

      res->qmi_call_id = call_qmi_id;

      res->media_id = call_media_id;

      res->next = qmi_voice_voip_overview.call_info_root;
      qmi_voice_voip_overview.call_info_root = res;

      finalized_ok = TRUE;
    } while (FALSE);

    if ( !finalized_ok )
    { // rollback
      qcril_free( res );
      res = NULL;
      id_alloc_res = RIL_E_NO_RESOURCES;
    }
  }
  else
  {
    id_alloc_res = RIL_E_NO_MEMORY;
  }

  QCRIL_LOG_ESSENTIAL("Created call info entry %p with call android id %d, qmi id %d, media id %d",
                        res, (int) call_android_id, call_qmi_id, call_media_id);
  if(ril_err != NULL)
  {
    *ril_err = id_alloc_res;
  }

  return res;
} // qcril_qmi_voice_voip_create_call_info_entry

//===========================================================================
// qcril_qmi_voice_voip_destroy_call_info_entry
//===========================================================================
void qcril_qmi_voice_voip_destroy_call_info_entry( qcril_qmi_voice_voip_call_info_entry_type* entry )
{
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* prev = NULL;
  int found;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_INFO(  ".. entry %p", entry );

  if ( entry )
  {

    iter = qmi_voice_voip_overview.call_info_root;
    prev = NULL;
    found = FALSE;

    while ( iter != NULL && !found )
    {
      if ( iter == entry )
      {
        found = TRUE;
      }
      else
      {
        prev = iter;
        iter = iter->next;
      }
    }
    QCRIL_LOG_INFO( ".. entry found ok %d", found );
    if ( found )
    {
      if ( entry == qmi_voice_voip_overview.call_info_enumeration_current )
      {
        qmi_voice_voip_overview.call_info_enumeration_current = entry->next;
      }

      if ( NULL == prev )
      { // first
        qmi_voice_voip_overview.call_info_root = entry->next;
      }
      else
      {
        prev->next = entry->next;
      }

      // destroy
      if ( !(entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_GOLDEN) )
      {
        //destroy the cdma emergency voice call handling entries
        if( entry->emer_voice_number.number )
        {
          qcril_free(entry->emer_voice_number.number);
        }

        // detroy phaseout timer if needed
        if ( QMI_RIL_ZERO != entry->call_obj_phase_out_timer_id )
        {
          qcril_cancel_timed_callback( (void*)(uintptr_t)entry->call_obj_phase_out_timer_id );
        }

        // destroy additional call info buffer
        if( entry->additional_call_info.buffer )
        {
          qcril_free(entry->additional_call_info.buffer);
        }

        // destroy STK CC emulation overlays
        if ( entry->overlayed_number_storage_for_emulated_stk_cc )
        {
          qcril_free( entry->overlayed_number_storage_for_emulated_stk_cc );
        }
        if ( entry->overlayed_name_storage_for_emulated_stk_cc )
        {
          qcril_free( entry->overlayed_name_storage_for_emulated_stk_cc );
        }

        if (entry->terminating_num)
        {
          qcril_free(entry->terminating_num);
        }

        qcril_free( entry );
      }
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_voip_destroy_call_info_entry

//===========================================================================
// qcril_qmi_voice_voip_allocate_call_android_id
//===========================================================================
RIL_Errno qcril_qmi_voice_voip_allocate_call_android_id( uint8_t* new_call_android_id )
{
  RIL_Errno res = RIL_E_GENERIC_FAILURE;
  uint8_t call_id;
  uint8_t generated_call_id;
  int generated;
  int found;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  generated_call_id = VOICE_INVALID_CALL_ID;

  if ( new_call_android_id )
  {
    generated = FALSE;
    for ( call_id = VOICE_LOWEST_CALL_ID; call_id <= VOICE_HIGHEST_CALL_ID && !generated; call_id++ )
    {
      iter = qmi_voice_voip_overview.call_info_root;
      found = FALSE;
      while ( iter != NULL && !found )
      {
        if ( call_id == iter->android_call_id )
        {
          found = TRUE;
          break;
        }
        iter = iter->next;
      }
      if ( !found )
      {
        generated_call_id = call_id;
        generated = TRUE;
      }
    }

    if ( generated )
    {
      res = RIL_E_SUCCESS;
    }

    *new_call_android_id = generated_call_id;
  }

  QCRIL_LOG_INFO( "returns res %d and id %d", (int) res, (int)generated_call_id );

  return res;
} // qcril_qmi_voice_voip_allocate_call_android_id

//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id( uint8_t call_qmi_id )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  QCRIL_LOG_INFO( "entry with id %d", (int)call_qmi_id );
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( call_qmi_id == iter->qmi_call_id )
    {
        res = iter;
    }
    else
    {
        iter = iter->next;
    }
  }


  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_call_qmi_id

//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id( uint8_t call_andoid_id )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  QCRIL_LOG_INFO( "entry with id %d", (int)call_andoid_id );
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( call_andoid_id == iter->android_call_id )
    {
      res = iter;
      break;
    }
    iter = iter->next;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id

//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state( RIL_CallState ril_call_state )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  QCRIL_LOG_INFO( "entry with ril call state %d", (int)ril_call_state );
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( ( iter->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_RIL_CALL_STATE_VALID ) && ( ril_call_state == iter->ril_call_state ) )
    {
        res = iter;
    }
    else
    {
        iter = iter->next;
    }
  }


  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_andoid_call_state
//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_elaboration
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( qcril_qmi_voice_voip_call_info_elaboration_type elaboration_pattern, int pattern_present )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;
  qcril_qmi_voice_voip_call_info_elaboration_type expected_after_application;

  QCRIL_LOG_INFO( "entry with elaboration %x, %x hex", (uint32)(elaboration_pattern >> 32),(uint32)elaboration_pattern );

  if ( pattern_present )
  {
    expected_after_application  = elaboration_pattern;
  }
  else
  {
    expected_after_application  = QMI_RIL_ZERO;
  }

  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( expected_after_application == (elaboration_pattern & iter->elaboration) ) // all bits
    {
      res = iter;
      break;
    }
    iter = iter->next;
  }

  if ( NULL != res )
  {
    QCRIL_LOG_INFO( ".. found %p - with call android id %d, call qmi id %d", res, (int)res->android_call_id, (int)res->qmi_call_id );
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_elaboration
//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_elaboration_any_subset
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_elaboration_any_subset( qcril_qmi_voice_voip_call_info_elaboration_type elaboration_pattern )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  QCRIL_LOG_INFO( "entry with pattern %d", (int)elaboration_pattern );


  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( elaboration_pattern & iter->elaboration ) // any of requested bits
    {
        res = iter;
    }
    else
    {
        iter = iter->next;
    }
  }

  if ( NULL != res )
  {
    QCRIL_LOG_INFO( ".. found %p - with call android id %d, call qmi id %d", res, (int)res->android_call_id, (int)res->qmi_call_id );
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_elaboration_any_subset

//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_single_elaboration_extended
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_single_elaboration_extended( qcril_qmi_voice_voip_call_info_elaboration_type elaboration_single,
                                                                                                                     int single_present )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;
  qcril_qmi_voice_voip_call_info_elaboration_type expected_after_application;

  int                                             is_extended;
  qcril_qmi_voice_voip_call_info_elaboration_type extended_ela_value;

  extended_ela_value = 0;
  is_extended = qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust( elaboration_single, &extended_ela_value );

  if ( single_present )
  {
     if ( is_extended )
     {
        expected_after_application = extended_ela_value;
     }
     else
     {
       expected_after_application  = elaboration_single;
     }
  }
  else
  {
    expected_after_application  = QMI_RIL_ZERO;
  }

  QCRIL_LOG_INFO( "lookup %x, %x hex, is extended %d", (uint32)(elaboration_single >> 32),(uint32)elaboration_single, is_extended );

  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if (  ( !is_extended && ( expected_after_application == ( elaboration_single & iter->elaboration ) ) )
        ||
        ( is_extended && ( expected_after_application == ( extended_ela_value & iter->elaboration_extended )  ) )
       )
    {
      res = iter;
      break;
    }
    iter = iter->next;
  }

  if ( NULL != res )
  {
    QCRIL_LOG_INFO( ".. found %p - with call android id %d, call qmi id %d", res, (int)res->android_call_id, (int)res->qmi_call_id );
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_single_elaboration_extended


//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_conn_uri
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_conn_uri( const char *conn_uri )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  QCRIL_LOG_INFO( "entry with conn_uri %s", conn_uri);
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( !strcmp( conn_uri, iter->voice_svc_remote_party_number.number ) )
    {
      res = iter;
      break;
    }
    iter = iter->next;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_conn_uri

//===========================================================================
// qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state( call_state_enum_v02 qmi_call_state )
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;
  qcril_qmi_voice_voip_call_info_entry_type* iter;

  QCRIL_LOG_INFO( "seeking entry with qmi call state %d", (int)qmi_call_state );
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL && NULL == res )
  {
    if ( qmi_call_state == iter->voice_scv_info.call_state )
    {
        res = iter;
    }
    else
    {
        iter = iter->next;
    }
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} // qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state

//===========================================================================
// qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust
//
// we check if elaboration_single_input belongs to original 64 bit or to extended range
// in later case we provide via elaboration_single_adjusted a bit mask for extended elabotaion check
//===========================================================================
int qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust( qcril_qmi_voice_voip_call_info_elaboration_type elaboration_single_input,
                                                                   qcril_qmi_voice_voip_call_info_elaboration_type * elaboration_single_adjusted )
{
   int res;
   if ( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE == elaboration_single_input )
   { // original elaboration range
      res = FALSE;
   }
   else
   if ( QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_FIRST == elaboration_single_input ||
        (0 == (elaboration_single_input & 1) )
      )
   { // in initial elaboration all values are even except QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_FIRST
      res = FALSE;
   }
   else
   {
      res = TRUE;
   }
   if ( res && NULL != elaboration_single_adjusted )
   {
      *elaboration_single_adjusted = elaboration_single_input ^ 1;
   }

   return res;
} // qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust

//===========================================================================
// qcril_qmi_voice_voip_call_info_is_single_elaboration_set
//===========================================================================
int qcril_qmi_voice_voip_call_info_is_single_elaboration_set( const qcril_qmi_voice_voip_call_info_entry_type* entry, qcril_qmi_voice_voip_call_info_elaboration_type single_elaboration )
{
   int                                             res = 0;
   int                                             is_extended;
   qcril_qmi_voice_voip_call_info_elaboration_type single_elaboration_extended_adjusted;

   if ( NULL != entry )
   {
      single_elaboration_extended_adjusted = 0;
      is_extended = qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust( single_elaboration, &single_elaboration_extended_adjusted );

      if (!is_extended)
      {
         res = ( 0 != ( entry->elaboration & single_elaboration ) );
      }
      else
      {
         res = ( 0 != ( entry->elaboration_extended & single_elaboration_extended_adjusted ) );
      }
   }

   return res;
} // qcril_qmi_voice_voip_call_info_is_single_elaboration_set
//===========================================================================
// qcril_qmi_voice_voip_call_info_set_single_elaboration
//===========================================================================
void qcril_qmi_voice_voip_call_info_set_single_elaboration( qcril_qmi_voice_voip_call_info_entry_type* entry, qcril_qmi_voice_voip_call_info_elaboration_type single_elaboration, int is_set )
{
   int                                             is_extended;
   qcril_qmi_voice_voip_call_info_elaboration_type single_elaboration_extended_adjusted;

   if ( NULL != entry )
   {
      single_elaboration_extended_adjusted = 0;
      is_extended = qcril_qmi_voice_voip_is_elaboration_extended_check_and_adjust( single_elaboration, &single_elaboration_extended_adjusted );

      if ( !is_extended )
      {
         if ( is_set )
         {
            entry->elaboration |= single_elaboration;
         }
         else
         {
            entry->elaboration &= ( 0xFFFFFFFFFFFFFFFFUL ^ single_elaboration );
         }
      }
      else
      {
         if ( is_set )
         {
            entry->elaboration_extended |= single_elaboration_extended_adjusted;
         }
         else
         {
            entry->elaboration_extended &= ( 0xFFFFFFFFFFFFFFFFUL ^ single_elaboration_extended_adjusted );
         }
      }
   }

} // qcril_qmi_voice_voip_call_info_set_single_elaboration


//===========================================================================
// qcril_qmi_voice_consider_shadow_remote_number_cpy_creation
//===========================================================================
void qcril_qmi_voice_consider_shadow_remote_number_cpy_creation( qcril_qmi_voice_voip_call_info_entry_type* entry )
{
  QCRIL_LOG_INFO( "param %p", entry );

  if ( NULL != entry )
  {
    if ( ( CALL_TYPE_VOICE_V02 == entry->voice_scv_info.call_type ||
         CALL_TYPE_EMERGENCY_V02 == entry->voice_scv_info.call_type ) &&
         entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID &&
         !qcril_qmi_voice_is_emer_voice_entry_valid(&entry->emer_voice_number) )
    {
      QCRIL_LOG_INFO( "shadow created for voice/emergency call" );
      qcril_qmi_voice_create_emer_voice_entry(&entry->emer_voice_number, &entry->voice_svc_remote_party_number);
    }
  }
} // qcril_qmi_voice_consider_shadow_remote_number_cpy_creation

//===========================================================================
// qcril_qmi_voice_call_info_entry_set_call_modified_cause
//===========================================================================
void qcril_qmi_voice_call_info_entry_set_call_modified_cause
(
 qcril_qmi_voice_voip_call_info_entry_type *entry,
 voice_call_modified_cause_enum_v02         call_modified_cause
)
{
  if (entry)
  {
    QCRIL_LOG_INFO("Set call_modified_cause: %d for call info entry: %p"
                   " (call android id %d, call qmi id %d)",
                   call_modified_cause, entry,
                   (int)entry->android_call_id, (int)entry->qmi_call_id);

    entry->call_modified_cause_valid = TRUE;
    entry->call_modified_cause       = call_modified_cause;
  }
}

//===========================================================================
// qcril_qmi_voice_voip_update_call_info_entry_mainstream
//===========================================================================
void qcril_qmi_voice_voip_update_call_info_entry_mainstream
(
 qcril_qmi_voice_voip_call_info_entry_type* entry,
 voice_all_call_status_ind_msg_v02* call_status_ind,
 uint8_t ril_call_state_valid,
 RIL_CallState ril_call_state
)
{
  char alpha_remote_name[QMI_VOICE_CALLER_NAME_MAX_V02+1] = {0};
  int alpha_remote_name_len = 0;
  uint8 remote_party_name_len = 0;
  unsigned int j = 0;
  uint8_t qmi_call_id;
  boolean need_update_remote_party_details = FALSE;

  QCRIL_LOG_INFO("param %p", entry);
  if (entry && call_status_ind)
  {
    QCRIL_LOG_INFO( "call android id %d, call qmi id %d",
        (int)entry->android_call_id, (int)entry->qmi_call_id);
    qmi_call_id = entry->qmi_call_id;

    // call_info
    for (j = 0; (j < call_status_ind->call_info_len && j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
    {
      if (call_status_ind->call_info[j].call_id == qmi_call_id)
      {
        entry->voice_scv_info = call_status_ind->call_info[j];
        QCRIL_LOG_INFO( ".. call state %d, call type %d, call mode %d",
            (int)entry->voice_scv_info.call_state, (int)entry->voice_scv_info.call_type,
            (int)entry->voice_scv_info.mode );

        // Update the remote party number/ip number if the call is in incoming state.
        if ((entry->voice_scv_info.call_state == CALL_STATE_INCOMING_V02) ||
            (entry->voice_scv_info.call_state == CALL_STATE_WAITING_V02) ||
            (entry->voice_scv_info.call_state == CALL_STATE_SETUP_V02))
        {
          need_update_remote_party_details =  TRUE;
        }
        break;
      }
    }

    if (ril_call_state_valid)
    {
      entry->ril_call_state = ril_call_state;
      entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_RIL_CALL_STATE_VALID;
    }

    /* If the alpha identifier is provided by the UICC, this is an indication that the terminal should not give any information
       to the user on the changes made by the UICC to the initial user request. So, We have to ignore modified number in remote
       party field if Alpha text is valid.
       */
    if (call_status_ind->ip_num_info_valid)
    {
      for (j = 0; (j < call_status_ind->ip_num_info_len &&
            j < QMI_VOICE_REMOTE_PARTY_NUMBER_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->ip_num_info[j].call_id == qmi_call_id)
        {
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_IP_NUMBER_VALID;
          if (need_update_remote_party_details ||
              (!call_status_ind->alpha_id_valid &&
               !qcril_qmi_voice_info.is_original_number_display))
          {
            entry->voice_svc_remote_party_ip_number = call_status_ind->ip_num_info[j];
          }
          break;
        }
      }
    }

    //  Is Connected Number ECT
    if (call_status_ind->is_connected_number_ECT_valid)
    {
      for (j = 0; (j < call_status_ind->is_connected_number_ECT_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->is_connected_number_ECT[j].call_id == qmi_call_id)
        {
          // Modify remote party number if it is modified due to call transfer
          // in CONVERSATION/HOLD states.
          if (call_status_ind->is_connected_number_ECT[j].is_connected_number_ECT &&
              ((entry->voice_scv_info.call_state == CALL_STATE_CONVERSATION_V02) ||
               (entry->voice_scv_info.call_state == CALL_STATE_HOLD_V02)))
          {
            need_update_remote_party_details = TRUE;
          }
          break;
        }
      }
    }

    // remote party number
    if (call_status_ind->remote_party_number_valid)
    {
      for (j = 0; (j < call_status_ind->remote_party_number_len &&
            j < QMI_VOICE_REMOTE_PARTY_NUMBER_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->remote_party_number[j].call_id == qmi_call_id)
        {
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NUMBER_VALID;
          if (need_update_remote_party_details ||
              (!call_status_ind->alpha_id_valid &&
               !qcril_qmi_voice_info.is_original_number_display))
          {
            entry->voice_svc_remote_party_number = call_status_ind->remote_party_number[j];
          }
          break;
        }
      }
    }

    if (call_status_ind->remote_party_name_valid)
    {
      for (j = 0; (j < call_status_ind->remote_party_name_len &&
            j < QMI_VOICE_REMOTE_PARTY_NAME_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->remote_party_name[j].call_id == qmi_call_id)
        {
          voice_remote_party_name2_type_v02 *remote_party_name =
            &call_status_ind->remote_party_name[j];

          entry->voice_svc_remote_party_name.call_id = remote_party_name->call_id;
          entry->voice_svc_remote_party_name.name_pi = remote_party_name->name_pi;

          *(entry->voice_svc_remote_party_name.name) = 0;

          QCRIL_LOG_INFO("remote party name - coding scheme %d, len %d",
              remote_party_name->coding_scheme, remote_party_name->name_len);

          remote_party_name_len = ((remote_party_name->name_len > QMI_VOICE_CALLER_NAME_MAX_V02) ?
              QMI_VOICE_CALLER_NAME_MAX_V02 : remote_party_name->name_len);

          if (entry->voice_scv_info.mode == CALL_MODE_CDMA_V02)
          {
            // convert ascii to utf8
            QCRIL_LOG_INFO("remote party name - call mode CDMA; convert ascii to utf8\n");
            entry->voice_svc_remote_party_name.name_len =
              qcril_cm_ss_ascii_to_utf8((unsigned char*) remote_party_name->name,
                  remote_party_name_len,
                  entry->voice_svc_remote_party_name.name,
                  sizeof(entry->voice_svc_remote_party_name.name));
          }
          else
          {
            entry->voice_svc_remote_party_name.name_len =
              qcril_cm_ss_convert_ussd_string_to_utf8(remote_party_name->coding_scheme,
                  (byte *)remote_party_name->name,
                  remote_party_name_len,
                  entry->voice_svc_remote_party_name.name,
                  sizeof(entry->voice_svc_remote_party_name.name));
          }

          if ((!*entry->voice_svc_remote_party_name.name) ||
              (entry->voice_svc_remote_party_name.name_len >=
               sizeof(entry->voice_svc_remote_party_name.name)))
          {
            QCRIL_LOG_ERROR("Invalid conversion results, remote name");
          }
          else
          {
            entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NAME_VALID;
          }
          break;
        }
      }
    }

    if (call_status_ind->alerting_type_valid)
    {
      for (j = 0; (j < call_status_ind->alerting_type_len &&
            j < QMI_VOICE_ALERTING_TYPE_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->alerting_type[j].call_id == qmi_call_id)
        {
          entry->voice_svc_alerting_type = call_status_ind->alerting_type[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALERTING_TYPE_VALID;
          break;
        }
      }
    }

    if (call_status_ind->srv_opt_valid)
    {
      for (j = 0; (j < call_status_ind->srv_opt_len &&
            j < QMI_VOICE_SRV_OPT_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->srv_opt[j].call_id == qmi_call_id)
        {
          entry->voice_svc_srv_opt = call_status_ind->srv_opt[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_SRV_OPT_VALID;
          break;
        }
      }
    }
    if (call_status_ind->call_end_reason_valid)
    {
      for (j = 0; (j < call_status_ind->call_end_reason_len &&
            j < QMI_VOICE_CALL_END_REASON_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->call_end_reason[j].call_id == qmi_call_id)
        {
          entry->voice_svc_call_end_reason = call_status_ind->call_end_reason[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_END_REASON_VALID;
          break;
        }
      }
    }
    if (call_status_ind->alpha_id_valid)
    {
      for (j = 0; (j < call_status_ind->alpha_id_len &&
            j < QMI_VOICE_ALPHA_IDENT_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->alpha_id[j].call_id == qmi_call_id)
        {
          voice_alpha_ident_with_id_type_v02 *alpha_id = &call_status_ind->alpha_id[j];

          alpha_id->alpha_text_len = (alpha_id->alpha_text_len>QMI_VOICE_ALPHA_TEXT_MAX_V02) ?
            QMI_VOICE_ALPHA_TEXT_MAX_V02 : alpha_id->alpha_text_len;
          entry->voice_svc_alpha_id = *alpha_id;
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ALPHA_ID_VALID;

          if (!call_status_ind->remote_party_name_valid)
          {
            if (ALPHA_DCS_GSM_V02 == alpha_id->alpha_dcs)
            {
              alpha_remote_name_len = qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8(
                  (char *)alpha_id->alpha_text,
                  alpha_id->alpha_text_len,
                  alpha_remote_name,
                  sizeof(alpha_remote_name));
            }
            else
            {
              alpha_remote_name_len = qcril_cm_ss_convert_ucs2_to_utf8(
                  (char *)alpha_id->alpha_text,
                  alpha_id->alpha_text_len * 2,
                  alpha_remote_name,
                  sizeof(alpha_remote_name));
            }

            entry->voice_svc_remote_party_name.call_id = entry->qmi_call_id;
            entry->voice_svc_remote_party_name.name_pi = PRESENTATION_NAME_PRESENTATION_ALLOWED_V02;
            entry->voice_svc_remote_party_name.name_len = alpha_remote_name_len;
            strlcpy(entry->voice_svc_remote_party_name.name,
                alpha_remote_name, sizeof(entry->voice_svc_remote_party_name.name));
            entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_R_PARTY_NAME_VALID;

            QCRIL_LOG_ESSENTIAL("Alpha string %s", entry->voice_svc_remote_party_name.name);
          }
          break;
        }
      }
    }
    if (call_status_ind->conn_ip_num_info_valid)
    {
      for (j = 0; (j < call_status_ind->conn_ip_num_info_len &&
            j < QMI_VOICE_CONNECTED_PARTY_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->conn_ip_num_info[j].call_id == qmi_call_id)
        {
          entry->voice_svc_conn_party_ip_num = call_status_ind->conn_ip_num_info[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONN_PARTY_IP_NUM_VALID;
          break;
        }
      }
    }
    if (call_status_ind->conn_party_num_valid)
    {
      for (j = 0; (j < call_status_ind->conn_party_num_len &&
            j < QMI_VOICE_CONNECTED_PARTY_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->conn_party_num[j].call_id == qmi_call_id)
        {
          entry->voice_svc_conn_party_num = call_status_ind->conn_party_num[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CONN_PARTY_NUM_VALID;
          break;
        }
      }
    }
    if (call_status_ind->diagnostic_info_valid)
    {
      for (j = 0; (j < call_status_ind->diagnostic_info_len &&
            j < QMI_VOICE_DIAGNOSTIC_INFO_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->diagnostic_info[j].call_id == qmi_call_id)
        {
          entry->voice_svc_diagnostic_info = call_status_ind->diagnostic_info[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_DIAGNOSTIC_INFO_VALID;
          break;
        }
      }
    }
    if (call_status_ind->called_party_num_valid)
    {
      for (j = 0; (j < call_status_ind->called_party_num_len &&
            j < QMI_VOICE_CALLED_PARTY_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->called_party_num[j].call_id == qmi_call_id)
        {
          entry->voice_svc_called_party_num = call_status_ind->called_party_num[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALLED_PARTY_NUM_VALID;
          break;
        }
      }
    }
    if (call_status_ind->redirecting_party_num_valid)
    {
      for (j = 0; (j < call_status_ind->redirecting_party_num_len &&
            j < QMI_VOICE_REDIRECTING_PARTY_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->redirecting_party_num[j].call_id == qmi_call_id)
        {
          entry->voice_svc_redirecting_party_num = call_status_ind->redirecting_party_num[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_REDIRECTING_PARTY_NUM_VALID;
          break;
        }
      }
    }
    if (call_status_ind->audio_attrib_valid)
    {
      for (j = 0; (j < call_status_ind->audio_attrib_len &&
            j < QMI_VOICE_CALL_ATTRIBUTES_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->audio_attrib[j].call_id == qmi_call_id)
        {
          entry->voice_audio_attrib = call_status_ind->audio_attrib[j];
          entry->elaboration |=  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUDIO_ATTR_VALID;
          break;
        }
      }
    }
    if (call_status_ind->video_attrib_valid)
    {
      for (j = 0; (j < call_status_ind->video_attrib_len &&
            j < QMI_VOICE_CALL_ATTRIBUTES_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->video_attrib[j].call_id == qmi_call_id)
        {
          entry->voice_video_attrib = call_status_ind->video_attrib[j];
          entry->elaboration |=  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VIDEO_ATTR_VALID;
          break;
        }
      }
    }
    if (call_status_ind->call_attrib_status_valid)
    {
      for (j = 0; (j < call_status_ind->call_attrib_status_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->call_attrib_status[j].call_id == qmi_call_id)
        {
          entry->call_attrib_status = call_status_ind->call_attrib_status[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_ATTR_VALID;
          break;
        }
      }
    }
    if (call_status_ind->rtt_mode_valid)
    {
      for (j = 0; (j < call_status_ind->rtt_mode_len &&
            j < QMI_VOICE_RTT_MODE_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->rtt_mode[j].call_id == qmi_call_id)
        {
          entry->rtt_mode_valid = TRUE;
          entry->rtt_mode = call_status_ind->rtt_mode[j];
          break;
        }
      }
    }
    if (call_status_ind->rtt_capabilities_info_valid)
    {
      for (j = 0; (j < call_status_ind->rtt_capabilities_info_len  &&
            j < QMI_VOICE_RTT_MODE_ARRAY_MAX_V02); j++)
      {
        if ( call_status_ind->rtt_capabilities_info[j].call_id == qmi_call_id)
        {
          entry->rtt_capabilities_info_valid = TRUE;
          entry->rtt_capabilities_info = call_status_ind->rtt_capabilities_info[j];
          break;
        }
      }
    }
    if (call_status_ind->is_srvcc_valid)
    {
      for (j = 0; (j < call_status_ind->is_srvcc_len &&
            j < QMI_VOICE_IS_SRVCC_CALL_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->is_srvcc[j].call_id == qmi_call_id)
        {
          if (TRUE == call_status_ind->is_srvcc[j].is_srvcc_call)
          {
            entry->is_srvcc = call_status_ind->is_srvcc[j];
            entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID;
            entry->srvcc_in_progress = FALSE;
          }
          break;
        }
      }
    }

    entry->srvcc_parent_call_info_valid = FALSE;
    if (call_status_ind->srvcc_parent_call_info_valid)
    {
      for (j = 0; (j < call_status_ind->srvcc_parent_call_info_len &&
            j < QMI_VOICE_SRVCC_PARENT_CALL_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->srvcc_parent_call_info[j].call_id == qmi_call_id)
        {
          entry->srvcc_parent_call_info_valid = TRUE;
          entry->srvcc_parent_call_info = call_status_ind->srvcc_parent_call_info[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID;
          break;
        }
      }
    }

    /* In case of SRVCC as call type get modified to voice, reset voip mask */
    if ((entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_SRVCC_VALID) &&
        (entry->voice_scv_info.call_type == CALL_TYPE_VOICE_V02))
    {
      if (entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN)
      {
        entry->elaboration &= ~QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN;
        QCRIL_LOG_DEBUG("resetting the voip mask as call got modified to voice");
      }
    }

    if (call_status_ind->local_call_capabilities_info_valid)
    {
      for (j = 0; (j < call_status_ind->local_call_capabilities_info_len &&
            j < QMI_VOICE_CALL_CAPABILITIES_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->local_call_capabilities_info[j].call_id == qmi_call_id)
        {
          entry->local_call_capabilities_info = call_status_ind->local_call_capabilities_info[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LOCAL_CALL_CAPBILITIES_VALID;
          break;
        }
      }
    }
    if (call_status_ind->peer_call_capabilities_info_valid)
    {
      for (j = 0; (j < call_status_ind->peer_call_capabilities_info_len &&
            j < QMI_VOICE_CALL_CAPABILITIES_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->peer_call_capabilities_info[j].call_id == qmi_call_id)
        {
          entry->peer_call_capabilities_info = call_status_ind->peer_call_capabilities_info[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PEER_CALL_CAPBILITIES_VALID;
          break;
        }
      }
    }
    if (call_status_ind->child_number_valid)
    {
      for (j = 0; (j < call_status_ind->child_number_len &&
            j < QMI_VOICE_CHILD_NUMBER_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->child_number[j].call_id == qmi_call_id)
        {
          entry->child_number = call_status_ind->child_number[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_CHILD_NUMBER_VALID;
          break;
        }
      }
    }
    if (call_status_ind->display_text_valid)
    {
      for (j = 0; (j < call_status_ind->display_text_len &&
            j < QMI_VOICE_DISPLAY_TEXT_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->display_text[j].call_id == qmi_call_id)
        {
          entry->display_text = call_status_ind->display_text[j];
          entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_IS_DISPLAY_TEXT_VALID;
          break;
        }
      }
    }
    if (call_status_ind->is_add_info_present_valid)
    {
      for (j = 0; (j < call_status_ind->is_add_info_present_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->is_add_info_present[j].call_id == qmi_call_id)
        {
          entry->additional_call_info.is_add_info_present =
            call_status_ind->is_add_info_present[j].is_add_info_present;
          break;
        }
      }
    }
    if (call_status_ind->ip_caller_name_valid)
    {
      for (j = 0; (j < call_status_ind->ip_caller_name_len &&
            j < QMI_VOICE_IP_CALLER_NAME_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->ip_caller_name[j].call_id == qmi_call_id)
        {
          entry->ip_caller_name_valid = TRUE;
          entry->ip_caller_name = call_status_ind->ip_caller_name[j];
          break;
        }
      }
    }
    if (call_status_ind->end_reason_text_valid)
    {
      for (j = 0; (j < call_status_ind->end_reason_text_len &&
            j < QMI_VOICE_IP_END_REASON_TEXT_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->end_reason_text[j].call_id == qmi_call_id)
        {
          entry->end_reason_text_valid = TRUE;
          entry->end_reason_text = call_status_ind->end_reason_text[j];
          break;
        }
      }
    }
    if (call_status_ind->orig_fail_reason_valid)
    {
      for (j = 0; (j < call_status_ind->orig_fail_reason_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->orig_fail_reason[j].call_id == qmi_call_id)
        {
          entry->lcf_valid = TRUE;
          entry->lcf = CALL_FAIL_ERROR_UNSPECIFIED;
          snprintf(entry->lcf_extended_codes, MAX_DEC_INT_STR, "%d",
              call_status_ind->orig_fail_reason[j].orig_fail_reason);
          QCRIL_LOG_INFO(".. orig_fail_reason 0x%x",
              call_status_ind->orig_fail_reason[j].orig_fail_reason);
          break;
        }
      }
    }
    if (call_status_ind->is_secure_call_valid)
    {
      for (j = 0; (j < call_status_ind->is_secure_call_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->is_secure_call[j].call_id == qmi_call_id)
        {
          entry->is_secure_call = call_status_ind->is_secure_call[j].is_secure_call;
          break;
        }
      }
    }
    entry->is_called_party_ringing_valid = FALSE;
    if (call_status_ind->is_called_party_ringing_valid)
    {
      for (j = 0; (j < call_status_ind->is_called_party_ringing_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->is_called_party_ringing[j].call_id == qmi_call_id)
        {
          entry->is_called_party_ringing_valid = TRUE;
          entry->is_called_party_ringing = call_status_ind->is_called_party_ringing[j];
          QCRIL_LOG_INFO(".. is_called_party_ringing %d",
              call_status_ind->is_called_party_ringing[j].is_called_party_ringing);
          break;
        }
      }
    }
    if (call_status_ind->sip_error_code_valid)
    {
      for (j = 0; (j < call_status_ind->sip_error_code_len &&
            j < QMI_VOICE_IP_END_SIP_CODE_ARRAY_MAX_V02); j++)
      {
        if ( call_status_ind->sip_error_code[ j ].call_id == qmi_call_id )
        {
          //QCRIL_LOG_INFO("sip_error_code %d", call_status_ind->sip_error_code[ j ].sip_error_code);
          entry->sip_error_code_valid = TRUE;
          entry->sip_error_code = call_status_ind->sip_error_code[ j ];
          break;
        }
      }
    }
    if (call_status_ind->alternate_sip_uris_valid)
    {
      for (j = 0; (j < call_status_ind->alternate_sip_uris_len &&
            j < QMI_VOICE_ALTERNATE_SIP_URI_ARRAY_MAX_V02); j++)
      {
        if ( call_status_ind->alternate_sip_uris[j].call_id == qmi_call_id)
        {
          //QCRIL_LOG_INFO("alternate_sip_uri %s", call_status_ind->alternate_sip_uris[j].sip_uri);
          entry->alternate_sip_uri_valid = TRUE;
          entry->alternate_sip_uri = call_status_ind->alternate_sip_uris[j];
          break;
        }
      }
    }
    entry->history_info_valid = FALSE;
    if (call_status_ind->ip_hist_info_valid)
    {
      for (j = 0; (j < call_status_ind->ip_hist_info_len &&
            j < QMI_VOICE_IP_HIST_INFO_ARRAY_MAX_V02); j++)
      {
        if ( call_status_ind->ip_hist_info[j].call_id == qmi_call_id)
        {
          entry->history_info_valid = TRUE;
          entry->history_info = call_status_ind->ip_hist_info[j];
          break;
        }
      }
    }
    if (call_status_ind->remote_party_conf_capability_valid)
    {
      for (j = 0; (j < call_status_ind->remote_party_conf_capability_len &&
            j < QMI_VOICE_REMOTE_PARTY_CONF_CAP_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->remote_party_conf_capability[j].call_id == qmi_call_id)
        {
          entry->remote_party_conf_capability_valid = TRUE;
          entry->remote_party_conf_capability = call_status_ind->remote_party_conf_capability[j];
          //          QCRIL_LOG_INFO(".. remote_party_conf_capability->conf_is_enabled %d",
          //              call_status_ind->remote_party_conf_capability->conf_is_enabled);
          break;
        }
      }
    }
    if (call_status_ind->media_id_valid)
    {
      for (j = 0; (j < call_status_ind->media_id_len &&
            j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->media_id[j].call_id == qmi_call_id)
        {
          entry->media_id = call_status_ind->media_id[j].media_id;
          break;
        }
      }
    }

    entry->has_verstat_info = false;
    if (call_status_ind->mt_call_verstat_valid == 1)
    {
      unsigned n_calls = call_status_ind->mt_call_verstat_len;
      for (j = 0; (j < n_calls && j < QMI_VOICE_CALL_INFO_MAX_V02); j++)
      {
        if (call_status_ind->mt_call_verstat[j].call_id == qmi_call_id)
        {
          entry->has_verstat_info = true;
          entry->verstat_info = call_status_ind->mt_call_verstat[j].
                  verstat_info;
          break;
        }
      }
    }

    //Terminating number for MT calls only
    entry->terminating_num_valid = false;
    entry->is_secondary = false;
    if(call_status_ind->terminating_num_valid == 1) {
      unsigned n_calls = call_status_ind->terminating_num_len;
      for (j = 0; (j < n_calls && j < QMI_VOICE_TERMINATING_ARRAY_MAX_V02); j++)
      {
        if (call_status_ind->terminating_num[j].call_id == qmi_call_id)
        {
          int length = strlen(call_status_ind->terminating_num[j].num);
          entry->terminating_num = (char*)qcril_malloc(length + 1);
          if (NULL == entry->terminating_num) {
            QCRIL_LOG_ERROR("malloc failed for entry->terminating_num[call id = %d]", qmi_call_id);
            break;
          }
          strlcpy(entry->terminating_num, call_status_ind->terminating_num[j].num, length + 1);
          //Assumption : there can be only one secondary call supported
          entry->terminating_num_valid = true;
          if (call_status_ind->is_secondary_valid) {
              entry->is_secondary = call_status_ind->is_secondary;
          }
        }
      }
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_voip_update_call_info_entry_mainstream
//===========================================================================
// qcril_qmi_voice_voip_update_call_info_uus
//===========================================================================
void qcril_qmi_voice_voip_update_call_info_uus(qcril_qmi_voice_voip_call_info_entry_type* entry,
                                               uus_type_enum_v02 uus_type,
                                               uus_dcs_enum_v02 uus_dcs,
                                               uint32_t uus_data_len,
                                               uint8_t *uus_data
                                                 )
{
  QCRIL_LOG_INFO( "param %p", entry );
  if ( entry )
  {
    entry->voice_svc_uus.uus_type = uus_type;
    entry->voice_svc_uus.uus_dcs  = uus_dcs;
    entry->voice_svc_uus.uus_data_len  = uus_data_len;
    memcpy( entry->voice_svc_uus.uus_data, uus_data, MIN( QMI_VOICE_UUS_DATA_MAX_V02, uus_data_len ) );
    entry->voice_svc_uus.uus_data_len  = uus_data_len;

    entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_UUS_VALID;
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_voip_update_call_info_uus

//===========================================================================
// qcril_qmi_voice_voip_lock_overview
//===========================================================================
void qcril_qmi_voice_voip_lock_overview()
{
  pthread_mutex_lock( &qmi_voice_voip_overview.overview_lock_mutex );
} // qcril_qmi_voice_voip_lock_overview
//===========================================================================
// qcril_qmi_voice_voip_unlock_overview
//===========================================================================
void qcril_qmi_voice_voip_unlock_overview()
{
  pthread_mutex_unlock( &qmi_voice_voip_overview.overview_lock_mutex );
} // qcril_qmi_voice_voip_unlock_overview
//===========================================================================
// qcril_qmi_voice_voip_mark_all_with
//===========================================================================
void qcril_qmi_voice_voip_mark_all_with(qcril_qmi_voice_voip_call_info_elaboration_type elaboration_set)
{
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;

  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL  )
  {
    iter->elaboration |= elaboration_set;
    iter = iter->next;
  }
} // qcril_qmi_voice_voip_mark_all_with
//===========================================================================
// qcril_qmi_voice_voip_unmark_all_with
//===========================================================================
void qcril_qmi_voice_voip_unmark_all_with(qcril_qmi_voice_voip_call_info_elaboration_type elaboration_set)
{
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;
  qcril_qmi_voice_voip_call_info_elaboration_type application_set;

  application_set = ~elaboration_set;
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL  )
  {
    iter->elaboration &= application_set;
    iter = iter->next;
  }
} // qcril_qmi_voice_voip_unmark_all_with

//===========================================================================
// qcril_qmi_voice_voip_unmark_with_specified_call_state
//===========================================================================
void qcril_qmi_voice_voip_unmark_with_specified_call_state
(
  qcril_qmi_voice_voip_call_info_elaboration_type elaboration_set,
  call_state_enum_v02 state
)
{
  qcril_qmi_voice_voip_call_info_entry_type* iter = NULL;
  qcril_qmi_voice_voip_call_info_elaboration_type application_set;

  application_set = ~elaboration_set;
  iter = qmi_voice_voip_overview.call_info_root;
  while ( iter != NULL  )
  {
    if ( state == iter->voice_scv_info.call_state )
    {
      iter->elaboration &= application_set;
    }
    iter = iter->next;
  }
} // qcril_qmi_voice_voip_unmark_with_specified_call_state

//===========================================================================
// qcril_qmi_voice_voip_mark_with_specified_call_state
//===========================================================================
void qcril_qmi_voice_voip_mark_with_specified_call_state
(
  qcril_qmi_voice_voip_call_info_elaboration_type elaboration_set,
  call_state_enum_v02 state
)
{
  qcril_qmi_voice_voip_call_info_entry_type* iter = qmi_voice_voip_overview.call_info_root;

  while ( iter != NULL  )
  {
    if ( state == iter->voice_scv_info.call_state )
    {
      iter->elaboration |= elaboration_set;
    }
    iter = iter->next;
  }
} // qcril_qmi_voice_voip_mark_with_specified_call_state

//===========================================================================
// qcril_qmi_voice_voip_call_info_entries_is_empty
//===========================================================================
boolean qcril_qmi_voice_voip_call_info_entries_is_empty(void)
{
  return !qmi_voice_voip_overview.call_info_root;
} // qcril_qmi_voice_voip_call_info_entries_is_empty

//===========================================================================
// qcril_qmi_voice_voip_call_info_entries_enum_first
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_call_info_entries_enum_first(void)
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;

  res = qmi_voice_voip_overview.call_info_root;
  qmi_voice_voip_overview.call_info_enumeration_current = res;

  return res;
} //
//===========================================================================
// qcril_qmi_voice_voip_call_info_entries_enum_next
//===========================================================================
qcril_qmi_voice_voip_call_info_entry_type* qcril_qmi_voice_voip_call_info_entries_enum_next(void)
{
  qcril_qmi_voice_voip_call_info_entry_type* res = NULL;

  res = NULL;

  if ( NULL != qmi_voice_voip_overview.call_info_enumeration_current )
  {
    res = qmi_voice_voip_overview.call_info_enumeration_current->next;
    qmi_voice_voip_overview.call_info_enumeration_current = res;
  }

  return res;
}
//===========================================================================
// qcril_qmi_voice_voip_generate_summary
//===========================================================================
void qcril_qmi_voice_voip_generate_summary( qcril_qmi_voice_voip_current_call_summary_type * summary )
{
  qcril_qmi_voice_voip_call_info_entry_type * call_info_entry = NULL;

  int nof_3gpp2_calls;
  int nof_3gpp_calls;
  int nof_active_calls;
  int nof_voip_calls;
  int nof_calls;

  if ( summary )
  {
    memset( summary, 0, sizeof( *summary ) );

    nof_3gpp2_calls  = 0;
    nof_3gpp_calls   = 0;
    nof_active_calls = 0;
    nof_voip_calls   = 0;
    nof_calls        = 0;

    call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
    while ( NULL != call_info_entry )
    {
      if ((VOICE_INVALID_CALL_ID != call_info_entry->android_call_id) &&
          ((VOICE_INVALID_CALL_ID != call_info_entry->qmi_call_id) ||
            (call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NO_QMI_ID_RECEIVED)))
      {
        // skip shadow calls from CM space
        nof_calls++;
        if ( call_info_entry->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN )
        {
          nof_voip_calls++;
        }
        else if ( CALL_MODE_CDMA_V02 == call_info_entry->voice_scv_info.mode )
        {
          nof_3gpp2_calls++;
        }
        else
        {
          nof_3gpp_calls++;
        }

        if ( CALL_STATE_CONVERSATION_V02 == call_info_entry->voice_scv_info.call_state )
        {
          nof_active_calls++;
        }
        summary->active_or_single_call = call_info_entry;
      }
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
    }

    summary->nof_calls_overall      = nof_calls;
    summary->nof_voip_calls         = nof_voip_calls;
    summary->nof_3gpp2_calls        = nof_3gpp2_calls;
    summary->nof_3gpp_calls         = nof_3gpp_calls;
    summary->nof_active_calls       = nof_active_calls;
    summary->nof_voice_calls        = nof_3gpp2_calls + nof_3gpp_calls;
  }
} // qcril_qmi_voice_voip_generate_summary

//===========================================================================
// qcril_qmi_voice_voip_call_info_dump
//===========================================================================
void qcril_qmi_voice_voip_call_info_dump(qcril_qmi_voice_voip_call_info_entry_type* call_info_entry)
{
  QCRIL_LOG_INFO( "param %p", call_info_entry );
  if ( call_info_entry )
  {
    QCRIL_LOG_DEBUG( ".. call android id %d, call qmi id %d, elaboration %x, %x hex",
        (int)call_info_entry->android_call_id,
        (int)call_info_entry->qmi_call_id,
        (uint32) (call_info_entry->elaboration >> 32), (uint32)call_info_entry->elaboration);
    QCRIL_LOG_DEBUG( ".. call state %d, call type %d, call mode %d",
        (int)call_info_entry->voice_scv_info.call_state,
        (int)call_info_entry->voice_scv_info.call_type,
        (int)call_info_entry->voice_scv_info.mode );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_voip_call_info_dump

//===========================================================================
// qcril_qmi_voice_request_set_local_call_hold
//===========================================================================^M
void qcril_qmi_voice_request_set_local_call_hold
(
const qcril_request_params_type *const params_ptr,
qcril_request_return_type *const ret_ptr
)
{
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  voice_manage_calls_req_msg_v02  manage_calls_req;
  RIL_Errno   ril_req_res = RIL_E_SUCCESS;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  int lch = 0;
  uint32 user_data;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  do
  {
    if ( NULL == params_ptr->data )
    {
      QCRIL_LOG_ERROR(".. invalid param");
      ril_req_res = RIL_E_GENERIC_FAILURE;
      break;
    }
    lch = *(( int *) params_ptr->data);
    memset(&manage_calls_req, 0, sizeof(manage_calls_req));
    manage_calls_req.sups_type = lch ? SUPS_TYPE_LOCAL_HOLD_V02 : SUPS_TYPE_LOCAL_UNHOLD_V02;
    QCRIL_LOG_DEBUG("lch = %d, sups type %d", lch, (int) manage_calls_req.sups_type );
    manage_calls_req.call_id_valid = FALSE;

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 (qcril_req_state_e_type)(QCRIL_REQ_AWAITING_CALLBACK|
                                  QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS),
                                 QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD,
                                 NULL,
                                 &reqlist_entry );

    if (lch == TRUE)
    {
      reqlist_entry.req_datalen = sizeof (lch);
      reqlist_entry.req_data = (void *)&lch;
    }

    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) == E_SUCCESS )
    {
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

      /* Send QMI VOICE MANAGE CALLS REQ */
      qmi_client_error_type error = qmi_client_voice_send_async(
                                      QMI_VOICE_MANAGE_CALLS_REQ_V02,
                                      &manage_calls_req,
                                      sizeof(manage_calls_req),
                                      sizeof(voice_manage_calls_resp_msg_v02),
                                      qcril_qmi_voice_command_cb,
                                      (void*)(uintptr_t)user_data);
      if ( QMI_NO_ERR != error )
      {
        QCRIL_LOG_DEBUG("send_msg_async failed with error code: %d", error);
        ril_req_res = RIL_E_GENERIC_FAILURE;
      }
    }
    else
    {
      QCRIL_LOG_INFO("the new request is rejected");
      ril_req_res = RIL_E_GENERIC_FAILURE;
    }
  } while (FALSE);

  if ( RIL_E_SUCCESS != ril_req_res )
  { // failure
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
#ifndef QMI_RIL_UTF
    qcril_am_handle_event(lch ? QCRIL_AM_EVENT_LCH : QCRIL_AM_EVENT_UNLCH, NULL);
#endif
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_request_set_local_call_hold

//===========================================================================
// qmi_ril_voice_drop_homeless_incall_reqs
//===========================================================================
void qmi_ril_voice_drop_homeless_incall_reqs( void )
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                        QCRIL_DEFAULT_MODEM_ID,
                        qmi_ril_voice_drop_homeless_incall_reqs_main_threaded,
                        NULL,  // immediate
                        NULL );

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_drop_homeless_incall_reqs
//===========================================================================
// qmi_ril_voice_drop_homeless_incall_reqs_main_threaded
//===========================================================================
void qmi_ril_voice_drop_homeless_incall_reqs_main_threaded(void *param)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(param);

  auto restriction = PolicyManager::getInstance().getMessageRestriction(
      QCRIL_MAKE_ANDROID_REQ_MSG_NAME_EX(RIL_REQUEST_DTMF));
  restriction->abandonPendingMessages();

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_drop_homeless_incall_reqs_main_threaded
//===========================================================================
// qmi_ril_voice_cleanup_reqs_after_call_completion
//===========================================================================
void qmi_ril_voice_cleanup_reqs_after_call_completion(void)
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                        QCRIL_DEFAULT_MODEM_ID,
                        qmi_ril_voice_cleanup_reqs_after_call_completion_main_threaded,
                        NULL,  // immediate
                        NULL );

  QCRIL_LOG_FUNC_RETURN();

} // qmi_ril_voice_cleanup_reqs_after_call_completion
//===========================================================================
// qmi_ril_voice_cleanup_reqs_after_call_completion_main_threaded
//===========================================================================
void qmi_ril_voice_cleanup_reqs_after_call_completion_main_threaded(void *param)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(param);

  auto restriction = PolicyManager::getInstance().getMessageRestriction(
      QCRIL_MAKE_ANDROID_REQ_MSG_NAME_EX(RIL_REQUEST_DTMF));
  restriction->abandonPendingMessages();

  restriction = PolicyManager::getInstance().getMessageRestriction(
      QCRIL_MAKE_ANDROID_REQ_MSG_NAME_EX(RIL_REQUEST_CONFERENCE));
  restriction->abandonPendingMessages();

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_cleanup_reqs_after_call_completion_main_threaded

/*===========================================================================

  FUNCTION: qcril_qmi_voice_get_modem_call_type_info

===========================================================================*/
/*!
    @brief
    fetch modem call type information from android telephony information.

    @return
    TRUE, if call type can be derived.
    FALSE, otherwise.
*/
/*=========================================================================*/
boolean qcril_qmi_voice_get_modem_call_type_info
(
 ims_CallType                          ril_callType,
 ims_CallDomain                        ril_callDomain,
 boolean                                is_emergency_ip,
 call_type_enum_v02                    *call_type,
 uint8_t                               *audio_attrib_valid,
 voice_call_attribute_type_mask_v02    *audio_attrib,
 uint8_t                               *video_attrib_valid,
 voice_call_attribute_type_mask_v02    *video_attrib
)
{
  boolean result = TRUE;

  if (call_type == NULL )
  {
    result = FALSE;
    return result;
  }

  switch (ril_callType)
  {
    case RIL_CALL_TYPE_VOICE:
      if ((RIL_Call_Domain) ril_callDomain == RIL_CALL_DOMAIN_PS)
      {
        *call_type = (is_emergency_ip ? CALL_TYPE_EMERGENCY_IP_V02 : CALL_TYPE_VOICE_IP_V02);
      }
      else
      {
        *call_type = CALL_TYPE_VOICE_V02;
      }

      if (audio_attrib_valid != NULL && audio_attrib != NULL)
      {
        *audio_attrib_valid = TRUE;
        *audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);
      }

      if (video_attrib_valid != NULL && video_attrib != NULL)
      {
        *video_attrib_valid = TRUE;
        *video_attrib = 0;
      }
      break;

    case RIL_CALL_TYPE_VS_RX:
      /* Video is receive only */
      if ((RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_PS ||
          (RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_AUTOMATIC)
      {
        if (audio_attrib_valid == NULL || audio_attrib == NULL ||
            video_attrib_valid == NULL || video_attrib == NULL)
        {
          result = FALSE;
        }
        else
        {
          *audio_attrib_valid = TRUE;
          *audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);
          *video_attrib_valid = TRUE;
          *video_attrib = VOICE_CALL_ATTRIB_RX_V02;
          *call_type = (is_emergency_ip ? CALL_TYPE_EMERGENCY_VT_V02 : CALL_TYPE_VT_V02);
        }
      }
      else
      {
        /* other domain values are not supported currently */
        result = FALSE;
      }
      break;

    case RIL_CALL_TYPE_VS_TX:
      /* Video is transmit only */
      if ((RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_PS ||
          (RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_AUTOMATIC)
      {
        if (audio_attrib_valid == NULL || audio_attrib == NULL ||
            video_attrib_valid == NULL || video_attrib == NULL)
        {
          result = FALSE;
        }
        else
        {
          *audio_attrib_valid = TRUE;
          *audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);
          *video_attrib_valid = TRUE;
          *video_attrib = VOICE_CALL_ATTRIB_TX_V02;
          *call_type = (is_emergency_ip ? CALL_TYPE_EMERGENCY_VT_V02 : CALL_TYPE_VT_V02);
        }
      }
      else
      {
        /* other domain values are not supported currently */
        result = FALSE;
      }
      break;

    case RIL_CALL_TYPE_VT:
      /* Video is transmit only */
      if ((RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_PS ||
          (RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_AUTOMATIC)
      {
        if (audio_attrib_valid == NULL || audio_attrib == NULL ||
            video_attrib_valid == NULL || video_attrib == NULL)
        {
          result = FALSE;
        }
        else
        {
          *audio_attrib_valid = TRUE;
          *audio_attrib = VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
          *video_attrib_valid = TRUE;
          *video_attrib = VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
          *call_type = (is_emergency_ip ? CALL_TYPE_EMERGENCY_VT_V02 : CALL_TYPE_VT_V02);
        }
      }
      else
      {
        /* other domain values are not supported currently */
        result = FALSE;
      }
      break;

    case RIL_CALL_TYPE_VT_NODIR:
      if ((RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_PS ||
          (RIL_Call_Domain)ril_callDomain == RIL_CALL_DOMAIN_AUTOMATIC)
      {
        if (audio_attrib_valid == NULL || audio_attrib == NULL ||
            video_attrib_valid == NULL || video_attrib == NULL)
        {
          result = FALSE;
        }
        else
        {
          *audio_attrib_valid = TRUE;
          *audio_attrib = VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02;
          *video_attrib_valid = TRUE;
          *video_attrib = 0;
          *call_type = (is_emergency_ip ? CALL_TYPE_EMERGENCY_VT_V02 : CALL_TYPE_VT_V02);
        }
      }
      break;

    default:
      result = FALSE;
      break;
  }

  QCRIL_LOG_DEBUG("result = %d, modem call type = %d, ril call type = %d, ril call domain = %d",
      result, *call_type, ril_callType, ril_callDomain);

  if ((audio_attrib != NULL) && (audio_attrib_valid != NULL))
  {
    QCRIL_LOG_DEBUG("audio_attrib_valid = %d, audio_attrib = %d",
        *audio_attrib_valid, *audio_attrib);
  }

  if ((video_attrib != NULL) && (video_attrib_valid != NULL))
  {
    QCRIL_LOG_DEBUG(" video_attrib_valid = %d, video_attrib = %d",
        *video_attrib_valid, *video_attrib);
  }

  return result;
}

/*===========================================================================

  FUNCTION: qcril_qmi_voice_get_atel_call_type_info_by_call_info

===========================================================================*/
/*!
    @brief
    fetch RIL call type information from an call info entry.

    @return
    TRUE, if call type can be derived.
    FALSE, otherwise.
*/
/*=========================================================================*/
boolean qcril_qmi_voice_get_atel_call_type_info_by_call_info
(
   const qcril_qmi_voice_voip_call_info_entry_type *call_info,
   RIL_Call_Details *call_details
)
{
   boolean ret;
   call_type_enum_v02 call_type;
   boolean video_attrib_valid;
   voice_call_attribute_type_mask_v02 video_attrib;
   boolean audio_attrib_valid;
   voice_call_attribute_type_mask_v02 audio_attrib;
   boolean attrib_status_valid;
   voice_call_attrib_status_enum_v02 attrib_status;
   qcril_qmi_voice_voip_call_info_elaboration_type call_info_elab;

   if ( NULL == call_info )
   {
      QCRIL_LOG_ERROR("call_info is NULL");
      ret = FALSE;
   }
   else
   {
      call_type = call_info->voice_scv_info.call_type;
      video_attrib_valid = (call_info->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_VIDEO_ATTR_VALID) ? TRUE : FALSE;
      video_attrib = call_info->voice_video_attrib.call_attributes;
      audio_attrib_valid = (call_info->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUDIO_ATTR_VALID) ? TRUE : FALSE;
      audio_attrib = call_info->voice_audio_attrib.call_attributes;
      attrib_status_valid = (call_info->elaboration &
              QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_ATTR_VALID) ? TRUE: FALSE;
      attrib_status = call_info->call_attrib_status.call_attrib_status;
      call_info_elab = call_info->elaboration;
      ret = qcril_qmi_voice_get_atel_call_type_info(call_type, video_attrib_valid, video_attrib,
          audio_attrib_valid, audio_attrib,
          attrib_status_valid, attrib_status,
          TRUE, call_info_elab,
          call_info->answered_call_type_valid, call_info->answered_call_type,
          call_details);
   }

   return ret;
} // qcril_qmi_voice_get_atel_call_type_info_by_call_info

/*===========================================================================

  FUNCTION: qcril_qmi_voice_get_atel_call_type_info

===========================================================================*/
/*!
    @brief
    fetch RIL call type information from call type, video attribute (if available)
    audio attribute (if available) and call elaboration (if available).

    @return
    TRUE, if call type can be derived.
    FALSE, otherwise.
*/
/*=========================================================================*/
boolean qcril_qmi_voice_get_atel_call_type_info
(
 call_type_enum_v02 call_type,
 boolean video_attrib_valid,
 voice_call_attribute_type_mask_v02 video_attrib,
 boolean audio_attrib_valid,
 voice_call_attribute_type_mask_v02 audio_attrib,
 boolean attrib_status_valid,
 voice_call_attrib_status_enum_v02 attrib_status,
 boolean call_info_elab_valid,
 qcril_qmi_voice_voip_call_info_elaboration_type call_info_elab,
 boolean cached_call_type_valid,
 ims_CallType cached_call_type,
 RIL_Call_Details *call_details
)
{
  QCRIL_LOG_FUNC_ENTRY();
  boolean ret = TRUE;

  if (NULL == call_details)
  {
    QCRIL_LOG_ERROR("call_details is NULL ");
    ret = FALSE;
  }
  else
  {
    QCRIL_LOG_INFO( "QMI call_type: %d, video_attrib_valid: %d, video_attrib: %d, "
        "audio_attrib_valid: %d, audio_attrib: %d, "
        "call_attrib_valid: %d, call_attrib:%d, "
        "call_info_elab_valid: %d, elaboration %x, %x hex",
        call_type, video_attrib_valid, (int)video_attrib,
        audio_attrib_valid, audio_attrib,
        attrib_status_valid, attrib_status,
        call_info_elab_valid,
        (uint32)(call_info_elab >> 32), (uint32)call_info_elab );

    call_details->callSubState = RIL_CALL_SUB_STATE_UNDEFINED;

    if ((CALL_TYPE_VT_V02 == call_type) || (CALL_TYPE_EMERGENCY_VT_V02 == call_type))
    {
      if (FALSE == video_attrib_valid)
      {
        call_details->callType = RIL_CALL_TYPE_VT;
        call_details->callDomain = RIL_CALL_DOMAIN_PS;
      }
      else
      {
        /* based on call attributes determine video call type */
        if (VOICE_CALL_ATTRIB_TX_V02 == video_attrib)
        {
          call_details->callType = RIL_CALL_TYPE_VS_TX;
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
        }
        else if (VOICE_CALL_ATTRIB_RX_V02 == video_attrib)
        {
          call_details->callType = RIL_CALL_TYPE_VS_RX;
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
        }
        else if ((VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02) == video_attrib)
        {
          call_details->callType = RIL_CALL_TYPE_VT;
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
        }
        else if (TRUE == audio_attrib_valid && 0 == audio_attrib && 0 == video_attrib)
        {
          call_details->callSubState =
            (RIL_Call_Sub_State)(RIL_CALL_SUB_STATE_AUDIO_CONNECTED_SUSPENDED |
                RIL_CALL_SUB_STATE_VIDEO_CONNECTED_SUSPENDED);
          call_details->callType = cached_call_type_valid ?
            (RIL_Call_Type) cached_call_type : RIL_CALL_TYPE_VT;
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
        }
        else if (0 == video_attrib && attrib_status_valid == TRUE)
        {
          call_details->callType = RIL_CALL_TYPE_VT_NODIR;
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
          switch (attrib_status)
          {
            case VOICE_CALL_ATTRIB_STATUS_RETRY_NEEDED_V02:
              call_details->callSubState = RIL_CALL_SUB_STATE_AVP_RETRY;
              break;
            case VOICE_CALL_ATTRIB_STATUS_MEDIA_PAUSED_V02:
              call_details->callSubState = RIL_CALL_SUB_STATE_MEDIA_PAUSED;
              break;
            case VOICE_CALL_ATTRIB_STATUS_OK_V02:
              call_details->callSubState = RIL_CALL_SUB_STATE_UNDEFINED;
              break;
            default:
              break;
          }
        }
        else
        {
          ret = FALSE;
        }
      }
      if (call_type == CALL_TYPE_EMERGENCY_VT_V02 &&
          call_info_elab & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN)
      {
        call_details->callDomain = RIL_CALL_DOMAIN_AUTOMATIC;
      }
    }
    else // not a VT call
    {
      call_details->callType = RIL_CALL_TYPE_VOICE;
      if (TRUE == audio_attrib_valid && 0 == audio_attrib)
      {
        call_details->callSubState = RIL_CALL_SUB_STATE_AUDIO_CONNECTED_SUSPENDED;
      }

      boolean call_domain_set = FALSE;
      if (call_info_elab_valid)
      {
        call_domain_set = TRUE;
        if (call_info_elab & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN)
        {
          call_details->callDomain = RIL_CALL_DOMAIN_CS;
        }
        else if (call_info_elab & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PS_DOMAIN)
        {
          call_details->callDomain = RIL_CALL_DOMAIN_PS;
        }
        else if (call_info_elab & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_AUTO_DOMAIN)
        {
          call_details->callDomain = RIL_CALL_DOMAIN_AUTOMATIC;
        }
        else
        {
          QCRIL_LOG_DEBUG("did not set call domain in elaboration.");
          call_domain_set = FALSE;
        }
      }
      if (!call_domain_set)
      {
        switch (call_type)
        {
          case CALL_TYPE_EMERGENCY_IP_V02:
          case CALL_TYPE_VOICE_IP_V02:
            call_details->callDomain = RIL_CALL_DOMAIN_PS;
            break;

          default:
            /* fall back to default voice case */
            call_details->callDomain = RIL_CALL_DOMAIN_CS;
            break;
        }
      }
    } // end of "not a VT call"

    QCRIL_LOG_DEBUG("ril call type = %d, ril call domain = %d, call sub state = %d",
        call_details->callType, call_details->callDomain, call_details->callSubState);
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ret);
  return ret;
} // qcril_qmi_voice_get_atel_call_type_info

/*===========================================================================

  FUNCTION: qcril_qmi_voice_match_modem_call_type

===========================================================================*/
/*!
    @brief
    compare the modem call types provided.

    @return
    TRUE, if call type has matched.
    FALSE, otherwise.
*/
/*=========================================================================*/
boolean qcril_qmi_voice_match_modem_call_type
(
   call_type_enum_v02                    call_type1,
   uint8_t                               audio_attrib_valid1,
   voice_call_attribute_type_mask_v02    audio_attrib1,
   uint8_t                               video_attrib_valid1,
   voice_call_attribute_type_mask_v02    video_attrib1,
   uint8_t                               rtt_mode_valid1,
   rtt_mode_type_v02                     rtt_mode1,
   call_type_enum_v02                    call_type2,
   uint8_t                               audio_attrib_valid2,
   voice_call_attribute_type_mask_v02    audio_attrib2,
   uint8_t                               video_attrib_valid2,
   voice_call_attribute_type_mask_v02    video_attrib2,
   uint8_t                               rtt_mode_valid2,
   rtt_mode_type_v02                     rtt_mode2
)
{
   boolean result;

   QCRIL_LOG_DEBUG( "call_type1 = %d, audio_attrrib valid/value = %d/%d, video_attrib valid/value = %d/%d",
                    call_type1, audio_attrib_valid1, (int)audio_attrib1, video_attrib_valid1, (int)video_attrib1);

   QCRIL_LOG_DEBUG( "call_type2 = %d, audio_attrrib valid/value = %d/%d, video_attrib valid/value = %d/%d",
                    call_type2, audio_attrib_valid2, (int)audio_attrib2, video_attrib_valid2, (int)video_attrib2);

   if ( ( call_type1 == call_type2 ) &&
        ( ( ( rtt_mode_valid1 == TRUE ) && ( rtt_mode_valid2 == TRUE ) &&
            ( rtt_mode1 == rtt_mode2 ) ) ||
          ( ( rtt_mode_valid1 == FALSE ) && ( rtt_mode_valid2 == FALSE ) )
        )
      )
   {
      if ( CALL_TYPE_VT_V02 == call_type1 || // only check video/audio attribute for VT
           CALL_TYPE_EMERGENCY_VT_V02 == call_type1 )
      {
         if ( ( audio_attrib_valid1 == audio_attrib_valid2 ) &&
              ( ( audio_attrib_valid1 && audio_attrib1 == audio_attrib2 ) || ! audio_attrib_valid1 ) &&
              ( video_attrib_valid1 == video_attrib_valid2 ) &&
              ( ( video_attrib_valid1 && video_attrib1 == video_attrib2 ) || ! video_attrib_valid1 )
            )
         {
            result = TRUE;
         }
         else
         {
            result = FALSE;
         }
      }
      else
      {
         result = TRUE;
      }
   }
   else
   {
      result = FALSE;
   }

   QCRIL_LOG_FUNC_RETURN_WITH_RET(result);

   return result;
}

//===========================================================================
// qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl
//===========================================================================
void qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl( void )
{
    qcril_qmi_voice_voip_call_info_entry_type* call_info = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    call_info = qcril_qmi_voice_voip_call_info_entries_enum_first();
    while ( NULL != call_info )
    {
      if ( VOICE_INVALID_CALL_ID != call_info->android_call_id &&
           CALL_STATE_END_V02 == call_info->voice_scv_info.call_state &&
           call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CALL_ENDED_REPORTED &&
           call_info->elaboration & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_LAST_CALL_FAILURE_REPORTED
         )
      {
        qcril_qmi_voice_voip_destroy_call_info_entry( call_info);
      }

      call_info = qcril_qmi_voice_voip_call_info_entries_enum_next();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_evaluate_voice_call_obj_cleanup_vcl

//===========================================================================
// qcril_qmi_voice_handle_audio_pd_state_changed
//===========================================================================
void qcril_qmi_voice_handle_audio_pd_state_changed
(
   qcril_qmi_pd_entry *entry,
   qcril_qmi_pd_state state,
   void *userdata)
{
   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(entry);
   QCRIL_NOTUSED(userdata);
   qcril_qmi_voice_voip_lock_overview();
   qcril_qmi_voice_info.pd_info.state = state;
   qcril_qmi_voice_update_audio_state_vcl();
   qcril_qmi_voice_voip_unlock_overview();
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_handle_pil_state_changed

//===========================================================================
// qcril_qmi_voice_handle_pil_state_changed
//===========================================================================
void qcril_qmi_voice_handle_pil_state_changed(const qcril_qmi_pil_state* cur_state)
{
   QCRIL_LOG_FUNC_ENTRY();
   qcril_qmi_voice_voip_lock_overview();
   qcril_qmi_voice_info.pil_state.state = cur_state->state;
   qcril_qmi_voice_update_audio_state_vcl();
   qcril_qmi_voice_voip_unlock_overview();
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_handle_pil_state_changed


boolean qmi_ril_voice_is_audio_inactive_vcl()
{
  QCRIL_LOG_FUNC_ENTRY();
  boolean ret = qcril_qmi_voice_info.audio_info.state != QCRIL_QMI_AUDIO_STATE_UP;
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
}

boolean qmi_ril_voice_is_calls_supressed_by_audio_pd_vcl(void)
{
  boolean ret;
  QCRIL_LOG_FUNC_ENTRY();
  ret = qcril_qmi_voice_info.pd_info.state != QCRIL_QMI_PD_UP &&
        qcril_qmi_voice_info.pd_info.state != QCRIL_QMI_PD_UNUSED;
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
}

void qcril_qmi_voice_update_audio_state_vcl(void)
{
   bool audio_active;
   QCRIL_LOG_FUNC_ENTRY();
   audio_active = TRUE;
   audio_active &= !qmi_ril_voice_is_calls_supressed_by_pil_vcl();
   audio_active &= !qmi_ril_voice_is_calls_supressed_by_audio_pd_vcl();

   qcril_qmi_voice_info.audio_info.state = audio_active ?
           QCRIL_QMI_AUDIO_STATE_UP :
           QCRIL_QMI_AUDIO_STATE_DOWN;

   if (qmi_ril_voice_is_audio_inactive_vcl())
   {
      qcril_qmi_voice_hangup_all_non_emergency_calls_vcl();
   }

   QCRIL_LOG_FUNC_RETURN();
}

boolean qcril_qmi_voice_is_emergency_call(const qcril_qmi_voice_voip_call_info_entry_type* call)
{
    return call && qcril_qmi_voice_is_qmi_call_emergency(&call->voice_scv_info);
}

//===========================================================================
// qcril_qmi_voice_hangup_all_non_emergency_calls_vcl
//===========================================================================
void qcril_qmi_voice_hangup_all_non_emergency_calls_vcl()
{
    qcril_qmi_voice_hangup_all_calls_vcl(qcril_qmi_voice_is_emergency_call, TRUE);
} // qcril_qmi_voice_hangup_all_non_emergency_calls_vcl

//===========================================================================
// qcril_qmi_voice_hangup_all_calls_vcl
//===========================================================================
void qcril_qmi_voice_hangup_all_calls_vcl(boolean (*exception_filter)(const qcril_qmi_voice_voip_call_info_entry_type*), boolean qmi_async)
{
   qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
   voice_end_call_req_msg_v02   call_end_req_msg;

   QCRIL_LOG_FUNC_ENTRY();

   call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_first();
   while (NULL != call_info_entry)
   {
      if ( CALL_STATE_DISCONNECTING_V02 != call_info_entry->voice_scv_info.call_state &&
           CALL_STATE_END_V02 != call_info_entry->voice_scv_info.call_state )
      {
         if (exception_filter && exception_filter(call_info_entry))
         {
            call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
            continue;
         }

         memset(&call_end_req_msg, 0, sizeof(call_end_req_msg));
         call_end_req_msg.call_id = call_info_entry->qmi_call_id;
         QCRIL_LOG_INFO("end call with qmi id %d", call_end_req_msg.call_id);
         if (qmi_async)
         {
           qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                       QMI_VOICE_END_CALL_REQ_V02,
                                       &call_end_req_msg,
                                       sizeof(voice_end_call_req_msg_v02),
                                       sizeof(voice_end_call_resp_msg_v02),
                                       qcril_qmi_voice_command_cb,
                                       nullptr);
           QCRIL_LOG_INFO("end call QMI send returns: %d", qmi_client_error);
         }
         else
         {
           voice_end_call_resp_msg_v02 call_end_resp_msg;
           qmi_client_error_type qmi_client_error = get_voice_modem_endpoint()->sendRawSync(
                                       QMI_VOICE_END_CALL_REQ_V02,
                                       &call_end_req_msg,
                                       sizeof(voice_end_call_req_msg_v02),
                                       &call_end_resp_msg,
                                       sizeof(voice_end_call_resp_msg_v02));
           QCRIL_LOG_INFO("end call QMI send returns: %d", qmi_client_error);
         }
      }
      call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
   }
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_hangup_all_calls_vcl

//===========================================================================
// qmi_ril_voice_is_calls_supressed_by_pil_vcl
//===========================================================================
boolean qmi_ril_voice_is_calls_supressed_by_pil_vcl()
{
   QCRIL_LOG_FUNC_ENTRY();
   boolean ret = (QCRIL_QMI_PIL_STATE_OFFLINE == qcril_qmi_voice_info.pil_state.state);
   QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
   return ret;
} // qmi_ril_voice_is_calls_supressed_by_pil_vcl

//===========================================================================
// qcril_qmi_voice_ims_send_unsol_radio_state_change
//===========================================================================
void qcril_qmi_voice_ims_send_unsol_radio_state_change()
{
  ims_RadioStateChanged ims_unsol_radio_state_change;
  RIL_RadioState        radio_state;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&ims_unsol_radio_state_change, 0, sizeof(ims_unsol_radio_state_change));

  radio_state = qcril_get_current_radio_state();
  QCRIL_LOG_DEBUG("radio_state: %s(%d)", qcril_log_ril_radio_state_to_str(radio_state), radio_state);

  ims_unsol_radio_state_change.has_state = TRUE;
  switch (radio_state)
  {
    case RADIO_STATE_UNAVAILABLE:
      ims_unsol_radio_state_change.state = ims_RadioState_RADIO_STATE_UNAVAILABLE;
      break;

    case RADIO_STATE_OFF:
      ims_unsol_radio_state_change.state = ims_RadioState_RADIO_STATE_OFF;
      break;

    default:
      ims_unsol_radio_state_change.state = ims_RadioState_RADIO_STATE_ON;
      break;
  }

  QCRIL_LOG_DEBUG("Modem_state is : %d", ims_unsol_radio_state_change.state);

  imsRadioSendMessage(0,
      ims_MsgType_UNSOL_RESPONSE,
      ims_MsgId_UNSOL_RADIO_STATE_CHANGED,
      ims_Error_E_SUCCESS,
      &ims_unsol_radio_state_change,
      sizeof(ims_unsol_radio_state_change));

  QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_voice_ims_client_connected_handler
//===========================================================================
void qcril_qmi_voice_ims_client_connected_handler(void * param)
{
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( param );

  qcril_qmi_voice_ims_send_unsol_radio_state_change();
  qcril_qmi_voice_ims_send_unsol_vice_dialog_refresh_info_helper();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_ims_client_connected_handler

//===========================================================================
// qcril_qmi_voice_ims_client_connected
//===========================================================================
void qcril_qmi_voice_ims_client_connected()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
      QCRIL_DEFAULT_MODEM_ID,
      qcril_qmi_voice_ims_client_connected_handler,
      NULL,  // immediate
      NULL);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_ims_client_connected

//===========================================================================
// qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp
//===========================================================================
void qcril_qmi_send_ss_failure_cause_oem_hook_unsol_resp
(
  qmi_sups_errors_enum_v02 sups_failure_cause,
  uint8_t call_id
)
{
    int payload[2] = {0};

    payload[ 0 ] = call_id;
    payload[ 1 ] = sups_failure_cause;

    QCRIL_LOG_INFO("Sending QCRIL_EVT_HOOK_UNSOL_SS_ERR_CODE: call_id - %d sups_failure_cause - %d ", call_id, sups_failure_cause);
    qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_SS_ERROR_CODE, (char *) payload, sizeof(payload) );

    return;
}

//===========================================================================
// qcril_qmi_voice_send_request_answer
//===========================================================================
RIL_Errno qcril_qmi_voice_send_request_answer(
  const qcril_request_params_type             *const params_ptr,
  int                                         reject_this_call
)
{
   RIL_Errno                                   res;
   uint32                                      user_data;
   qcril_reqlist_public_type                   reqlist_entry;
   voice_answer_call_req_msg_v02               ans_call_req_msg;
   qcril_qmi_voice_voip_call_info_entry_type   *call_info_entry = NULL;
   qmi_ril_voice_ims_command_exec_oversight_type*                      command_oversight;
   qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type   oversight_cmd_params;
   call_state_enum_v02                         target_call_state;
   IxErrnoType reqlist_status;

   QCRIL_LOG_FUNC_ENTRY();

   res = RIL_E_GENERIC_FAILURE;

   do
   {
      qcril_reqlist_default_entry(params_ptr->t,
                                  params_ptr->event_id,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_REQ_AWAITING_CALLBACK,
                                  QCRIL_EVT_NONE,
                                  NULL,
                                  &reqlist_entry);
      reqlist_status = qcril_reqlist_new(QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry);
      if (reqlist_status != E_SUCCESS)
      {
          QCRIL_LOG_ERROR(".. failed to add into Req list");
          res = qcril_qmi_map_internalerr_from_reqlist_new_to_ril_err(reqlist_status);
          break;
      }
      call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
                  QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_PENDING_INCOMING, TRUE);
      if ( NULL == call_info_entry )
      {
         QCRIL_LOG_INFO(".. pending incoming call record entry not found");
         res = RIL_E_INVALID_STATE;
         break;
      }
      // Cancel if there is any auto answer timed callback
      if ( QMI_RIL_ZERO != qmi_voice_voip_overview.auto_answer_timer_id )
      {
         QCRIL_LOG_INFO(".. Cancel Auto answer timed callback");
         qcril_cancel_timed_callback( (void*)(uintptr_t) qmi_voice_voip_overview.auto_answer_timer_id );
         qmi_voice_voip_overview.auto_answer_timer_id = QMI_RIL_ZERO;
      }
      memset(&ans_call_req_msg, 0, sizeof(ans_call_req_msg));
      ans_call_req_msg.call_id = call_info_entry->qmi_call_id;
      QCRIL_LOG_INFO(".. call id qmi %d", (int) ans_call_req_msg.call_id );

      if ( QCRIL_EVT_IMS_SOCKET_REQ_ANSWER == params_ptr->event_id )
      {
          ims_Answer* msg_ptr = (ims_Answer*) params_ptr->data;
          if (NULL == msg_ptr)
          {
             QCRIL_LOG_ERROR("IMS Answer params_ptr->data is NULL");
             res = RIL_E_INVALID_ARGUMENTS;
             break;
          }
          else
          {
              /* check for these params as they are sent only in case VoIP/VT is supported */
              if( msg_ptr->has_call_type )
              {
                 /* In case of voice call, call type is not expected in answer */
                 if( call_info_entry->voice_scv_info.call_type == CALL_TYPE_VT_V02 )
                 {
                    if( msg_ptr->call_type == ims_CallType_CALL_TYPE_VT )
                    {
                       ans_call_req_msg.call_type_valid = TRUE;
                       ans_call_req_msg.call_type = CALL_TYPE_VT_V02;

                       ans_call_req_msg.audio_attrib_valid = TRUE;
                       ans_call_req_msg.audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);

                       ans_call_req_msg.video_attrib_valid = TRUE;
                       ans_call_req_msg.video_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);
                    }
                    else if ( ims_CallType_CALL_TYPE_VT_TX == msg_ptr->call_type )
                    {
                       ans_call_req_msg.call_type_valid = TRUE;
                       ans_call_req_msg.call_type = CALL_TYPE_VT_V02;

                       ans_call_req_msg.audio_attrib_valid = TRUE;
                       ans_call_req_msg.audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);

                       ans_call_req_msg.video_attrib_valid = TRUE;
                       ans_call_req_msg.video_attrib = VOICE_CALL_ATTRIB_TX_V02;
                    }
                    else if ( ims_CallType_CALL_TYPE_VT_RX == msg_ptr->call_type )
                    {
                       ans_call_req_msg.call_type_valid = TRUE;
                       ans_call_req_msg.call_type = CALL_TYPE_VT_V02;

                       ans_call_req_msg.audio_attrib_valid = TRUE;
                       ans_call_req_msg.audio_attrib = (VOICE_CALL_ATTRIB_TX_V02 | VOICE_CALL_ATTRIB_RX_V02);

                       ans_call_req_msg.video_attrib_valid = TRUE;
                       ans_call_req_msg.video_attrib = VOICE_CALL_ATTRIB_RX_V02;
                    }
                    else
                    {
                       ans_call_req_msg.call_type_valid = TRUE;
                       ans_call_req_msg.call_type = CALL_TYPE_VOICE_IP_V02;
                    }
                    // Cache the user specified call type in answer.
                    call_info_entry->answered_call_type_valid = TRUE;
                    call_info_entry->answered_call_type = msg_ptr->call_type;
                 }
                 QCRIL_LOG_DEBUG("atel ims call type = %d, modem call type = %d", msg_ptr->call_type, ans_call_req_msg.call_type);
              }
              if (msg_ptr->has_presentation)
              {
                 ans_call_req_msg.pi_valid = TRUE;
                 ans_call_req_msg.pi = (ip_pi_enum_v02)msg_ptr->presentation;
              }
              if(msg_ptr->has_rttMode)
              {
                  ans_call_req_msg.rtt_mode_valid = qcril_qmi_ims_map_ims_rtt_mode_to_qcril(
                                                    msg_ptr->rttMode,
                                                    &ans_call_req_msg.rtt_mode);
                  QCRIL_LOG_DEBUG("atel ims rtt mode = %d, modem rtt mode = %d", msg_ptr->rttMode, ans_call_req_msg.rtt_mode);
              }
          }
      }

      user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );

      if (TRUE == reject_this_call)
      {
          ans_call_req_msg.reject_call_valid = TRUE;
          ans_call_req_msg.reject_call = TRUE;
      }

      if ( QCRIL_EVT_RIL_REQUEST_ANSWER == params_ptr->event_id ||
              QCRIL_EVT_IMS_SOCKET_REQ_ANSWER == params_ptr->event_id ||
              QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND == params_ptr->event_id )
      {
          command_oversight = qmi_ril_voice_ims_create_command_oversight( params_ptr->t, params_ptr->event_id , TRUE );
          if ( NULL != command_oversight )
          {
              target_call_state = CALL_STATE_CONVERSATION_V02;
              if ( QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND == params_ptr->event_id )
              {
                 target_call_state = CALL_STATE_END_V02;
              }
              qmi_ril_voice_ims_command_oversight_add_call_link( command_oversight,
                                                             QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID,
                                                             QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE,
                                                             call_info_entry->qmi_call_id,
                                                             target_call_state );

              memset( &oversight_cmd_params, 0, sizeof( oversight_cmd_params ) );
              oversight_cmd_params.locator.command_oversight = command_oversight;

              qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_COMMENCE_AWAIT_RESP_IND,
                                                            QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                                            &oversight_cmd_params );
          } // if ( NULL != command_oversight )
      }

      // Send QMI VOICE ANSWER CALL REQ
      qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                   QMI_VOICE_ANSWER_CALL_REQ_V02,
                                   &ans_call_req_msg,
                                   sizeof(ans_call_req_msg),
                                   sizeof(voice_answer_call_resp_msg_v02),
                                   qcril_qmi_voice_command_cb,
                                   (void*)(uintptr_t)user_data);
      if (qmi_client_error != QMI_NO_ERR) {
        QCRIL_LOG_INFO(".. failed to post qmi answer message, trasport error %d",
                qmi_client_error);
        res = RIL_E_SYSTEM_ERR;
        break;
      }

      if (FALSE == reject_this_call)
      {
          call_info_entry->elaboration |= QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_ANSWERING_CALL;
#ifndef QMI_RIL_UTF
          qcril_am_handle_event(qcril_qmi_voice_get_answer_am_event(call_info_entry), NULL);
#endif
      }

      res = RIL_E_SUCCESS;
   } while (FALSE);

   QCRIL_LOG_FUNC_RETURN();
   return res;
} // qcril_qmi_voice_send_request_answer

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_oem_hook_reject_incoming_call_cause_21

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_REJECT_INCOMING_CALL_CAUSE_21
*/
/*=========================================================================*/
void qcril_qmi_voice_oem_hook_reject_incoming_call_cause_21
(
   const qcril_request_params_type *const params_ptr,
   qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);
    qcril_qmi_voice_voip_lock_overview();
    res = qcril_qmi_voice_send_request_answer (params_ptr, TRUE);
    if (RIL_E_SUCCESS != res)
    {
        qcril_send_empty_payload_request_response(
                        QCRIL_DEFAULT_INSTANCE_ID,
                        params_ptr->t,
                        params_ptr->event_id,
                        res);
    }
    qcril_qmi_voice_voip_unlock_overview();
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_oem_hook_reject_incoming_call_cause_21

//===========================================================================
// qmi_ril_voice_ims_command_oversight_timeout_handler
//===========================================================================
void qmi_ril_voice_ims_command_oversight_timeout_handler(void * param)
{
  qmi_ril_voice_ims_command_exec_oversight_type* command_oversight;
  qmi_ril_voice_ims_command_exec_oversight_type* iter;
  uint32                                         cause_tmr;
  qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type
                                                  event_params;

  QCRIL_LOG_FUNC_ENTRY();

  cause_tmr = (uint32)(uintptr_t)param;

  qcril_qmi_voice_voip_lock_overview();

  // find expired
  command_oversight = NULL;
  iter = qmi_ril_voice_ims_command_oversight_first();
  while ( NULL != iter && NULL == command_oversight )
  {
    if ( cause_tmr == iter->timeout_control_timer_id )
    {
      command_oversight = iter;
    }
    else
    {
      iter = qmi_ril_voice_ims_command_oversight_next();
    }
  } // while ( NULL != iter && NULL == command_oversight )

  if ( NULL != command_oversight )
  {
    command_oversight->timeout_control_timer_id = QMI_RIL_ZERO;

    memset( &event_params, 0, sizeof( event_params ) );
    event_params.locator.command_oversight = command_oversight;

    (void)qmi_ril_voice_ims_command_oversight_handle_event( QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_TIME_OUT, QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ, &event_params );
  }

  qcril_qmi_voice_voip_unlock_overview();

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_ims_command_oversight_timeout_handler


//===========================================================================
// qmi_ril_voice_ims_command_oversight_dial_completion_action
//===========================================================================
void qmi_ril_voice_ims_command_oversight_dial_completion_action
(
 void *command,
 void *data
)
{
  int idx = 0;
  qcril_qmi_voice_voip_call_info_entry_type *call_entry = NULL;
  qmi_ril_voice_ims_command_exec_oversight_link_type *link = NULL;
  RIL_Errno ril_req_res = RIL_E_SUCCESS;
  qmi_ril_voice_ims_command_exec_oversight_type *command_oversight =
        (qmi_ril_voice_ims_command_exec_oversight_type *)command;

  QCRIL_LOG_FUNC_ENTRY();

  if (data)
  {
    ril_req_res = *((RIL_Errno *)data);
  }

  QCRIL_LOG_DEBUG("command_oversight = %p, ril_req_res = %d", command_oversight, ril_req_res);

  if (command_oversight &&
      (ril_req_res != RIL_E_SUCCESS && ril_req_res != RIL_E_DIAL_MODIFIED_TO_DIAL))
  {
    link = command_oversight->impacted;
    // Delete the call_entry if DIAL is returned with error due to timeout
    for (idx = 0; idx < command_oversight->nof_impacted; idx++)
    {
      if (QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN == link->linkage_type)
      {
        call_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration(
            link->linkage.elaboration_pattern, TRUE);
        if (call_entry)
        {
          if (link->exec_state ==
                QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION)
          {
            call_entry->voice_scv_info.call_state = CALL_STATE_END_V02;
            break;
          }
          call_entry = NULL;
        }
      }
      link++;
    } // for ( idx = 0; idx < command_oversight->nof_impacted; idx++ )
    if (call_entry)
    {
      QCRIL_LOG_DEBUG("command_oversight->android_request_id = %d",
          command_oversight->android_request_id);
      if(command_oversight->android_request_id == QCRIL_EVT_RIL_REQUEST_DIAL)
      {
        qcril_qmi_voice_voip_destroy_call_info_entry(call_entry);
      }
      if(command_oversight->android_request_id == QCRIL_EVT_IMS_SOCKET_REQ_DIAL)
      {
        qcril_qmi_voice_send_ims_unsol_call_state_changed();
      }
    }
  }
  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_voice_ims_command_oversight_dial_completion_action

//===========================================================================
// qmi_ril_voice_ims_create_command_oversight
//===========================================================================
qmi_ril_voice_ims_command_exec_oversight_type* qmi_ril_voice_ims_create_command_oversight( RIL_Token token,  qcril_evt_e_type request_id, int launch_timout_control )
{
  struct timeval timeout_delay;

  qmi_ril_voice_ims_command_exec_oversight_type* command_oversight;

  command_oversight = (qmi_ril_voice_ims_command_exec_oversight_type*)
        qcril_malloc( sizeof( *command_oversight ) );

  if ( NULL != command_oversight )
  {
    command_oversight->token              = token;
    command_oversight->android_request_id = request_id;

    if ( launch_timout_control )
    { // launch timer
      memset( &timeout_delay, 0, sizeof( timeout_delay ) );
      timeout_delay.tv_usec = QMI_RIL_ZERO;

      if (request_id == QCRIL_EVT_RIL_REQUEST_DIAL ||
          request_id == QCRIL_EVT_IMS_SOCKET_REQ_DIAL)
      {
        timeout_delay.tv_sec = 72;
        command_oversight->completion_action =
          qmi_ril_voice_ims_command_oversight_dial_completion_action;
      }
      else if (request_id == QCRIL_EVT_RIL_REQUEST_ANSWER ||
          request_id == QCRIL_EVT_IMS_SOCKET_REQ_ANSWER)
      {
        timeout_delay.tv_sec = 10;
      }
      else if (request_id == QCRIL_EVT_RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND ||
          request_id == QCRIL_EVT_RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND)
      {
        timeout_delay.tv_sec = 72;
      }
      else if (request_id == QCRIL_EVT_HOOK_REQUEST_SETUP_ANSWER)
      {
        timeout_delay.tv_sec = 90;
      }
      else
      {
        timeout_delay.tv_sec = 1; // 1 second by default
      }

      qcril_setup_timed_callback(   QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_voice_ims_command_oversight_timeout_handler,
                                    &timeout_delay,
                                    &command_oversight->timeout_control_timer_id );

    }
    QCRIL_LOG_DEBUG( "cmd oversight created obj %p android req %d, token 0x%x, under timeout ctrl %d",
                     command_oversight, request_id, token, command_oversight->timeout_control_timer_id );

    command_oversight->next                           = qmi_voice_voip_overview.command_exec_oversight_root;
    qmi_voice_voip_overview.command_exec_oversight_root = command_oversight;
  }
  else
  {
    QCRIL_LOG_ERROR("cmd oversight FAILED to create obj: no resources");
  }

  qmi_ril_voice_ims_command_oversight_dump( command_oversight );

  return command_oversight;
} // qmi_ril_voice_ims_create_command_oversight
//===========================================================================
// qmi_ril_voice_ims_destroy_command_oversight
//===========================================================================
void qmi_ril_voice_ims_destroy_command_oversight( qmi_ril_voice_ims_command_exec_oversight_type* command_oversight )
{
  qmi_ril_voice_ims_command_exec_oversight_type** cur_p;
  qmi_ril_voice_ims_command_exec_oversight_type*  cur;
  if ( NULL != command_oversight )
  {
    if ( QMI_RIL_ZERO != command_oversight->timeout_control_timer_id )
    {
      qcril_cancel_timed_callback( (void*)(uintptr_t) command_oversight->timeout_control_timer_id );
      command_oversight->timeout_control_timer_id = QMI_RIL_ZERO;
    }

    cur_p = &qmi_voice_voip_overview.command_exec_oversight_root;
    while ( NULL != ( cur = *cur_p ) && ( command_oversight != cur ) )
    {
      cur_p = &cur->next;
    }
    if ( NULL != cur )
    {
      *cur_p = cur->next;
    }

    if ( command_oversight == qmi_voice_voip_overview.command_exec_oversight_current )
    {
      qmi_voice_voip_overview.command_exec_oversight_current = command_oversight->next;
    }
    QCRIL_LOG_DEBUG("Destroyed cmd oversight obj %p", command_oversight);

    qcril_free( command_oversight );
  }
} // qmi_ril_voice_ims_destroy_command_oversight

//===========================================================================
// qmi_ril_voice_ims_command_oversight_add_call_link
//===========================================================================
void qmi_ril_voice_ims_command_oversight_add_call_link(  qmi_ril_voice_ims_command_exec_oversight_type*     command_oversight,
                                                         qmi_ril_voice_ims_command_exec_oversight_call_obj_linkage_e_type link_type,
                                                         qcril_qmi_voice_voip_call_info_elaboration_type    elaboration_pattern,
                                                         int                                                call_id,
                                                         call_state_enum_v02                                target_call_state
                                                       )
{
  qmi_ril_voice_ims_command_exec_oversight_link_type * link;

  if ( NULL != command_oversight && ( command_oversight->nof_impacted < QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_MAX_NOF_CALLS ) )
  {
    link = &command_oversight->impacted [ command_oversight->nof_impacted ];
    command_oversight->nof_impacted++;

    link->linkage_type = link_type;
    switch ( link_type )
    {
      case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_NONE:
        // no action
        break;

      case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID:
        link->linkage.qmi_call_id = call_id;
        break;

      case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID:
        link->linkage.android_call_id = call_id;
        break;

      case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN:
        link->linkage.elaboration_pattern                               = elaboration_pattern;
        break;

      default:
        break;
    }
    link->target_call_state = target_call_state;
  }

  qmi_ril_voice_ims_command_oversight_dump( command_oversight );
} // qmi_ril_voice_ims_command_oversight_add_call_link


//===========================================================================
// qmi_ril_voice_ims_command_oversight_first
//===========================================================================
qmi_ril_voice_ims_command_exec_oversight_type* qmi_ril_voice_ims_command_oversight_first()
{
  qmi_ril_voice_ims_command_exec_oversight_type*  command_oversight;

  command_oversight                                       = qmi_voice_voip_overview.command_exec_oversight_root;
  qmi_voice_voip_overview.command_exec_oversight_current  = qmi_voice_voip_overview.command_exec_oversight_root;

  return command_oversight;
}  // qmi_ril_voice_ims_command_oversight_first
//===========================================================================
// qmi_ril_voice_ims_command_oversight_next
//===========================================================================
qmi_ril_voice_ims_command_exec_oversight_type* qmi_ril_voice_ims_command_oversight_next()
{
  qmi_ril_voice_ims_command_exec_oversight_type*  command_oversight;

  command_oversight = qmi_voice_voip_overview.command_exec_oversight_current;
  if ( NULL != qmi_voice_voip_overview.command_exec_oversight_current )
  {
    qmi_voice_voip_overview.command_exec_oversight_current = qmi_voice_voip_overview.command_exec_oversight_current->next;
    command_oversight                                      = qmi_voice_voip_overview.command_exec_oversight_current;
  }
  else
  {
    command_oversight = NULL;
  }
  return command_oversight;
} // qmi_ril_voice_ims_command_oversight_next

//===========================================================================
// qmi_ril_voice_ims_find_command_oversight_by_token
//===========================================================================
qmi_ril_voice_ims_command_exec_oversight_type* qmi_ril_voice_ims_find_command_oversight_by_token( RIL_Token token )
{
  qmi_ril_voice_ims_command_exec_oversight_type*  command_oversight;
  qmi_ril_voice_ims_command_exec_oversight_type*  iter;

  command_oversight = NULL;

  iter = qmi_ril_voice_ims_command_oversight_first();
  while ( ( NULL != iter ) && ( NULL == command_oversight ) )
  {
    if ( token == iter->token )
    {
      command_oversight = iter;
    }
    else
    {
      iter = qmi_ril_voice_ims_command_oversight_next();
    }
  }

  return command_oversight;
} // qmi_ril_voice_ims_find_command_oversight_by_token

//===========================================================================
// qmi_ril_voice_ims_command_oversight_handle_event
//===========================================================================
int qmi_ril_voice_ims_command_oversight_handle_event(   qmi_ril_voice_ims_command_exec_intermediates_event_e_type event,
                                                         qmi_ril_voice_ims_command_exec_oversight_call_obj_linkage_e_type link_type,
                                                         qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type* params
                                                       )
{
  qmi_ril_voice_ims_command_exec_oversight_type*              iter;
  int                                                         idx;
  qmi_ril_voice_ims_command_exec_oversight_link_type *        link;
  int                                                         need_to_conclude_cmd;
  int                                                         is_match;
  qmi_ril_voice_ims_command_exec_intermediates_state_e_type   new_link_state;
  int                                                         need_set_new_link_state;
  int                                                         any_link_changed;
  qmi_ril_voice_ims_command_exec_intermediates_state_e_type   generalized_completion_state;
  RIL_Errno                                                   ril_req_res = RIL_E_INTERNAL_ERR;
  qcril_reqlist_public_type                                   atel_request;
  IxErrnoType                                                 atel_request_find_res;
  int                                                         any_action_performed;
  qcril_qmi_voice_voip_call_info_entry_type*                  call_entry;

  QCRIL_LOG_FUNC_ENTRY();

  any_action_performed = FALSE;

  iter = qmi_ril_voice_ims_command_oversight_first();
  while ( NULL != iter )
  {
    qmi_ril_voice_ims_command_oversight_dump( iter );

    link                 = iter->impacted;
    any_link_changed     = FALSE;
    for ( idx = 0; idx < iter->nof_impacted; idx++ )
    {
      is_match = FALSE;
      switch ( link_type )
      {
        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID:
          if ( QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID == link->linkage_type && link->linkage.qmi_call_id == params->locator.qmi_call_id )
          {
            is_match = TRUE;
          }
          break;

        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID:
          if ( QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID == link->linkage_type && link->linkage.android_call_id == params->locator.android_call_id )
          {
            is_match = TRUE;
          }
          break;

        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN:
          if ( QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN == link->linkage_type &&
               ( link->linkage.elaboration_pattern & params->locator.elaboration_pattern ) == link->linkage.elaboration_pattern
             )
          {
            call_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( link->linkage.elaboration_pattern, TRUE );
            if ( NULL != call_entry )
            {
              is_match = TRUE;
            }
          }
          break;

        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ:
          if ( params->locator.command_oversight == iter )
          {
            is_match = TRUE;
          }
          break;

        default:
          // no action
          break;
      } // switch ( link_type )

      need_set_new_link_state = FALSE;
      new_link_state          = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_NONE;
      if ( is_match )
      { // found record, absorb event
        switch ( event )
        {
          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_COMMENCE_AWAIT_RESP_IND:
            new_link_state          = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_AWAITING_RESP_AND_IND;
            need_set_new_link_state = TRUE;
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_SUCCESS:
            switch ( link->exec_state )
            {
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_AWAITING_RESP_AND_IND:
                new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_RESP_AWAITING_IND;
                need_set_new_link_state = TRUE;
                break;

              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AWAITING_RESP:
                new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION;
                need_set_new_link_state = TRUE;
                break;

              default:
                break;
            }
            if ( 0 == iter->successful_response_payload_len && params->successful_response_payload_len > 0 && need_set_new_link_state )
            {
              iter->successful_response_payload_len = params->successful_response_payload_len;
              memcpy( (void *)&iter->successful_response_payload, (void *)&params->successful_response_payload, params->successful_response_payload_len );
            }
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_FAILURE:
            switch ( link->exec_state )
            {
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_AWAITING_RESP_AND_IND:
                new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION;
                need_set_new_link_state = TRUE;
                break;

              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AWAITING_RESP:
                new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION;
                need_set_new_link_state = TRUE;
                break;

              default:
                break;
            }
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_IND:
            if ( link->target_call_state == params->new_call_state )
            {
              switch ( link->exec_state )
              {
                case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_AWAITING_RESP_AND_IND:
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AWAITING_RESP;
                  need_set_new_link_state = TRUE;
                  break;

                case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_RESP_AWAITING_IND:
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION;
                  need_set_new_link_state = TRUE;
                  break;

                default:
                  break;
              } // ( link->exec_state )
            } // if ( link->target_call_state == params->new_call_state )
            if ( 0 == iter->successful_response_payload_len && params->successful_response_payload_len > 0 && need_set_new_link_state )
            {
              iter->successful_response_payload_len = params->successful_response_payload_len;
              memcpy( (void *)&iter->successful_response_payload, (void *)&params->successful_response_payload, params->successful_response_payload_len );
            }
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_CALL_ENDED:
            if ( CALL_STATE_END_V02 == link->target_call_state )
            {
              switch ( link->exec_state )
              {
                case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_AWAITING_RESP_AND_IND:
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AWAITING_RESP;
                  need_set_new_link_state = TRUE;
                  break;

                case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_RESP_AWAITING_IND:
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION;
                  need_set_new_link_state = TRUE;
                  break;

                default:
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION;
                  need_set_new_link_state = TRUE;
                  break;
              }
            }
            else
            {
              new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION;
              need_set_new_link_state = TRUE;
            }
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_TIME_OUT:
            switch ( link->exec_state )
            {
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION:               // fallthrough
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION:    // fallthrough
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION:
                // no change
                break;

              default:
                if ( iter == params->locator.command_oversight )
                {
                  new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION;
                  need_set_new_link_state = TRUE;
                }
                break;
            }
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_ABANDON:
            new_link_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION;
            need_set_new_link_state = TRUE;
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_NONE:                // fallthrough
          default:
            // no action
            break;
        } // switch ( event )
        if ( need_set_new_link_state )
        {
          link->exec_state      = new_link_state;
          any_link_changed      = TRUE;
          any_action_performed  = TRUE;
        }
      } // if ( is_match ) - call links match with params
      link++;
    } // for ( idx = 0; idx < iter->nof_impacted; idx++ )

    need_to_conclude_cmd = FALSE;
    if ( any_link_changed )
    { // assess if all links awaiting for conclusion
      need_to_conclude_cmd = TRUE;
      generalized_completion_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION;
      link = iter->impacted;
      // get to one result cause or abandon conclusion
      for ( idx = 0; idx < iter->nof_impacted ; idx++ )
      {
        switch ( link->exec_state )
        {
          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION:
            // we may conclude, keeping need_to_conclude_cmd set
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION:
            generalized_completion_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION;
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION:
            generalized_completion_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION;
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION:
            switch ( generalized_completion_state )
            {
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION:                  // fallthrough
              case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION:
                // no change
                break;

              default:
                generalized_completion_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION;
                break;
            }
            // we may conclude, keeping need_to_conclude_cmd set
            break;

          case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION:
            generalized_completion_state = QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION;
            need_to_conclude_cmd = TRUE;
            break;

          default:
            if ( QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION != generalized_completion_state )
            {
              need_to_conclude_cmd = FALSE; // not ready for conclusion
            }
            break;
        }
        link++;
      } // for ( idx = 0; idx < iter->nof_impacted && need_to_conclude_cmd ; idx++ )
      if ( need_to_conclude_cmd )
      { // do conclude - need to respond and conclude the pending oversight
        if ( QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION != generalized_completion_state )
        {
          switch ( generalized_completion_state )
          {
            case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_TIMEOUT_READY_FOR_COMPLETION:
              ril_req_res = RIL_E_INTERNAL_ERR;
              break;

            case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_FAILURE_RESP_READY_FOR_COMPLETION:
              ril_req_res = RIL_E_INTERNAL_ERR;
              break;

            case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_CALL_ENDED_READY_FOR_COMPLETION:
            case QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_RECEIVED_IND_AND_RESP_READY_FOR_COMPLETION:
            default:
              if (iter->successful_response_payload_len > 0)
              {
                ril_req_res = (RIL_Errno)iter->successful_response_payload;
              }
              else
              {
                ril_req_res = RIL_E_SUCCESS;
              }
              break;
          }

          atel_request_find_res = qcril_reqlist_query( QCRIL_DEFAULT_INSTANCE_ID, iter->token, &atel_request );
          if ( E_SUCCESS == atel_request_find_res )
          {
            qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                       atel_request.t,
                                                       atel_request.request,
                                                       ril_req_res );

          } // if ( E_SUCCESS == atel_request_find_res )
        } // if ( QMI_RIL_VOICE_IMS_EXEC_INTERMED_STATE_ABANDONED_READY_FOR_COMPLETION != generalized_completion_state )

        if (iter->completion_action != NULL)
        {
          iter->completion_action(iter, &ril_req_res);
        }

        // reset elaboration from call obj
        link                 = iter->impacted;
        for ( idx = 0; idx < iter->nof_impacted; idx++ )
        {
          if ( QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN == link->linkage_type )
          {
            call_entry = qcril_qmi_voice_voip_find_call_info_entry_by_elaboration( link->linkage.elaboration_pattern, TRUE );
            if ( NULL != call_entry )
            {
              call_entry->elaboration &= ~link->linkage.elaboration_pattern;
            }
          }
          link++;
        } // for ( idx = 0; idx < iter->nof_impacted; idx++ )

        qmi_ril_voice_ims_destroy_command_oversight( iter );
      } // if ( need_to_conclude_cmd )

    } // if ( any_link_changed )

    if ( !need_to_conclude_cmd )
    {
      qmi_ril_voice_ims_command_oversight_dump( iter );
    }
    else
    {
      QCRIL_LOG_INFO("command concluded");
    }

    iter = qmi_ril_voice_ims_command_oversight_next();

  } // while ( NULL != iter ), iteration through oversight command objects

  QCRIL_LOG_FUNC_RETURN_WITH_RET( any_action_performed );

  return any_action_performed;
} // qmi_ril_voice_ims_command_oversight_handle_event

//===========================================================================
// qmi_ril_voice_ims_command_oversight_dump
//===========================================================================
void qmi_ril_voice_ims_command_oversight_dump( qmi_ril_voice_ims_command_exec_oversight_type* command_oversight )
{
  int                                                   idx;
  qmi_ril_voice_ims_command_exec_oversight_link_type*   link;
  char                                                  link_info_buf[ QCRIL_MAX_LOG_MSG_SIZE ];

  if ( NULL != command_oversight )
  {
    QCRIL_LOG_INFO("oversight obj android request id %d, token id %" PRId32 ", timer %d, nof_impacted %d",
                   command_oversight->android_request_id,
                   qcril_log_get_token_id ( command_oversight->token ),
                   command_oversight->timeout_control_timer_id,
                   command_oversight->nof_impacted );

    link = command_oversight->impacted;
    for ( idx = 0; idx < command_oversight->nof_impacted; idx++ )
    {
      switch ( link->linkage_type )
      {
        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID:
          snprintf( link_info_buf, QCRIL_MAX_LOG_MSG_SIZE, "qmi call id %d", link->linkage.qmi_call_id );
          break;

        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ANDROID_CALL_ID:
          snprintf( link_info_buf, QCRIL_MAX_LOG_MSG_SIZE, "atel call id %d", link->linkage.android_call_id );
          break;

        case QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_ELABORATION_PATTERN:
          snprintf( link_info_buf, QCRIL_MAX_LOG_MSG_SIZE, "elaboration %x-%x", (unsigned int)(link->linkage.elaboration_pattern >> 32), (unsigned int)(link->linkage.elaboration_pattern & 0xFFFFFFUL) );
          break;

        default:
          snprintf( link_info_buf, QCRIL_MAX_LOG_MSG_SIZE, "no info" );
          break;
      }
      QCRIL_LOG_INFO(".link#%d, state %d, %s, exp c-state %d",
                     idx,
                     link->exec_state,
                     link_info_buf,
                     link->target_call_state
                     );

      link++;
    }
  }
} // qmi_ril_voice_ims_command_oversight_dump

void qcril_qmi_voice_process_in_main_thread_handler
(
 qcril_timed_callback_handler_params_type *param
)
{

  QCRIL_LOG_FUNC_ENTRY();

  auto req_params = (const qcril_request_params_type *)param->custom_param;
  if (!req_params)
  {
     QCRIL_LOG_ERROR("unexpected: parameters null...return");
     return;
  }

  if (req_params->event_id == QCRIL_EVT_IMS_SOCKET_REQ_DIAL)
  {
    qcril_qmi_voice_request_dial (req_params, NULL);
    ims_Dial *ims_in_data_ptr = (ims_Dial*)req_params->data;
    qcril_qmi_npb_release(ims_Dial_fields, ims_in_data_ptr);
    qcril_free(ims_in_data_ptr);
  }
  else if (req_params->event_id == QCRIL_EVT_IMS_SOCKET_REQ_HANGUP)
  {
    qcril_qmi_voice_request_hangup (req_params, NULL);
  }

  qcril_free ((void*)req_params);

  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_voice_process_in_main_thread
(
   qcril_evt_e_type event_id,
   void *data,
   size_t datalen,
   RIL_Token t
)
{
   int res = 0;
   qcril_request_params_type *params_ptr = NULL;

   QCRIL_LOG_FUNC_ENTRY();

   do
   {
      params_ptr = (qcril_request_params_type*)qcril_malloc (sizeof (*params_ptr));
      if (NULL == params_ptr)
      {
         QCRIL_LOG_ERROR ("qcril_malloc failed");
         break;
      }
      params_ptr->instance_id = QCRIL_DEFAULT_INSTANCE_ID;
      params_ptr->modem_id = QCRIL_DEFAULT_MODEM_ID;
      params_ptr->event_id = event_id;
      params_ptr->data = data;
      params_ptr->datalen = datalen;
      params_ptr->t = t;
      res = qcril_setup_timed_callback_ex_params (QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_voice_process_in_main_thread_handler,
                                            (void *) params_ptr,
                                            NULL,
                                            NULL);
      RIL_Errno ril_res = (!res) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
      if (RIL_E_SUCCESS != ril_res)
      {
          QCRIL_LOG_ERROR ("could not post ims dial request to timed callback. res = %d", res);
          qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
              params_ptr->t, params_ptr->event_id, ril_res);
          if (NULL != params_ptr)
          {
              qcril_free(params_ptr);
          }
      }
   } while (FALSE);

   QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_voice_request_ims_set_supp_srv_status

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_SUPP_SVC_STATUS, and calls appropriate
    function based on the SuppSvcFacilityType and SuppSvcOperationType.
    Function handler table defined by set_supp_srv_status_handler_table[][].

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_ims_set_supp_srv_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  /* IMS SuppSvcRequest message pointer */
  ims_SuppSvcRequest *ims_in_data_ptr;

  /* Operation type (activate, deactivate, query) from SuppSvcRequest message */
  ims_SuppSvcOperationType operation_type;

  /* Facility type (CLIP, COLP, BA*) from SuppSvcRequest message */
  ims_SuppSvcFacilityType facility_type;

  QCRIL_LOG_FUNC_ENTRY();

  if ( NULL == params_ptr)
  {
    QCRIL_LOG_INFO( "params_ptr is NULL" );
  }
  else if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
  {
    QCRIL_LOG_INFO( "params_ptr->datalen == 0 or params_ptr is NULL" );
    qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                               params_ptr->t,
                                               params_ptr->event_id,
                                               RIL_E_GENERIC_FAILURE );
  }
  else
  {
    ims_in_data_ptr = ( ims_SuppSvcRequest * )params_ptr->data;
    if ( ims_in_data_ptr->has_operationType )
    {
      operation_type = ( ims_SuppSvcOperationType )ims_in_data_ptr->operationType;
      QCRIL_LOG_INFO( "operation_type: %d", operation_type );

      if ( ims_in_data_ptr->has_facilityType )
      {
        facility_type = ( ims_SuppSvcFacilityType )ims_in_data_ptr->facilityType;
        QCRIL_LOG_INFO( "facility_type: %d", facility_type );

        if ( ims_SuppSvcFacilityType_MAX >= facility_type ||
          ims_SuppSvcFacilityType_MIN <= facility_type )
        {

          switch ( operation_type )
          {
            case   ims_SuppSvcOperationType_ACTIVATE:
            case   ims_SuppSvcOperationType_DEACTIVATE:   /* Fall through */
              {
                ( *supp_srv_status_set_handler_table\
                  [facility_type] )( params_ptr, ret_ptr );
                break;
              }

            case  ims_SuppSvcOperationType_QUERY:
              {
                ( *supp_srv_status_query_handler_table\
                  [facility_type] )( params_ptr, ret_ptr );
                break;
              }

          case ims_SuppSvcOperationType_REGISTER:
          case ims_SuppSvcOperationType_ERASURE:
              if (ims_SuppSvcFacilityType_FACILITY_BS_MT == facility_type)
              {
                  qcril_qmi_voice_request_set_supp_svc(params_ptr, ret_ptr);
              }
              else
              {
                  QCRIL_LOG_INFO( "Unsupported facility type %d for reg or erase", facility_type );
                  qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                             params_ptr->t,
                                                             params_ptr->event_id,
                                                             RIL_E_GENERIC_FAILURE );
              }
              break;

            default:
              {
                QCRIL_LOG_INFO( "Unsupported operation type %d", operation_type );
                qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                           params_ptr->t,
                                                           params_ptr->event_id,
                                                           RIL_E_GENERIC_FAILURE );
              }
          }
        }
        else
        {
          QCRIL_LOG_INFO( "Unsupported facilityType %d", facility_type );
          qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                     params_ptr->t,
                                                     params_ptr->event_id,
                                                     RIL_E_GENERIC_FAILURE );
        }
      }
      else
      {
        QCRIL_LOG_INFO( "facilityType is not present" );
        qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                   params_ptr->t,
                                                   params_ptr->event_id,
                                                   RIL_E_GENERIC_FAILURE );
      }
    }
    else
    {
      QCRIL_LOG_INFO( "operationType is not present" );

      qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                                 params_ptr->t,
                                                 params_ptr->event_id,
                                                 RIL_E_GENERIC_FAILURE );
    }
  }

  QCRIL_LOG_FUNC_RETURN();
}

boolean qcril_qmi_voice_has_specific_call(qcril_qmi_voice_call_filter filter, call_mode_enum_v02 *call_mode)
{
    boolean ret = FALSE;

    if (filter)
    {
        qcril_qmi_voice_voip_lock_overview();
        qcril_qmi_voice_voip_call_info_entry_type *call_info_entry =
            qcril_qmi_voice_voip_call_info_entries_enum_first();

        while ( NULL != call_info_entry )
        {
            if (filter(call_info_entry))
            {
                if(call_mode != NULL)
                {
                    *call_mode = call_info_entry->voice_scv_info.mode;
                }
                ret = TRUE;
                break;
            }
            call_info_entry = qcril_qmi_voice_voip_call_info_entries_enum_next();
        }
        qcril_qmi_voice_voip_unlock_overview();
    }

    return ret;
}
/*=========================================================================
  FUNCTION:  qcril_qmi_voice_reboot_cleanup

===========================================================================*/
/*!
    @brief
    Cleans up globals for reboot
*/
/*=========================================================================*/
int qcril_qmi_voice_reboot_cleanup()
{
  feature_subaddress_support = 0;
  reject_cause_21_supported = FALSE;
  has_wps_pending_dial = FALSE;

  return 0;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_request_call_deflection

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_CALL_DEFLECTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_call_deflection
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  ims_DeflectCall                          *ims_deflect_call_ptr = NULL;
  const char*                               conn_uri = NULL;
  qcril_reqlist_public_type                 reqlist_entry;
  voice_manage_ip_calls_req_msg_v02         manage_ip_calls_req_msg;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  qmi_client_error_type                     client_error;
  uint32_t                                  conn_index;
  uint32                                    user_data;
  RIL_Errno                                 ril_err = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  if(NULL == params_ptr)
  {
    QCRIL_LOG_ERROR("params_ptr is NULL");
    return;
  }

  do
  {
    if(NULL == params_ptr->data)
    {
      QCRIL_LOG_ERROR("params_ptr->data is NULL");
      break;
    }

    ims_deflect_call_ptr = (ims_DeflectCall *)params_ptr->data;
    if((ims_deflect_call_ptr->has_conn_index) && (ims_deflect_call_ptr->number.arg))
    {
      conn_index = ims_deflect_call_ptr->conn_index;
      QCRIL_LOG_INFO("conn_index recieved: %d", conn_index);

      conn_uri = (const char*)ims_deflect_call_ptr->number.arg;
      QCRIL_LOG_INFO("Deflect to conn_uri: %s", conn_uri);
    }
    else
    {
      QCRIL_LOG_ERROR("Request has no valid conn_index or conn_uri");
      break;
    }

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(conn_index);
    if(NULL == call_info_entry)
    {
       QCRIL_LOG_ERROR("Failed to find call entry, aborting!");
       break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_NONE,
                                 NULL,
                                 &reqlist_entry );

    reqlist_entry.valid_sub_id = TRUE;
    reqlist_entry.sub_id = call_info_entry->qmi_call_id;
    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry ) != E_SUCCESS )
    {
      QCRIL_LOG_INFO(".. failed to add requrd to req list");
      break;
    }

    memset( &manage_ip_calls_req_msg, 0, sizeof(manage_ip_calls_req_msg) );
    manage_ip_calls_req_msg.sups_type = VOIP_SUPS_TYPE_CALL_DEFLECTION_V02;
    manage_ip_calls_req_msg.call_id_valid = TRUE;
    manage_ip_calls_req_msg.call_id = call_info_entry->qmi_call_id;
    manage_ip_calls_req_msg.sip_uri_valid = TRUE;
    memcpy( manage_ip_calls_req_msg.sip_uri, conn_uri, strlen(conn_uri) );

    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry.req_id );
    client_error = qmi_client_voice_send_async(QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                                &manage_ip_calls_req_msg,
                                                sizeof(manage_ip_calls_req_msg),
                                                sizeof(voice_manage_ip_calls_resp_msg_v02),
                                                qcril_qmi_voice_command_cb,
                                                (void*)(uintptr_t)user_data);

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(client_error, NULL);
  } while ( FALSE );

  if(ril_err != RIL_E_SUCCESS)
  {
    imsRadioSendMessage(params_ptr->t, ims_MsgType_RESPONSE, ims_MsgId_REQUEST_DEFLECT_CALL, qcril_qmi_ims_map_ril_error_to_ims_error(ril_err), NULL, 0);
  }

  QCRIL_LOG_FUNC_RETURN();
  return;
}

//===========================================================================
// qcril_qmi_voice_set_audio_call_type
//===========================================================================
void qcril_qmi_voice_set_audio_call_type(const voice_call_info2_type_v02* iter_call_info, qcril_qmi_voice_voip_call_info_entry_type *call_info_entry)
{
   call_mode_enum_v02 call_mode;
   call_type_enum_v02 call_type;

   if (NULL == call_info_entry)
   {
      QCRIL_LOG_ERROR("call_info_entry is NULL");
   }
   else
   {
      if (NULL != iter_call_info)
      {
         call_type = iter_call_info->call_type;
         call_mode = iter_call_info->mode;
      }
      else
      {
         call_type = call_info_entry->voice_scv_info.call_type;
         call_mode = call_info_entry->voice_scv_info.mode;
      }

      switch(call_mode)
      {
        case CALL_MODE_NO_SRV_V02:
        case CALL_MODE_UNKNOWN_V02:
          switch(call_type)
          {
            case CALL_TYPE_VOICE_IP_V02:
            case CALL_TYPE_VT_V02:
            case CALL_TYPE_EMERGENCY_IP_V02:
            case CALL_TYPE_EMERGENCY_VT_V02:
              QCRIL_LOG_INFO("Set audio call_type as IMS");
              call_info_entry->audio_call_type = QMI_RIL_VOICE_IMS_AUDIO_CALL_TYPE_IMS;
              break;

            default:
              QCRIL_LOG_INFO("Set audio call_type as VOICE");
              call_info_entry->audio_call_type = QMI_RIL_VOICE_IMS_AUDIO_CALL_TYPE_VOICE;
              break;
          }
          break;

        case CALL_MODE_LTE_V02:
        case CALL_MODE_WLAN_V02:
          QCRIL_LOG_INFO("Set audio call_type as IMS");
          call_info_entry->audio_call_type = QMI_RIL_VOICE_IMS_AUDIO_CALL_TYPE_IMS;
          break;

        default:
          QCRIL_LOG_INFO("Set audio call_type as VOICE");
          call_info_entry->audio_call_type = QMI_RIL_VOICE_IMS_AUDIO_CALL_TYPE_VOICE;
          break;
      }
   }
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_get_current_setup_calls

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_GET_CURRENT_SETUP_CALLS
*/
/*=========================================================================*/
void qcril_qmi_voice_get_current_setup_calls
(
   const qcril_request_params_type *const params_ptr,
   qcril_request_return_type *const ret_ptr
)
{
    qcril_qmi_voice_setup_call_info *payload_ptr = NULL;
    qcril_qmi_voice_voip_call_info_entry_type* call_info_entry = NULL;
    qcril_qmi_voice_current_calls_type *current_calls_type_ptr = NULL;
    qcril_request_resp_params_type resp;
    boolean is_call_present = FALSE;
    RIL_Errno result = RIL_E_GENERIC_FAILURE;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_voice_voip_lock_overview();
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state(CALL_STATE_SETUP_V02);
    do
    {
        if (NULL == call_info_entry)
        {
            result = RIL_E_SUCCESS;
            break;
        }
        is_call_present = TRUE;
        payload_ptr = (qcril_qmi_voice_setup_call_info *) qcril_malloc (sizeof (*payload_ptr));
        if (NULL == payload_ptr)
        {
            break;
        }
        memset (payload_ptr, 0, sizeof (*payload_ptr));
        current_calls_type_ptr = (qcril_qmi_voice_current_calls_type *) qcril_malloc (sizeof (*current_calls_type_ptr));
        if (NULL == current_calls_type_ptr)
        {
            break;
        }
        memset (current_calls_type_ptr, 0, sizeof (*current_calls_type_ptr));
        if (RIL_E_SUCCESS != qcril_qmi_voice_gather_current_call_information(
                                0, params_ptr, current_calls_type_ptr, call_info_entry))
        {
            break;
        }

        payload_ptr->index = current_calls_type_ptr->info[0].index;
        payload_ptr->toa = current_calls_type_ptr->info[0].toa;
        payload_ptr->als = current_calls_type_ptr->info[0].als;
        payload_ptr->isVoice = current_calls_type_ptr->info[0].isVoice;
        if (NULL != current_calls_type_ptr->info[0].number)
            strlcpy (payload_ptr->number, current_calls_type_ptr->info[0].number, QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
        payload_ptr->numberPresentation = current_calls_type_ptr->info[0].numberPresentation;
        if (NULL != current_calls_type_ptr->info[0].name)
            strlcpy (payload_ptr->name, current_calls_type_ptr->info[0].name, QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
        payload_ptr->namePresentation = current_calls_type_ptr->info[0].namePresentation;

        result = RIL_E_SUCCESS;
    } while (FALSE);

    qcril_qmi_voice_voip_unlock_overview();

    if (RIL_E_SUCCESS == result)
    {
        QCRIL_LOG_INFO ("Reply to OEM --> is_call_present %d", is_call_present);
        qcril_default_request_resp_params (QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp);
        if (is_call_present)
        {
            QCRIL_LOG_INFO ("Reply to OEM --> index %d, toa %d, als %d, isVoice %d",
                           payload_ptr->index,
                           payload_ptr->toa,
                           payload_ptr->als,
                           payload_ptr->isVoice);

            QCRIL_LOG_INFO ("...num %s, num presentation %d, name %s, name presentation %d",
                           payload_ptr->number,
                           payload_ptr->numberPresentation,
                           payload_ptr->name,
                           payload_ptr->namePresentation);
            resp.resp_pkt = (void *) payload_ptr;
            resp.resp_len = sizeof (*payload_ptr);
        }
    }
    else
    {
        qcril_default_request_resp_params (QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp);
    }
    qcril_send_request_response (&resp );
    if (current_calls_type_ptr)
        qcril_free (current_calls_type_ptr);
    if (payload_ptr)
        qcril_free (payload_ptr);
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_get_current_setup_calls

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_request_setup_answer

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_REQUEST_SETUP_ANSWER
*/
/*=========================================================================*/
void qcril_qmi_voice_request_setup_answer
(
   const qcril_request_params_type *const params_ptr,
   qcril_request_return_type *const ret_ptr
)
{
    qcril_qmi_voice_voip_call_info_entry_type*                          call_info_entry = NULL;
    voice_setup_answer_req_msg_v02                                      setup_answer_req_msg;
    qcril_qmi_voice_setup_answer_data_type*                             data = NULL;
    uint32_t                                                            user_data;
    qcril_reqlist_public_type                                           reqlist_entry;
    qmi_ril_voice_ims_command_exec_oversight_type*                      command_oversight = NULL;;
    qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type   oversight_cmd_params;
    RIL_Errno                                                           result = RIL_E_GENERIC_FAILURE;
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_voice_voip_lock_overview();
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_qmi_call_state (CALL_STATE_SETUP_V02);
    do
    {
        if (RIL_E_SUCCESS != qcril_qmi_voice_perform_null_check_and_reqlist_entry
                             (params_ptr, &user_data, &reqlist_entry) ||
            !call_info_entry)
        {
            QCRIL_LOG_ERROR("Failure. call_info_entry %p", call_info_entry);
            break;
        }

        command_oversight = qmi_ril_voice_ims_create_command_oversight (params_ptr->t, params_ptr->event_id, TRUE);
        if ( NULL == command_oversight )
        {
            break;
        }
        data = (qcril_qmi_voice_setup_answer_data_type *) params_ptr->data;
        qmi_ril_voice_ims_command_oversight_add_call_link (command_oversight,
                                                     QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_QMI_CALL_ID,
                                                     QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_NONE,
                                                     call_info_entry->qmi_call_id,
                                                     data->rejection ? CALL_STATE_END_V02 : CALL_STATE_INCOMING_V02);

        memset (&oversight_cmd_params, 0, sizeof (oversight_cmd_params));
        oversight_cmd_params.locator.command_oversight = command_oversight;

        qmi_ril_voice_ims_command_oversight_handle_event (QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_COMMENCE_AWAIT_RESP_IND,
                                                        QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                                        &oversight_cmd_params);

        memset (&setup_answer_req_msg, 0, sizeof (setup_answer_req_msg));
        setup_answer_req_msg.call_id = call_info_entry->qmi_call_id;
        setup_answer_req_msg.reject_setup_valid = TRUE;
        setup_answer_req_msg.reject_setup = data->rejection;
        if (QMI_NO_ERR != qmi_client_voice_send_async(
                                QMI_VOICE_SETUP_ANSWER_REQ_V02,
                                &setup_answer_req_msg,
                                sizeof (setup_answer_req_msg),
                                sizeof (voice_setup_answer_resp_msg_v02),
                                qcril_qmi_voice_command_cb,
                                (void *)(intptr_t) user_data))
        {
            QCRIL_LOG_ERROR("failed to send setup answer request: qmi call id %d, rejection %d",
                       setup_answer_req_msg.call_id, setup_answer_req_msg.reject_setup);
            break;
        }
        QCRIL_LOG_INFO("successfully sent setup answer request: qmi call id %d, rejection %d",
                       setup_answer_req_msg.call_id, setup_answer_req_msg.reject_setup);
        result = RIL_E_SUCCESS;
    } while (FALSE);

    if (RIL_E_SUCCESS != result)
    {
        if (NULL != command_oversight)
            qmi_ril_voice_ims_destroy_command_oversight( command_oversight );
        qcril_send_empty_payload_request_response (QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, result);
    }

    qcril_qmi_voice_voip_unlock_overview();
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_voice_request_setup_answer

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_setup_answer_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handles response QMI_VOICE_SETUP_ANSWER_RESP_V02
*/
/*=========================================================================*/
void qcril_qmi_voice_setup_answer_resp_hdlr
(
   const qcril_request_params_type *const params_ptr
)
{
    voice_setup_answer_resp_msg_v02*                                    setup_answer_resp_ptr = NULL;
    qmi_ril_voice_ims_command_exec_oversight_handle_event_params_type   oversight_event_params;
    qmi_ril_voice_ims_command_exec_oversight_type*                      command_oversight = NULL;
    int                                                                 covered_by_oversight_handling = FALSE;
    RIL_Errno                                                           result = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();
    setup_answer_resp_ptr = (voice_setup_answer_resp_msg_v02 *) params_ptr->data;
    qcril_qmi_voice_voip_lock_overview();
    if (setup_answer_resp_ptr)
    {
        result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result (QMI_NO_ERR, &setup_answer_resp_ptr->resp);
        QCRIL_LOG_INFO("QMI result %d, QMI error %d, RIL result %d",
                       setup_answer_resp_ptr->resp.result, setup_answer_resp_ptr->resp.error, result);
        command_oversight = qmi_ril_voice_ims_find_command_oversight_by_token (params_ptr->t);
        if (NULL != command_oversight)
        {
            memset (&oversight_event_params, 0, sizeof (oversight_event_params));
            oversight_event_params.locator.command_oversight = command_oversight;
            covered_by_oversight_handling = qmi_ril_voice_ims_command_oversight_handle_event
                                            (
                                               (RIL_E_SUCCESS == result)?
                                               QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_SUCCESS :
                                               QMI_RIL_VOICE_IMS_EXEC_INTERMED_EVENT_RECEIVED_RESP_FAILURE,
                                               QMI_RIL_VOICE_IMS_EXEC_OVERSIGHT_LINKAGE_SPECIFIC_OVERSIGHT_OBJ,
                                               &oversight_event_params
                                            );
        }
    }
    qcril_qmi_voice_voip_unlock_overview();
    if (NULL == command_oversight || !covered_by_oversight_handling)
    {
        qcril_send_empty_payload_request_response (QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, result);
    }
    QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION: qcril_qmi_voice_perform_null_check_and_reqlist_entry

===========================================================================*/
RIL_Errno qcril_qmi_voice_perform_null_check_and_reqlist_entry
(
   const qcril_request_params_type *const params_ptr,
   uint32_t *user_data_ptr,
   qcril_reqlist_public_type *reqlist_entry_ptr
)
{
    RIL_Errno result = RIL_E_GENERIC_FAILURE;
    do
    {
        if (NULL == params_ptr || NULL == user_data_ptr)
        {
            QCRIL_LOG_ERROR("failure: NULL pointer. params_ptr %p, user_data_ptr %p",
                            params_ptr, user_data_ptr);
            break;
        }
        if (NULL == params_ptr->data || 0 == params_ptr->datalen)
        {
            QCRIL_LOG_ERROR("failure: params_ptr->data %p, params_ptr->datalen %d",
                           params_ptr->data, (int) params_ptr->datalen);
            break;
        }
        qcril_reqlist_default_entry (params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_NONE,
                                     NULL,
                                     reqlist_entry_ptr);
        if (E_SUCCESS != qcril_reqlist_new (QCRIL_DEFAULT_INSTANCE_ID, reqlist_entry_ptr))
        {
            QCRIL_LOG_ERROR("failure: could not add entry to reqlist");
            break;
        }
        *user_data_ptr = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, reqlist_entry_ptr->req_id);
        result = RIL_E_SUCCESS;
    } while (FALSE);
    QCRIL_LOG_FUNC_RETURN_WITH_RET(result);
    return result;
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_request_get_colr

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_GET_COLR.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_get_colr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type    reqlist_entry;
  uint32                       user_data;
  RIL_Errno                    res = RIL_E_GENERIC_FAILURE;
  QCRIL_NOTUSED(ret_ptr);

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    /* Add entry to ReqList */
    qcril_reqlist_default_entry(params_ptr->t,
            params_ptr->event_id,
            QCRIL_DEFAULT_MODEM_ID,
            QCRIL_REQ_AWAITING_CALLBACK,
            QCRIL_EVT_NONE,
            NULL,
            &reqlist_entry);

    if (qcril_reqlist_new(QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry) != E_SUCCESS)
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            reqlist_entry.req_id);

    /* Send QMI VOICE DIAL CALL REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                         QMI_VOICE_GET_COLR_REQ_V02,
                                         NULL,
                                         0,
                                         sizeof(voice_get_colr_resp_msg_v02),
                                         qcril_qmi_voice_command_cb,
                                         (void*)(uintptr_t)user_data);
    QCRIL_LOG_INFO(".. qmi send async res %d", (int) qmi_client_error );
    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error, NULL);
  } while(FALSE);

  if (res != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
            params_ptr->t,
            params_ptr->event_id,
            res);
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_get_colr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_get_colr_resp_hdlr

===========================================================================*/
/*!
    @brief
    Handle QMI VOICE GET COLR RESP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_get_colr_resp_hdlr
(
  const qcril_request_params_type *const params_ptr
)
{
  voice_get_colr_resp_msg_v02 *get_colr_resp = NULL;
  RIL_Errno ril_result = RIL_E_GENERIC_FAILURE;
  ims_Error ims_error = ims_Error_E_GENERIC_FAILURE;
  qmi_error_type_v01 qmi_error;
  qcril_instance_id_e_type instance_id;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  if( params_ptr->data != NULL )
  {
    get_colr_resp = (voice_get_colr_resp_msg_v02 *)params_ptr->data;
    qmi_error = get_colr_resp->resp.error;

    ril_result = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
      QMI_NO_ERR,
      &get_colr_resp->resp);
    if(RIL_E_SUCCESS == ril_result)
    {
      QCRIL_LOG_INFO("QCRIL QMI VOICE GET COLR RESP: SUCCESS");
    }
    else
    {
      QCRIL_LOG_INFO("QCRIL QMI VOICE GET COLR RESP: FAILURE");
    }
    if (params_ptr->event_id == QCRIL_EVT_IMS_SOCKET_REQ_GET_COLR)
    {
      ims_Colr colr;
      memset(&colr, 0, sizeof(colr));
      qcril_qmi_voice_copy_colr_data(get_colr_resp, &colr, ril_result, &ims_error);

      imsRadioSendMessage(params_ptr->t,
        ims_MsgType_RESPONSE,
        ims_MsgId_REQUEST_GET_COLR,
        ims_error,
        (void *)&colr,
        sizeof(colr));
      if (colr.has_errorDetails)
      {
        if (colr.errorDetails.sipErrorString.arg)
        {
          qcril_free(colr.errorDetails.sipErrorString.arg);
        }
      }
    }
  }
  else
  {
    QCRIL_LOG_ERROR("params_ptr->data is NULL");
    qcril_send_empty_payload_request_response(instance_id,
      params_ptr->t,
      params_ptr->event_id,
      RIL_E_GENERIC_FAILURE);
  }
}/* qcril_qmi_voice_get_colr_resp_hdlr */

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_request_set_colr

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_IMS_SOCKET_REQ_SET_COLR.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_request_set_colr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_reqlist_public_type  reqlist_entry;
  RIL_Errno                  res = RIL_E_GENERIC_FAILURE;
  uint32                     user_data;
  ims_Colr                 *ims_colr_ptr = NULL;

  voice_set_sups_service_req_msg_v02   set_sups_req;
  QCRIL_NOTUSED(ret_ptr);

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
    {
      QCRIL_LOG_INFO( "params_ptr->datalen == 0 or params_ptr is NULL" );
      break;
    }

    ims_colr_ptr = (ims_Colr *) params_ptr->data;

    /* Add entry to ReqList */
    qcril_reqlist_default_entry(params_ptr->t,
            params_ptr->event_id,
            QCRIL_DEFAULT_MODEM_ID,
            QCRIL_REQ_AWAITING_CALLBACK,
            QCRIL_EVT_NONE,
            NULL,
            &reqlist_entry );
    if (qcril_reqlist_new(QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry) != E_SUCCESS)
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      break;
    }

    memset(&set_sups_req, 0, sizeof(set_sups_req));

    QCRIL_LOG_INFO( "has_presentation: %d, presentation: %d",
          ims_colr_ptr->has_presentation,
          ims_colr_ptr->presentation);

    if (ims_colr_ptr->has_presentation)
    {
      set_sups_req.supplementary_service_info.reason = (voice_reason_enum_v02)QMI_VOICE_REASON_COLR_V02;

      set_sups_req.colr_pi_valid = TRUE;
      if (ims_colr_ptr->presentation == ims_IpPresentation_IP_PRESENTATION_NUM_RESTRICTED)
      {
        set_sups_req.supplementary_service_info.voice_service = VOICE_SERVICE_ACTIVATE_V02;
        set_sups_req.colr_pi = COLR_PRESENTATION_RESTRICTED_V02;
      }
      else if (ims_colr_ptr->presentation == ims_IpPresentation_IP_PRESENTATION_NUM_ALLOWED)
      {
        set_sups_req.supplementary_service_info.voice_service = VOICE_SERVICE_DEACTIVATE_V02;
        set_sups_req.colr_pi = COLR_PRESENTATION_NOT_RESTRICTED_V02;
      }
      else
      {
        QCRIL_LOG_ERROR("requested colr is not a valid value");
        break;
      }
    }
    else
    {
      QCRIL_LOG_ERROR("request misses some necessary information");
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA(QCRIL_DEFAULT_INSTANCE_ID,
            QCRIL_DEFAULT_MODEM_ID,
            reqlist_entry.req_id);

    /* Send QMI VOICE SET SUPS SERVICE REQ */
    qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                          QMI_VOICE_SET_SUPS_SERVICE_REQ_V02,
                                          &set_sups_req,
                                          sizeof(set_sups_req),
                                          sizeof(voice_set_sups_service_resp_msg_v02),
                                          qcril_qmi_voice_command_cb,
                                          (void*)(uintptr_t)user_data);
    QCRIL_LOG_INFO(".. qmi send async res %d", (int) qmi_client_error );
    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error, NULL);
  } while(FALSE);

  if (res != RIL_E_SUCCESS)
  {
    qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
            params_ptr->t,
            params_ptr->event_id,
            res);
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_voice_request_set_colr */

void qcril_qmi_voice_voip_reset_answered_call_type
(
 qcril_qmi_voice_voip_call_info_entry_type *call_info,
 voice_modified_ind_msg_v02                *modify_ind_ptr
)
{
  if(call_info != NULL && call_info->answered_call_type_valid)
  {
    if (call_info->voice_scv_info.call_type == CALL_TYPE_VT_V02)
    {
      if ((modify_ind_ptr->audio_attrib_valid && 0 != modify_ind_ptr->audio_attrib) &&
          (modify_ind_ptr->video_attrib_valid && 0 != modify_ind_ptr->video_attrib))
      {
        call_info->answered_call_type_valid = FALSE;
      }
    }
    else if (call_info->voice_scv_info.call_type == CALL_TYPE_VOICE_IP_V02)
    {
      if (modify_ind_ptr->audio_attrib_valid && 0 != modify_ind_ptr->audio_attrib)
      {
        call_info->answered_call_type_valid = FALSE;
      }
    }
  }
}

//===========================================================================
// map_qmi_call_type_to_ril_type
//===========================================================================
RIL_Call_Type map_qmi_call_type_to_ril_type(call_type_enum_v02 call_type) {
  switch (call_type) {
    case CALL_TYPE_VT_V02:
    case CALL_TYPE_EMERGENCY_VT_V02:
    case CALL_TYPE_VIDEOSHARE_V02:
      return RIL_CALL_TYPE_VT;
    default:
      return RIL_CALL_TYPE_VOICE;
  }
} // map_qmi_call_type_to_ril_type

//===========================================================================
// qcril_qmi_voice_send_ims_unsol_call_state_changed
//===========================================================================
void qcril_qmi_voice_send_ims_unsol_call_state_changed()
{
    qcril_request_params_type params;
    memset(&params, 0, sizeof(params));
    params.event_id = QCRIL_EVT_IMS_SOCKET_SEND_UNSOL_CURRENT_CALLS;
    qcril_qmi_voice_send_current_ims_calls(&params, NULL);
} // qcril_qmi_voice_send_ims_unsol_call_state_changed

//===========================================================================
// qcril_qmi_voice_is_ims_send_calls
//===========================================================================
boolean qcril_qmi_voice_is_ims_send_calls(qcril_evt_e_type event_id)
{
    return event_id == QCRIL_EVT_IMS_SOCKET_REQ_GET_CURRENT_CALLS ||
           event_id == QCRIL_EVT_IMS_SOCKET_SEND_UNSOL_CURRENT_CALLS;
} // qcril_qmi_voice_is_ims_send_calls

void qcril_qmi_voice_send_wps_dial_request(void)
{
  QCRIL_LOG_FUNC_ENTRY();

  qmi_client_error_type qmi_client_error = qmi_client_voice_send_async(
                                 QMI_VOICE_DIAL_CALL_REQ_V02,
                                 &wps_dial_request,
                                 sizeof(voice_dial_call_req_msg_v02),
                                 sizeof(voice_dial_call_resp_msg_v02),
                                 qcril_qmi_voice_command_cb,
                                 (void*)(uintptr_t)wps_user_data);
  RIL_Errno res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                    qmi_client_error, NULL);
  if (RIL_E_SUCCESS != res) {
    QCRIL_LOG_ERROR("Error dialing wps call: %d", res);
  }

  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_voice_send_simulated_SRVCC_ind(void)
{
  qcril_unsol_resp_params_type unsol_resp;
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();

  qcril_default_unsol_resp_params(instance_id, RIL_UNSOL_SRVCC_STATE_NOTIFY ,&unsol_resp);
  RIL_SrvccState ril_srvccstate;
  unsol_resp.resp_pkt = &ril_srvccstate;
  unsol_resp.resp_len = sizeof(RIL_SrvccState);

  ril_srvccstate = HANDOVER_STARTED;
  qcril_send_unsol_response(&unsol_resp);
  qcril_qmi_voice_send_ims_unsol_resp_handover(ril_srvccstate);

  ril_srvccstate = HANDOVER_COMPLETED;
  qcril_send_unsol_response(&unsol_resp);
  qcril_qmi_voice_send_ims_unsol_resp_handover(ril_srvccstate);

  QCRIL_LOG_FUNC_RETURN();
}


/*=========================================================================
  FUNCTION:  qcril_qmi_voice_update_set_local_call_hold_response_state

===========================================================================*/
/*!
    @brief
    Send SET_LOCAL_CALL_HOLD response to Telephony

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_update_set_local_call_hold_response_state
(
  qcril_reqlist_public_type *req_info,
  uint32 completed_state,
  qmi_result_type_v01 qmi_result,
  qmi_error_type_v01 qmi_error
)
{
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
    boolean   send_response = FALSE;
    uint32    state = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if (!req_info)
    {
        QCRIL_LOG_FUNC_RETURN();
        return;
    }

    QCRIL_LOG_INFO("request = %s", qcril_log_lookup_event_name(req_info->request));

    if (req_info->request == QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD ||
        req_info->request == QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD_v01)
    {
        QCRIL_LOG_INFO(".. token = %d; completed_state = 0x%X, qmi_result = %d qmi_error = %d",
                req_info->t, completed_state, qmi_result, qmi_error);

        state = req_info->state[QCRIL_DEFAULT_INSTANCE_ID];

        QCRIL_LOG_INFO("req_info state = 0x%X", state);

        // Clear the completed state
        state &= ~completed_state;

        if (state == QCRIL_REQ_COMPLETED_SUCCESS)
        {
            send_response = TRUE;
            ril_err = qcril_qmi_client_map_qmi_err_to_ril_err(qmi_error);
        }
        else if (state == QCRIL_REQ_COMPLETED_FAILURE)
        {
            send_response = TRUE;
            ril_err = RIL_E_GENERIC_FAILURE;
        }
        else
        {
            QCRIL_LOG_INFO(".. still pending events..");
            // Update the state and wait for Modem response/Audio response
            if(qmi_result == QMI_RESULT_SUCCESS_V01)
            {
                state |= QCRIL_REQ_COMPLETED_SUCCESS;
            }
            else
            {
                state |= QCRIL_REQ_COMPLETED_FAILURE;
            }
        }

        QCRIL_LOG_INFO(".. send_response = %d", send_response);
        if (send_response)
        {
            qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
                    req_info->t,
                    req_info->request,
                    ril_err);
        }
        else
        {
            QCRIL_LOG_INFO("updating state to 0x%X", state);
            qcril_reqlist_update_state( QCRIL_DEFAULT_INSTANCE_ID,
                    QCRIL_DEFAULT_MODEM_ID,
                    req_info->t,
                    (qcril_req_state_e_type)state);
        }
    }
    QCRIL_LOG_FUNC_RETURN();
}  // qcril_qmi_voice_update_set_local_call_hold_response_state

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_am_lch_complete_handler

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_QMI_VOICE_AM_LCH_COMPLETE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_voice_am_lch_complete_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_reqlist_public_type req_info;
    QCRIL_NOTUSED(params_ptr);
    QCRIL_NOTUSED(ret_ptr);

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO(".. LCH complete");

    if ((qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                QCRIL_DEFAULT_MODEM_ID,
                QCRIL_EVT_HOOK_SET_LOCAL_CALL_HOLD,
                &req_info ) == E_SUCCESS) &&
            req_info.req_data)
    {
        QCRIL_LOG_INFO(".. pending LCH request in queue; update the response status");
        qcril_qmi_voice_update_set_local_call_hold_response_state(&req_info,
                QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS, QMI_RESULT_SUCCESS_V01, QMI_ERR_NONE_V01);
    }
    QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_send_ims_unsol_resp_handover

===========================================================================*/
/*!
    @brief
    Sends UNSOL_RESPONSE_HANDOVER on IMS socket.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_voice_send_ims_unsol_resp_handover(RIL_SrvccState ril_srvccstate)
{
    ims_Handover ims_handover;
    memset(&ims_handover, 0, sizeof(ims_handover));

    ims_handover.has_type = TRUE;
    switch(ril_srvccstate)
    {
    case HANDOVER_STARTED:
        ims_handover.type = ims_Handover_Msg_Type_START;
        break;
    case HANDOVER_COMPLETED:
        ims_handover.type = ims_Handover_Msg_Type_COMPLETE_SUCCESS;
        break;
    case HANDOVER_FAILED:
        ims_handover.type = ims_Handover_Msg_Type_COMPLETE_FAIL;
        break;
    case HANDOVER_CANCELED:
        ims_handover.type = ims_Handover_Msg_Type_CANCEL;
        break;
    default:
        ims_handover.has_type = FALSE;
        break;
    }

    QCRIL_LOG_INFO("Send UNSOL_RESPONSE_HANDOVER has_type = %d, type = %d",
            ims_handover.has_type, ims_handover.type);

    if (ims_handover.has_type)
    {
        imsRadioSendMessage(
                0,
                ims_MsgType_UNSOL_RESPONSE,
                ims_MsgId_UNSOL_RESPONSE_HANDOVER,
                ims_Error_E_SUCCESS,
                &ims_handover,
                sizeof(ims_handover));
    }
}

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_retry_call_end

===========================================================================*/
/*!
      @brief
      Retry call end request without optional tlvswhen it fails because
      of malformed qmi message.

      @param qmi_call_id
      Call id on which the call end request failed

      @param t
      Use the same token as the original request

      @param request
      Request id of the original request

      @return
      None.
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_voice_retry_call_end
(
  RIL_Token token,
  qcril_evt_e_type request
)
{
  uint32                                          user_data;
  voice_end_call_req_msg_v02                      call_end_req_msg;
  RIL_Errno                                       ril_err = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type                       req_info;
  int                                             conn_index = 0;
  qcril_qmi_voice_voip_call_info_entry_type*      call_info_entry = NULL;
  QCRIL_NOTUSED(request);

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if (E_SUCCESS != qcril_reqlist_query(QCRIL_DEFAULT_INSTANCE_ID,
                                             token,
                                             &req_info))
    {
      QCRIL_LOG_ERROR("Request not found");
      break;
    }


    // preparation
    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         req_info.req_id);

    memset( &call_end_req_msg, 0, sizeof(call_end_req_msg) );

    if( NULL == req_info.req_data )
    {
      QCRIL_LOG_ERROR("Request data is null");
      break;
    }

    conn_index = *((int*)req_info.req_data);
    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(conn_index);
    if (call_info_entry == NULL)
    {
        QCRIL_LOG_ERROR("Failed to find call entry for conn_index: %d, aborting!", conn_index);
        break;
    }
    QCRIL_LOG_DEBUG("android conn_index = %d, qmi call id = %d", conn_index,
            call_info_entry->qmi_call_id);

    call_end_req_msg.call_id = call_info_entry->qmi_call_id;

    qmi_client_error_type transp_err = qmi_client_voice_send_async(
                                           QMI_VOICE_END_CALL_REQ_V02,
                                           &call_end_req_msg,
                                           sizeof(call_end_req_msg),
                                           sizeof(voice_end_call_resp_msg_v02),
                                           qcril_qmi_voice_command_cb,
                                           (void*)(uintptr_t)user_data);
    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(
                                           transp_err, nullptr);
  } while(FALSE);

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_err);

  return ril_err;
}

void qcril_qmi_send_hangup_response(qcril_evt_e_type request,
                                    RIL_Token token,
                                    RIL_Errno result)
{
  qcril_send_empty_payload_request_response( QCRIL_DEFAULT_INSTANCE_ID,
                                             token,
                                             request,
                                             result );
  hangup_retry_attempted = FALSE;
}

void qcril_qmi_voice_reset_ussd_power_opt_buffer()
{
    QCRIL_LOG_INFO("Reset USSD Power Opt buffer");
    qcril_qmi_voice_info.ussd_info_buffer_for_opt_valid = FALSE;
    qcril_qmi_voice_info.ussd_info_buffer_for_opt_len = 0;
    memset(&qcril_qmi_voice_info.ussd_info_buffer_for_opt,0,sizeof(qcril_qmi_voice_info.ussd_info_buffer_for_opt));
}

void qcril_qmi_voice_update_ussd_power_opt_buffer(voice_ussd_ind_msg_v02 *ind_data_ptr)
{
    int length = 0;

    QCRIL_LOG_FUNC_ENTRY();

    do
    {
        if(NULL == ind_data_ptr)
            break;

        if(!qcril_qmi_voice_info.ussd_info_buffer_for_opt_valid)
        {
            qcril_qmi_voice_info.ussd_info_buffer_for_opt_valid = TRUE;
            qcril_qmi_voice_info.ussd_info_buffer_for_opt_len = 0;
        }

        length = qcril_qmi_voice_info.ussd_info_buffer_for_opt_len;
        if(length == MAX_USSD_INFO_FOR_POWER_OPT)
            break;

        memcpy(&qcril_qmi_voice_info.ussd_info_buffer_for_opt[length], ind_data_ptr, sizeof(voice_ussd_ind_msg_v02));
        qcril_qmi_voice_info.ussd_info_buffer_for_opt_len++;
        QCRIL_LOG_INFO("USSD Power Opt buffer length %d", qcril_qmi_voice_info.ussd_info_buffer_for_opt_len);
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_voice_notify_ussd_power_opt_to_atel()
{
    int i = 0;
    int length = 0;

    QCRIL_LOG_INFO("USSD Power Opt buffer valid %d", qcril_qmi_voice_info.ussd_info_buffer_for_opt_valid);
    if(qcril_qmi_voice_info.ussd_info_buffer_for_opt_valid)
    {
        length = qcril_qmi_voice_info.ussd_info_buffer_for_opt_len;
        QCRIL_LOG_INFO("USSD Power Opt buffer length %d", qcril_qmi_voice_info.ussd_info_buffer_for_opt_len);
        for(i=0; i<length; i++)
        {
            qcril_qmi_voice_ussd_ind_hdlr(&qcril_qmi_voice_info.ussd_info_buffer_for_opt[i], sizeof(voice_ussd_ind_msg_v02));
        }

        qcril_qmi_voice_reset_ussd_power_opt_buffer();
    }
}

//===========================================================================
// QCRIL_EVT_IMS_SOCKET_REQ_EXPLICIT_CALL_TRANSFER
//===========================================================================
void qcril_qmi_voice_request_explicit_call_transfer
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  QCRIL_NOTUSED(ret_ptr);
  QCRIL_LOG_FUNC_ENTRY();

  uint32                              user_data;
  qcril_reqlist_public_type           reqlist_entry;
  ims_ExplicitCallTransfer            *ims_ect = NULL;
  voice_manage_ip_calls_req_msg_v02   manage_ip_calls_req_msg;
  qcril_qmi_voice_voip_call_info_entry_type *call_info_entry = NULL;
  qcril_qmi_voice_voip_call_info_entry_type *target_call_info_entry = NULL;
  qmi_client_error_type               client_error;
  RIL_Errno                           ril_err = RIL_E_GENERIC_FAILURE;

  do
  {
    if ( NULL == params_ptr || NULL == params_ptr->data)
    {
      QCRIL_LOG_INFO( "params_ptr or params_ptr->data is NULL" );
      break;
    }

    ims_ect = (ims_ExplicitCallTransfer *)params_ptr->data;

    /* Add entry to ReqList */
    qcril_reqlist_default_entry(params_ptr->t,
            params_ptr->event_id,
            QCRIL_DEFAULT_MODEM_ID,
            QCRIL_REQ_AWAITING_CALLBACK,
            QCRIL_EVT_NONE,
            NULL,
            &reqlist_entry );
    if (qcril_reqlist_new(QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry) != E_SUCCESS)
    {
      /* Fail to add entry to ReqList */
      QCRIL_LOG_ERROR("Failed to Add into Req list");
      break;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         reqlist_entry.req_id);

    memset( &manage_ip_calls_req_msg, 0, sizeof(manage_ip_calls_req_msg) );
    manage_ip_calls_req_msg.sups_type = VOIP_SUPS_TYPE_EXPLICIT_CALL_TRANSFER_V02;
    if( !(ims_ect->has_callId && ims_ect->has_ectType) )
    {
      QCRIL_LOG_ERROR("Mandatory params missing");
      QCRIL_LOG_ERROR("has_callId: %d, has_ectType: %d",
                             ims_ect->has_callId, ims_ect->has_ectType);
      break;
    }

    call_info_entry = qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(ims_ect->callId);
    if(NULL == call_info_entry)
    {
       QCRIL_LOG_ERROR("Failed to find call entry, aborting!");
       break;
    }

    if(ims_ect->has_targetCallId)
    {
      QCRIL_LOG_INFO("targetCallId: %d", ims_ect->targetCallId);
      target_call_info_entry =
          qcril_qmi_voice_voip_find_call_info_entry_by_call_android_id(
                                                   ims_ect->targetCallId);
      if(NULL == target_call_info_entry)
      {
        QCRIL_LOG_ERROR("Failed to find target call entry, aborting!");
        break;
      }

      manage_ip_calls_req_msg.transfer_target_call_id_valid = ims_ect->has_targetCallId;
      manage_ip_calls_req_msg.transfer_target_call_id = target_call_info_entry->qmi_call_id;
    }

    QCRIL_LOG_INFO("callId: %d, ectType: %d", ims_ect->callId, ims_ect->ectType);
    manage_ip_calls_req_msg.call_id_valid = ims_ect->has_callId;
    manage_ip_calls_req_msg.call_id = call_info_entry->qmi_call_id;
    if(qcril_qmi_ims_map_ims_ect_type_to_qmi_ect_type(ims_ect->ectType,
                                         &manage_ip_calls_req_msg.ect_type))
    {
      manage_ip_calls_req_msg.ect_type_valid = TRUE;
    }
    else
    {
      QCRIL_LOG_ERROR("Failed to map ims ect_type %d to qmi ect_type", ims_ect->ectType);
      break;
    }

    if(ims_ect->targetAddress.arg)
    {
      QCRIL_LOG_INFO("targetAddress: %s", ims_ect->targetAddress.arg);

      manage_ip_calls_req_msg.sip_uri_valid = TRUE;
      strlcpy( manage_ip_calls_req_msg.sip_uri,
              (const char*)ims_ect->targetAddress.arg,
              sizeof(manage_ip_calls_req_msg.sip_uri));
    }

    client_error = qmi_client_voice_send_async(QMI_VOICE_MANAGE_IP_CALLS_REQ_V02,
                                                &manage_ip_calls_req_msg,
                                                sizeof(manage_ip_calls_req_msg),
                                                sizeof(voice_manage_ip_calls_resp_msg_v02),
                                                qcril_qmi_voice_command_cb,
                                                (void*)(uintptr_t)user_data );

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(client_error, NULL);
  }while(FALSE);

  if(ril_err != RIL_E_SUCCESS)
  {
    if(params_ptr)
    {
      imsRadioSendMessage(params_ptr->t,
                             ims_MsgType_RESPONSE,
                             ims_MsgId_REQUEST_EXPLICIT_CALL_TRANSFER,
                             qcril_qmi_ims_map_ril_error_to_ims_error(ril_err),
                             NULL, 0);
    }
  }

  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_voice_update_voice_registration_status(voiceRegStatusStruct& voiceReg)
{
  // no lock needed for qcril_qmi_voice_nas_reported_info
  qcril_qmi_voice_nas_reported_info.voice_state_valid = voiceReg.stateValid;
  qcril_qmi_voice_nas_reported_info.voice_state = voiceReg.state;
  qcril_qmi_voice_nas_reported_info.voice_radio_tech_valid = voiceReg.radioTechValid;
  qcril_qmi_voice_nas_reported_info.voice_radio_tech = voiceReg.radioTech;
  qcril_qmi_voice_nas_reported_info.status_overview_valid = voiceReg.statusOverviewValid;
  qcril_qmi_voice_nas_reported_info.status_overview = voiceReg.statusOverview;
}

void qcril_qmi_voice_update_service_rte_info(networkRteStruct& networkRte)
{
  // no lock needed for qcril_qmi_voice_nas_reported_info
  qcril_qmi_voice_nas_reported_info.voice_rte_valid = networkRte.voiceRteValid;
  qcril_qmi_voice_nas_reported_info.voice_rte = networkRte.voiceRte;
  qcril_qmi_voice_nas_reported_info.data_rte_valid = networkRte.dataRteValid;
  qcril_qmi_voice_nas_reported_info.data_rte = networkRte.dataRte;
  qcril_qmi_voice_nas_reported_info.ims_rte_valid = networkRte.imsRteValid;
  qcril_qmi_voice_nas_reported_info.ims_rte = networkRte.imsRte;
}

uint8_t qcril_qmi_voice_cancel_pending_emergency_call(void)
{
  uint8_t is_pending_ecall_clearing_status = FALSE;

  QCRIL_LOG_FUNC_ENTRY();
  PEND_EMER_LOCK();
  if (TRUE == qcril_qmi_pending_emergency_call_info.is_emergency_call_pending)
  {
    QCRIL_LOG_DEBUG("cancel pending emergency call...");
    is_pending_ecall_clearing_status = TRUE;
    qcril_qmi_pending_emergency_call_info.is_emergency_call_pending = FALSE;

    // Add an entry to the reqlist to ensure the send function
    // returns the response properly.
    qcril_reqlist_public_type reqlist_entry;
    qcril_reqlist_default_entry(qcril_qmi_pending_emergency_call_info.emergency_params_ptr.t,
        qcril_qmi_pending_emergency_call_info.emergency_params_ptr.event_id,
        QCRIL_DEFAULT_MODEM_ID,
        QCRIL_REQ_AWAITING_CALLBACK,
        QCRIL_EVT_NONE,
        NULL,
        &reqlist_entry);
    qcril_reqlist_new(QCRIL_DEFAULT_INSTANCE_ID, &reqlist_entry);

    qcril_send_empty_payload_request_response(QCRIL_DEFAULT_INSTANCE_ID,
                                qcril_qmi_pending_emergency_call_info.emergency_params_ptr.t,
                                qcril_qmi_pending_emergency_call_info.emergency_params_ptr.event_id,
                                RIL_E_GENERIC_FAILURE);
  }
  PEND_EMER_UNLOCK();
  QCRIL_LOG_FUNC_RETURN_WITH_RET(is_pending_ecall_clearing_status);
  return is_pending_ecall_clearing_status;
}

void qcril_qmi_voice_request_set_tty_mode_wrapper (void* cb_data) {

  const qcril_request_params_type* params = (const qcril_request_params_type*)cb_data;
  qcril_request_return_type ret;
  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_request_set_tty_mode(params, &ret);
  QCRIL_LOG_FUNC_RETURN();

}

void qcril_voice_query_tty_mode_wrapper(void* cb_data) {

  const qcril_request_params_type* params = (const qcril_request_params_type*)cb_data;
  qcril_request_return_type ret;
  QCRIL_LOG_FUNC_ENTRY();
  qcril_voice_query_tty_mode(params, &ret);
  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_voice_request_query_preferred_voice_privacy_mode_wrapper(void* cb_data) {
  const qcril_request_params_type* params = (const qcril_request_params_type*)cb_data;
  qcril_request_return_type ret;
  QCRIL_LOG_FUNC_ENTRY();
  qcril_qmi_voice_request_query_preferred_voice_privacy_mode(params, &ret);
  QCRIL_LOG_FUNC_RETURN();

}

#ifdef QMI_RIL_UTF
void qcril_qmi_hal_voice_module_cleanup()
{
    VoiceModule *module = getVoiceModule();
    module->qcrilHalVoiceModuleCleanup();
    qcril_qmi_voice_cleanup();
}
#endif

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_copy_colr_data

===========================================================================*/

void qcril_qmi_voice_copy_colr_data
(
  const voice_get_colr_resp_msg_v02 *const get_colr_resp,
  ims_Colr *colr,
  RIL_Errno ril_result,
  ims_Error *ims_error
)
{
  QCRIL_LOG_FUNC_ENTRY();

  int utf8_len = 0;
  char colr_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];
  if (get_colr_resp->colr_pi_valid && get_colr_resp->colr_pi)
  {
    QCRIL_LOG_INFO( "colr_pi_valid: %d, colr_pi: %d",
      get_colr_resp->colr_pi_valid, get_colr_resp->colr_pi);
  }

  *ims_error = qcril_qmi_ims_map_ril_error_to_ims_error(ril_result);
  if (get_colr_resp->colr_pi_valid != TRUE &&
      get_colr_resp->colr_response_valid != TRUE)
  {
    *ims_error = ims_Error_E_GENERIC_FAILURE;
  }

  if (get_colr_resp->colr_response_valid)
  {
    QCRIL_LOG_INFO("COLR RESP with status %d and provisionStatus %d",
      (int)get_colr_resp->colr_response.active_status,
      (int)get_colr_resp->colr_response.provision_status);
    if (get_colr_resp->colr_response.active_status == ACTIVE_STATUS_INACTIVE_V02)
    {
      colr->has_status = TRUE;
      colr->status = ims_ServiceClassStatus_DISABLED;
    }
    else if (get_colr_resp->colr_response.active_status == ACTIVE_STATUS_ACTIVE_V02)
    {
      colr->has_status = TRUE;
      colr->status = ims_ServiceClassStatus_ENABLED;
    }

    if (get_colr_resp->colr_response.provision_status ==
      PROVISION_STATUS_NOT_PROVISIONED_V02)
    {
      colr->has_provisionStatus = TRUE;
      colr->provisionStatus = ims_ServiceClassProvisionStatus_NOT_PROVISIONED;
    }
    else if (get_colr_resp->colr_response.provision_status ==
      PROVISION_STATUS_PROVISIONED_PERMANENT_V02)
    {
      colr->has_provisionStatus = TRUE;
      /**
       * Consider PROVISION_STATUS_PROVISIONED_PERMANENT as PROVISIONED
       */
      colr->provisionStatus = ims_ServiceClassProvisionStatus_PROVISIONED;
    }
    else if (get_colr_resp->colr_response.provision_status ==
      PROVISION_STATUS_PRESENTATION_ALLOWED_V02)
    {
      colr->has_provisionStatus = TRUE;
      colr->provisionStatus = ims_ServiceClassProvisionStatus_PROVISIONED;
    }
  }

  if (get_colr_resp->colr_pi_valid)
  {
    if (get_colr_resp->colr_pi == COLR_PRESENTATION_NOT_RESTRICTED_V02)
    {
      colr->has_presentation = TRUE;
      colr->presentation = ims_IpPresentation_IP_PRESENTATION_NUM_ALLOWED;
    }
    else if (get_colr_resp->colr_pi == COLR_PRESENTATION_RESTRICTED_V02)
    {
      colr->has_presentation = TRUE;
      colr->presentation = ims_IpPresentation_IP_PRESENTATION_NUM_RESTRICTED;
    }
  }

  if (get_colr_resp->sip_error_code_valid ||
      get_colr_resp->failure_cause_description_valid)
  {
    colr->has_errorDetails = get_colr_resp->sip_error_code_valid;
    if (get_colr_resp->sip_error_code_valid)
    {
      colr->errorDetails.has_sipErrorCode = TRUE;
      colr->errorDetails.sipErrorCode = get_colr_resp->sip_error_code;
      QCRIL_LOG_INFO("sip_error_code %d", colr->errorDetails.sipErrorCode);
    }
    if (get_colr_resp->failure_cause_description_valid)
    {
      memset(colr_sip_err_utf8_str, 0x0, sizeof(colr_sip_err_utf8_str));
      utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
        (char *)get_colr_resp->failure_cause_description,
        get_colr_resp->failure_cause_description_len * 2,
        colr_sip_err_utf8_str,
        sizeof(colr_sip_err_utf8_str));
      utf8_len = utf8_len + 1;
      if (utf8_len > (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN))
      {
        QCRIL_LOG_ERROR("Length exceeds maximum sip error size");
        utf8_len = (int)(QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
        colr_sip_err_utf8_str[utf8_len - 1] = '\0';
      }
      QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET COLR RESP len =%d,"
        "failure_description=%s", utf8_len,
        colr_sip_err_utf8_str);
      colr->errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
      if (colr->errorDetails.sipErrorString.arg)
      {
        strlcpy((char *)colr->errorDetails.sipErrorString.arg,
          colr_sip_err_utf8_str, utf8_len);
        QCRIL_LOG_INFO("sip_error_string %s", colr->errorDetails.sipErrorString.arg);
      }
    }
  }

  QCRIL_LOG_FUNC_RETURN();

}/*qcril_qmi_voice_copy_colr_data*/

/*=========================================================================
  FUNCTION:  qcril_qmi_voice_copy_colp_data

===========================================================================*/

void qcril_qmi_voice_copy_colp_data
(
  const voice_get_colp_resp_msg_v02 *const get_colp_resp,
  ims_SuppSvcResponse *suppSvc,
  RIL_Errno ril_result,
  ims_Error *ims_error
)
{
  QCRIL_LOG_FUNC_ENTRY();

  int utf8_len = 0;
  char colp_sip_err_utf8_str[QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN];

  suppSvc->has_facilityType = TRUE;
  suppSvc->facilityType = ims_SuppSvcFacilityType_FACILITY_COLP;

  *ims_error = qcril_qmi_ims_map_ril_error_to_ims_error(ril_result);
  if (get_colp_resp->colp_response_valid != TRUE)
  {
    *ims_error = ims_Error_E_GENERIC_FAILURE;
  }

  if (get_colp_resp->colp_response_valid)
  {
    QCRIL_LOG_INFO("COLP RESP with status %d and provisionStatus %d",
      (int)get_colp_resp->colp_response.active_status,
      (int)get_colp_resp->colp_response.provision_status);
    if (get_colp_resp->colp_response.active_status == ACTIVE_STATUS_INACTIVE_V02)
    {
      suppSvc->has_status = TRUE;
      suppSvc->status = ims_ServiceClassStatus_DISABLED;
    }
    else if (get_colp_resp->colp_response.active_status == ACTIVE_STATUS_ACTIVE_V02)
    {
      suppSvc->has_status = TRUE;
      suppSvc->status = ims_ServiceClassStatus_ENABLED;
    }

    if (get_colp_resp->colp_response.provision_status ==
      PROVISION_STATUS_NOT_PROVISIONED_V02)
    {
      suppSvc->has_provisionStatus = TRUE;
      suppSvc->provisionStatus = ims_ServiceClassProvisionStatus_NOT_PROVISIONED;
    }
    else if (get_colp_resp->colp_response.provision_status ==
      PROVISION_STATUS_PROVISIONED_PERMANENT_V02)
    {
      suppSvc->has_provisionStatus = TRUE;
      /**
       * consider PROVISION_STATUS_PROVISIONED_PERMANENT as PROVISIONED
       */
      suppSvc->provisionStatus = ims_ServiceClassProvisionStatus_PROVISIONED;
    }
    else if (get_colp_resp->colp_response.provision_status ==
      PROVISION_STATUS_PRESENTATION_ALLOWED_V02)
    {
      suppSvc->has_provisionStatus = TRUE;
      suppSvc->provisionStatus = ims_ServiceClassProvisionStatus_PROVISIONED;
    }
  }

  if (get_colp_resp->sip_error_code_valid ||
    get_colp_resp->failure_cause_description_valid)
  {
    suppSvc->has_errorDetails = get_colp_resp->sip_error_code_valid;
    if (get_colp_resp->sip_error_code_valid)
    {
      suppSvc->errorDetails.has_sipErrorCode = TRUE;
      suppSvc->errorDetails.sipErrorCode = get_colp_resp->sip_error_code;
      QCRIL_LOG_INFO("sip_error_code %d", suppSvc->errorDetails.sipErrorCode);
    }
    if (get_colp_resp->failure_cause_description_valid)
    {
      memset(colp_sip_err_utf8_str, 0x0, sizeof(colp_sip_err_utf8_str));
      utf8_len = qcril_cm_ss_convert_ucs2_to_utf8(
        (char *)get_colp_resp->failure_cause_description,
        get_colp_resp->failure_cause_description_len * 2,
        colp_sip_err_utf8_str,
        sizeof(colp_sip_err_utf8_str));
      utf8_len = utf8_len + 1;
      if (utf8_len > (QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN))
      {
        QCRIL_LOG_ERROR("Length exceeds maximum sip error size");
        utf8_len = (int)(QCRIL_QMI_VOICE_MAX_SUPS_FAILURE_STR_LEN);
        colp_sip_err_utf8_str[utf8_len - 1] = '\0';
      }
      QCRIL_LOG_DEBUG("QCRIL QMI VOICE GET COLP RESP len =%d,"
        "failure_description=%s", utf8_len,
        colp_sip_err_utf8_str);
      suppSvc->errorDetails.sipErrorString.arg = qcril_malloc(utf8_len);
      if (suppSvc->errorDetails.sipErrorString.arg)
      {
        strlcpy((char *)suppSvc->errorDetails.sipErrorString.arg,
          colp_sip_err_utf8_str, utf8_len);
        QCRIL_LOG_INFO("sip_error_string %s", suppSvc->errorDetails.sipErrorString.arg);
      }
    }
  }

  QCRIL_LOG_FUNC_RETURN();

} /*qcril_qmi_voice_copy_colp_data*/
