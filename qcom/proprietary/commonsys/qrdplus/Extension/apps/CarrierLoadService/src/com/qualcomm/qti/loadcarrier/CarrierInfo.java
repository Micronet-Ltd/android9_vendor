/**
 * Copyright (c) 2015 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

package com.qualcomm.qti.loadcarrier;

import android.text.TextUtils;
import android.util.Log;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Save the information of carrier packages and check if the given info matches.
 * Parse the contents of the .preloadspec file in the carrier package.
 */
public class CarrierInfo {
    private static final String TAG = "SIMTrigger/CarrierInfo";
    /**
     * Normal key words for matching. if the value of one of key words is not null,
     * it means the given infomation must match this value.
     */
    public static final String KEYWORD_MCCMNC = "MCCMNC";
    public static final String KEYWORD_MCC    = "MCC";
    public static final String KEYWORD_MNC    = "MNC";
    public static final String KEYWORD_SPN    = "SPN";
    public static final String KEYWORD_GID1   = "GID1";
    public static final String KEYWORD_GID2   = "GID2";
    public static final String KEYWORD_IMSI   = "IMSI";
    public static final String KEYWORD_MVNO    = "MVNO";

    /**
     * A special key word which is normally used for display. Set the system property
     * {@link Utils#PROP_KEY_TRIGGER_BRAND} to true or it won't be used for matching.
     */
    public static final String KEYWORD_BRAND  = "BRAND";

    /**
     * The unique identifier of a package. If {@link #KEYWORD_BRAND} is null, it will
     * be used for display instead of {@link #KEYWORD_BRAND}.
     */
    public static final String KEYWORD_NAME   = "NAME";

    /**
     * Additional information. These keys are necessary for UI layer. They are generated by
     * the matching or scanning process automatically and added into carrier's contents.
     */
    public static final String KEYWORD_SUB_MASK    = "subMask";
    public static final String KEYWORD_HAS_COM_MBN = "hasCommercialMbn";
    public static final String KEYWORD_HAS_ROW_MBN = "hasROWMbn";

    // Key symbols
    private static final String SEP_BLANK = " ";
    private static final String SEP_EQUAL = "=";
    private static final String SEP_COMMA = ",";
    private static final String SEP_QUOTE = "\"";
    // Special regex for IMSI
    // E.g. IMSI="8-10:234-678"
    private static final String IMSI_ITEM_REGEX =
            "(\\d+)" +  /* The start digit */
            "-(\\d+)" + /* The end digit */
            ":(\\d+)" + /* The lower bound*/
            "-(\\d+)";  /* The upper bound*/
    private static final int IMSI_ITEM_REGEX_GROUP_NUM = 4;
    private static Pattern imsiItemPattern = null;

    private static final int MCC_LENGTH     = 3;
    private static final int MNC_LENGTH_MIN = 2;
    private static final int MNC_LENGTH_MAX = 3;

    private String mContents = null;
    private HashMap<String, String> mContentItems = null;

    public CarrierInfo(String contents) {
        if (imsiItemPattern == null) {
            imsiItemPattern = Pattern.compile(IMSI_ITEM_REGEX);
        }
        if (TextUtils.isEmpty(contents)) {
            return;
        }
        mContents = contents.trim();
        parseContents();
    }

    /**
     * Transform a pair of key-value into a String.
     */
    public static String contentItemToString(String key, String value) {
        if (TextUtils.isEmpty(key)) {
            return null;
        }
        if (TextUtils.isEmpty(value)) {
            value = "";
        }
        return SEP_BLANK + key + SEP_EQUAL + SEP_QUOTE + value + SEP_QUOTE;
    }

    public boolean hasMatchPoints() {
        return !(TextUtils.isEmpty(getValue(KEYWORD_MCCMNC))
                && TextUtils.isEmpty(getValue(KEYWORD_MCC))
                && TextUtils.isEmpty(getValue(KEYWORD_MNC))
                && TextUtils.isEmpty(getValue(KEYWORD_SPN))
                && TextUtils.isEmpty(getValue(KEYWORD_GID1))
                && TextUtils.isEmpty(getValue(KEYWORD_GID2))
                && TextUtils.isEmpty(getValue(KEYWORD_IMSI)));
    }

    public boolean matchesMCCMNC(String mcc, String mnc) {
        String itemMccMncString = getValue(KEYWORD_MCCMNC);
        if (TextUtils.isEmpty(itemMccMncString)) {
            return true;
        }
        if (TextUtils.isEmpty(mcc) || TextUtils.isEmpty(mnc)) {
            return false;
        }

        if (Utils.DEBUG) Log.d(TAG, "itemMCCMNC:" + itemMccMncString);

        boolean matched = false;
        String[] itemMccMncs = itemMccMncString.split(SEP_COMMA);
        for (String itemMccMnc : itemMccMncs) {
            if ((itemMccMnc.length() >= MCC_LENGTH + MNC_LENGTH_MIN)
                    && (itemMccMnc.length() <= MCC_LENGTH + MNC_LENGTH_MAX)) {
                if (itemMccMnc.equals(mcc + mnc)) {
                    matched = true;
                    break;
                }
            } else if (itemMccMnc.length() == MCC_LENGTH) {
                if (itemMccMnc.equals(mcc)) {
                    matched = true;
                    break;
                }
            } else {
                if (Utils.DEBUG) Log.d(TAG, "INVALID value in MCCMNC item. value=" + itemMccMnc);
            }
        }

        if (matched) {
            if (Utils.DEBUG) Log.d(TAG, "MCCMNC item matched");
        }

        return matched;
    }

    public boolean matchesMCC(String mcc) {
        return matchesCommon(KEYWORD_MCC, mcc);
    }

    public boolean matchesMNC(String mnc) {
        return matchesCommon(KEYWORD_MNC, mnc);
    }

    public boolean matchesSPN(String spn) {
        return matchesCommon(KEYWORD_SPN, spn);
    }
	
    public boolean matchesMVNO(String mvno) {
        return matchesCommon(KEYWORD_MVNO, mvno);
    }

    public boolean matchesGID1(String gid1) {
        return matchesCommon(KEYWORD_GID1, gid1);
    }

    public boolean matchesGID2(String gid2) {
        return matchesCommon(KEYWORD_GID2, gid2);
    }

    public boolean matchesIMSI(String imsi) {
        String itemIMSIString = getValue(KEYWORD_IMSI);
        if (TextUtils.isEmpty(itemIMSIString)) {
            return true;
        }
        if (TextUtils.isEmpty(imsi)) {
            return false;
        }

        if (Utils.DEBUG) Log.d(TAG, "itemIMSI:" + itemIMSIString);

        String[] itemIMSIs = itemIMSIString.split(SEP_COMMA);
        for (String itemIMSI : itemIMSIs) {
            Matcher m = imsiItemPattern.matcher(itemIMSI);
            if (!m.matches() || m.groupCount() < IMSI_ITEM_REGEX_GROUP_NUM) {
                Log.e(TAG, "INVALID IMSI item. itemIMSI=" + itemIMSI);
                continue;
            }
            final int digitLow = Integer.parseInt(m.group(1));
            final int digitHigh = Integer.parseInt(m.group(2));
            final int lowerBound = Integer.parseInt(m.group(3));
            final int upperBound = Integer.parseInt(m.group(4));
            final int value = Integer.parseInt(imsi.substring(digitLow - 1, digitHigh));
            if ((value <= upperBound) && (value >= lowerBound)) {
                if (Utils.DEBUG) Log.d(TAG, "IMSI item matched");
                return true;
            }
        }

        return false;
    }

    public boolean matchesBRAND(String brand) {
        return matchesCommon(KEYWORD_BRAND, brand);
    }

    private boolean matchesCommon(String key, String value) {
        String itemValueString = getValue(key);
        if (TextUtils.isEmpty(itemValueString)) {
            return true;
        }
        if (TextUtils.isEmpty(value)) {
            return false;
        }

        if (Utils.DEBUG) Log.d(TAG, "item" + key + ":" + itemValueString);

        String[] itemValues = itemValueString.split(SEP_COMMA);
        for (String itemValue : itemValues) {
            if (itemValue.equals(value)) {
                if (Utils.DEBUG) Log.d(TAG, key + " item matched");
                return true;
            }
        }
        return false;
    }

    public String getValue(String key) {
        if (TextUtils.isEmpty(key)) {
            return null;
        }

        if (mContentItems == null || mContentItems.size() < 1) {
            return null;
        }

        return mContentItems.get(formatKey(key));
    }

    private void parseContents() {
        if (TextUtils.isEmpty(mContents)) {
            return;
        }
        if (mContentItems == null) {
            mContentItems = new HashMap<String, String>();
        }
        mContentItems.clear();

        String[] items = mContents.split(SEP_QUOTE);
        for (int i = 0; i < items.length - 1; i += 2) {
            if (!items[i].endsWith(SEP_EQUAL)) {
                Log.e(TAG, "Parsing contents error. contents:" + mContents + " item[" + i + "]:"
                        + items[i]);
                mContentItems.clear();
                return;
            } else {
                mContentItems.put(formatKey(items[i].trim().replace(SEP_EQUAL, "")), items[i+1]);
            }
        }
    }

    private String formatKey(String key) {
        return key.toUpperCase();
    }
}
